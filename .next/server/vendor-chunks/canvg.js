"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/canvg";
exports.ids = ["vendor-chunks/canvg"];
exports.modules = {

/***/ "(ssr)/./node_modules/canvg/lib/index.es.js":
/*!********************************************!*\
  !*** ./node_modules/canvg/lib/index.es.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AElement: () => (/* binding */ AElement),\n/* harmony export */   AnimateColorElement: () => (/* binding */ AnimateColorElement),\n/* harmony export */   AnimateElement: () => (/* binding */ AnimateElement),\n/* harmony export */   AnimateTransformElement: () => (/* binding */ AnimateTransformElement),\n/* harmony export */   BoundingBox: () => (/* binding */ BoundingBox),\n/* harmony export */   CB1: () => (/* binding */ CB1),\n/* harmony export */   CB2: () => (/* binding */ CB2),\n/* harmony export */   CB3: () => (/* binding */ CB3),\n/* harmony export */   CB4: () => (/* binding */ CB4),\n/* harmony export */   Canvg: () => (/* binding */ Canvg),\n/* harmony export */   CircleElement: () => (/* binding */ CircleElement),\n/* harmony export */   ClipPathElement: () => (/* binding */ ClipPathElement),\n/* harmony export */   DefsElement: () => (/* binding */ DefsElement),\n/* harmony export */   DescElement: () => (/* binding */ DescElement),\n/* harmony export */   Document: () => (/* binding */ Document),\n/* harmony export */   Element: () => (/* binding */ Element),\n/* harmony export */   EllipseElement: () => (/* binding */ EllipseElement),\n/* harmony export */   FeColorMatrixElement: () => (/* binding */ FeColorMatrixElement),\n/* harmony export */   FeCompositeElement: () => (/* binding */ FeCompositeElement),\n/* harmony export */   FeDropShadowElement: () => (/* binding */ FeDropShadowElement),\n/* harmony export */   FeGaussianBlurElement: () => (/* binding */ FeGaussianBlurElement),\n/* harmony export */   FeMorphologyElement: () => (/* binding */ FeMorphologyElement),\n/* harmony export */   FilterElement: () => (/* binding */ FilterElement),\n/* harmony export */   Font: () => (/* binding */ Font),\n/* harmony export */   FontElement: () => (/* binding */ FontElement),\n/* harmony export */   FontFaceElement: () => (/* binding */ FontFaceElement),\n/* harmony export */   GElement: () => (/* binding */ GElement),\n/* harmony export */   GlyphElement: () => (/* binding */ GlyphElement),\n/* harmony export */   GradientElement: () => (/* binding */ GradientElement),\n/* harmony export */   ImageElement: () => (/* binding */ ImageElement),\n/* harmony export */   LineElement: () => (/* binding */ LineElement),\n/* harmony export */   LinearGradientElement: () => (/* binding */ LinearGradientElement),\n/* harmony export */   MarkerElement: () => (/* binding */ MarkerElement),\n/* harmony export */   MaskElement: () => (/* binding */ MaskElement),\n/* harmony export */   Matrix: () => (/* binding */ Matrix),\n/* harmony export */   MissingGlyphElement: () => (/* binding */ MissingGlyphElement),\n/* harmony export */   Mouse: () => (/* binding */ Mouse),\n/* harmony export */   PSEUDO_ZERO: () => (/* binding */ PSEUDO_ZERO),\n/* harmony export */   Parser: () => (/* binding */ Parser),\n/* harmony export */   PathElement: () => (/* binding */ PathElement),\n/* harmony export */   PathParser: () => (/* binding */ PathParser),\n/* harmony export */   PatternElement: () => (/* binding */ PatternElement),\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   PolygonElement: () => (/* binding */ PolygonElement),\n/* harmony export */   PolylineElement: () => (/* binding */ PolylineElement),\n/* harmony export */   Property: () => (/* binding */ Property),\n/* harmony export */   QB1: () => (/* binding */ QB1),\n/* harmony export */   QB2: () => (/* binding */ QB2),\n/* harmony export */   QB3: () => (/* binding */ QB3),\n/* harmony export */   RadialGradientElement: () => (/* binding */ RadialGradientElement),\n/* harmony export */   RectElement: () => (/* binding */ RectElement),\n/* harmony export */   RenderedElement: () => (/* binding */ RenderedElement),\n/* harmony export */   Rotate: () => (/* binding */ Rotate),\n/* harmony export */   SVGElement: () => (/* binding */ SVGElement),\n/* harmony export */   SVGFontLoader: () => (/* binding */ SVGFontLoader),\n/* harmony export */   Scale: () => (/* binding */ Scale),\n/* harmony export */   Screen: () => (/* binding */ Screen),\n/* harmony export */   Skew: () => (/* binding */ Skew),\n/* harmony export */   SkewX: () => (/* binding */ SkewX),\n/* harmony export */   SkewY: () => (/* binding */ SkewY),\n/* harmony export */   StopElement: () => (/* binding */ StopElement),\n/* harmony export */   StyleElement: () => (/* binding */ StyleElement),\n/* harmony export */   SymbolElement: () => (/* binding */ SymbolElement),\n/* harmony export */   TRefElement: () => (/* binding */ TRefElement),\n/* harmony export */   TSpanElement: () => (/* binding */ TSpanElement),\n/* harmony export */   TextElement: () => (/* binding */ TextElement),\n/* harmony export */   TextPathElement: () => (/* binding */ TextPathElement),\n/* harmony export */   TitleElement: () => (/* binding */ TitleElement),\n/* harmony export */   Transform: () => (/* binding */ Transform),\n/* harmony export */   Translate: () => (/* binding */ Translate),\n/* harmony export */   UnknownElement: () => (/* binding */ UnknownElement),\n/* harmony export */   UseElement: () => (/* binding */ UseElement),\n/* harmony export */   ViewPort: () => (/* binding */ ViewPort),\n/* harmony export */   compressSpaces: () => (/* binding */ compressSpaces),\n/* harmony export */   \"default\": () => (/* binding */ Canvg),\n/* harmony export */   getSelectorSpecificity: () => (/* binding */ getSelectorSpecificity),\n/* harmony export */   normalizeAttributeName: () => (/* binding */ normalizeAttributeName),\n/* harmony export */   normalizeColor: () => (/* binding */ normalizeColor),\n/* harmony export */   parseExternalUrl: () => (/* binding */ parseExternalUrl),\n/* harmony export */   presets: () => (/* binding */ index),\n/* harmony export */   toNumbers: () => (/* binding */ toNumbers),\n/* harmony export */   trimLeft: () => (/* binding */ trimLeft),\n/* harmony export */   trimRight: () => (/* binding */ trimRight),\n/* harmony export */   vectorMagnitude: () => (/* binding */ vectorMagnitude),\n/* harmony export */   vectorsAngle: () => (/* binding */ vectorsAngle),\n/* harmony export */   vectorsRatio: () => (/* binding */ vectorsRatio)\n/* harmony export */ });\n/* harmony import */ var core_js_modules_es_promise_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.promise.js */ \"(ssr)/./node_modules/core-js/modules/es.promise.js\");\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"(ssr)/./node_modules/@babel/runtime/helpers/asyncToGenerator.js\");\n/* harmony import */ var core_js_modules_es_string_match_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es.string.match.js */ \"(ssr)/./node_modules/core-js/modules/es.string.match.js\");\n/* harmony import */ var core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/es.string.replace.js */ \"(ssr)/./node_modules/core-js/modules/es.string.replace.js\");\n/* harmony import */ var core_js_modules_es_string_starts_with_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! core-js/modules/es.string.starts-with.js */ \"(ssr)/./node_modules/core-js/modules/es.string.starts-with.js\");\n/* harmony import */ var core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"(ssr)/./node_modules/core-js/modules/es.array.iterator.js\");\n/* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"(ssr)/./node_modules/core-js/modules/web.dom-collections.iterator.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var core_js_modules_es_array_reduce_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! core-js/modules/es.array.reduce.js */ \"(ssr)/./node_modules/core-js/modules/es.array.reduce.js\");\n/* harmony import */ var core_js_modules_es_string_ends_with_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! core-js/modules/es.string.ends-with.js */ \"(ssr)/./node_modules/core-js/modules/es.string.ends-with.js\");\n/* harmony import */ var core_js_modules_es_string_split_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! core-js/modules/es.string.split.js */ \"(ssr)/./node_modules/core-js/modules/es.string.split.js\");\n/* harmony import */ var raf__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! raf */ \"(ssr)/./node_modules/raf/index.js\");\n/* harmony import */ var core_js_modules_es_string_trim_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! core-js/modules/es.string.trim.js */ \"(ssr)/./node_modules/core-js/modules/es.string.trim.js\");\n/* harmony import */ var rgbcolor__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! rgbcolor */ \"(ssr)/./node_modules/rgbcolor/index.js\");\n/* harmony import */ var core_js_modules_es_array_index_of_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"(ssr)/./node_modules/core-js/modules/es.array.index-of.js\");\n/* harmony import */ var core_js_modules_es_string_includes_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! core-js/modules/es.string.includes.js */ \"(ssr)/./node_modules/core-js/modules/es.string.includes.js\");\n/* harmony import */ var core_js_modules_es_array_reverse_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! core-js/modules/es.array.reverse.js */ \"(ssr)/./node_modules/core-js/modules/es.array.reverse.js\");\n/* harmony import */ var svg_pathdata__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! svg-pathdata */ \"(ssr)/./node_modules/svg-pathdata/lib/SVGPathData.module.js\");\n/* harmony import */ var core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! core-js/modules/es.regexp.to-string.js */ \"(ssr)/./node_modules/core-js/modules/es.regexp.to-string.js\");\n/* harmony import */ var stackblur_canvas__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! stackblur-canvas */ \"(ssr)/./node_modules/stackblur-canvas/dist/stackblur-es.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\r\n * Options preset for `OffscreenCanvas`.\r\n * @param config - Preset requirements.\r\n * @param config.DOMParser - XML/HTML parser from string into DOM Document.\r\n * @returns Preset object.\r\n */ function offscreen() {\n    var { DOMParser: DOMParserFallback } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var preset = {\n        window: null,\n        ignoreAnimation: true,\n        ignoreMouse: true,\n        DOMParser: DOMParserFallback,\n        createCanvas (width, height) {\n            return new OffscreenCanvas(width, height);\n        },\n        createImage (url) {\n            return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n                var response = yield fetch(url);\n                var blob = yield response.blob();\n                var img = yield createImageBitmap(blob);\n                return img;\n            })();\n        }\n    };\n    if (typeof DOMParser !== \"undefined\" || typeof DOMParserFallback === \"undefined\") {\n        Reflect.deleteProperty(preset, \"DOMParser\");\n    }\n    return preset;\n}\n/**\r\n * Options preset for `node-canvas`.\r\n * @param config - Preset requirements.\r\n * @param config.DOMParser - XML/HTML parser from string into DOM Document.\r\n * @param config.canvas - `node-canvas` exports.\r\n * @param config.fetch - WHATWG-compatible `fetch` function.\r\n * @returns Preset object.\r\n */ function node(_ref) {\n    var { DOMParser: DOMParser1, canvas, fetch: fetch1 } = _ref;\n    return {\n        window: null,\n        ignoreAnimation: true,\n        ignoreMouse: true,\n        DOMParser: DOMParser1,\n        fetch: fetch1,\n        createCanvas: canvas.createCanvas,\n        createImage: canvas.loadImage\n    };\n}\nvar index = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    offscreen: offscreen,\n    node: node\n});\n/**\r\n * HTML-safe compress white-spaces.\r\n * @param str - String to compress.\r\n * @returns String.\r\n */ function compressSpaces(str) {\n    return str.replace(/(?!\\u3000)\\s+/gm, \" \");\n}\n/**\r\n * HTML-safe left trim.\r\n * @param str - String to trim.\r\n * @returns String.\r\n */ function trimLeft(str) {\n    return str.replace(/^[\\n \\t]+/, \"\");\n}\n/**\r\n * HTML-safe right trim.\r\n * @param str - String to trim.\r\n * @returns String.\r\n */ function trimRight(str) {\n    return str.replace(/[\\n \\t]+$/, \"\");\n}\n/**\r\n * String to numbers array.\r\n * @param str - Numbers string.\r\n * @returns Numbers array.\r\n */ function toNumbers(str) {\n    var matches = (str || \"\").match(/-?(\\d+(?:\\.\\d*(?:[eE][+-]?\\d+)?)?|\\.\\d+)(?=\\D|$)/gm) || [];\n    return matches.map(parseFloat);\n} // Microsoft Edge fix\nvar allUppercase = /^[A-Z-]+$/;\n/**\r\n * Normalize attribute name.\r\n * @param name - Attribute name.\r\n * @returns Normalized attribute name.\r\n */ function normalizeAttributeName(name) {\n    if (allUppercase.test(name)) {\n        return name.toLowerCase();\n    }\n    return name;\n}\n/**\r\n * Parse external URL.\r\n * @param url - CSS url string.\r\n * @returns Parsed URL.\r\n */ function parseExternalUrl(url) {\n    //                      single quotes [2]\n    //                      v         double quotes [3]\n    //                      v         v         no quotes [4]\n    //                      v         v         v\n    var urlMatch = /url\\(('([^']+)'|\"([^\"]+)\"|([^'\")]+))\\)/.exec(url) || [];\n    return urlMatch[2] || urlMatch[3] || urlMatch[4];\n}\n/**\r\n * Transform floats to integers in rgb colors.\r\n * @param color - Color to normalize.\r\n * @returns Normalized color.\r\n */ function normalizeColor(color) {\n    if (!color.startsWith(\"rgb\")) {\n        return color;\n    }\n    var rgbParts = 3;\n    var normalizedColor = color.replace(/\\d+(\\.\\d+)?/g, (num, isFloat)=>rgbParts-- && isFloat ? String(Math.round(parseFloat(num))) : num);\n    return normalizedColor;\n}\n// slightly modified version of https://github.com/keeganstreet/specificity/blob/master/specificity.js\nvar attributeRegex = /(\\[[^\\]]+\\])/g;\nvar idRegex = /(#[^\\s+>~.[:]+)/g;\nvar classRegex = /(\\.[^\\s+>~.[:]+)/g;\nvar pseudoElementRegex = /(::[^\\s+>~.[:]+|:first-line|:first-letter|:before|:after)/gi;\nvar pseudoClassWithBracketsRegex = /(:[\\w-]+\\([^)]*\\))/gi;\nvar pseudoClassRegex = /(:[^\\s+>~.[:]+)/g;\nvar elementRegex = /([^\\s+>~.[:]+)/g;\nfunction findSelectorMatch(selector, regex) {\n    var matches = regex.exec(selector);\n    if (!matches) {\n        return [\n            selector,\n            0\n        ];\n    }\n    return [\n        selector.replace(regex, \" \"),\n        matches.length\n    ];\n}\n/**\r\n * Measure selector specificity.\r\n * @param selector - Selector to measure.\r\n * @returns Specificity.\r\n */ function getSelectorSpecificity(selector) {\n    var specificity = [\n        0,\n        0,\n        0\n    ];\n    var currentSelector = selector.replace(/:not\\(([^)]*)\\)/g, \"     $1 \").replace(/{[\\s\\S]*/gm, \" \");\n    var delta = 0;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, attributeRegex);\n    specificity[1] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, idRegex);\n    specificity[0] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, classRegex);\n    specificity[1] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoElementRegex);\n    specificity[2] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassWithBracketsRegex);\n    specificity[1] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassRegex);\n    specificity[1] += delta;\n    currentSelector = currentSelector.replace(/[*\\s+>~]/g, \" \").replace(/[#.]/g, \" \");\n    [currentSelector, delta] = findSelectorMatch(currentSelector, elementRegex); // lgtm [js/useless-assignment-to-local]\n    specificity[2] += delta;\n    return specificity.join(\"\");\n}\nvar PSEUDO_ZERO = .00000001;\n/**\r\n * Vector magnitude.\r\n * @param v\r\n * @returns Number result.\r\n */ function vectorMagnitude(v) {\n    return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));\n}\n/**\r\n * Ratio between two vectors.\r\n * @param u\r\n * @param v\r\n * @returns Number result.\r\n */ function vectorsRatio(u, v) {\n    return (u[0] * v[0] + u[1] * v[1]) / (vectorMagnitude(u) * vectorMagnitude(v));\n}\n/**\r\n * Angle between two vectors.\r\n * @param u\r\n * @param v\r\n * @returns Number result.\r\n */ function vectorsAngle(u, v) {\n    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vectorsRatio(u, v));\n}\nfunction CB1(t) {\n    return t * t * t;\n}\nfunction CB2(t) {\n    return 3 * t * t * (1 - t);\n}\nfunction CB3(t) {\n    return 3 * t * (1 - t) * (1 - t);\n}\nfunction CB4(t) {\n    return (1 - t) * (1 - t) * (1 - t);\n}\nfunction QB1(t) {\n    return t * t;\n}\nfunction QB2(t) {\n    return 2 * t * (1 - t);\n}\nfunction QB3(t) {\n    return (1 - t) * (1 - t);\n}\nclass Property {\n    constructor(document1, name, value){\n        this.document = document1;\n        this.name = name;\n        this.value = value;\n        this.isNormalizedColor = false;\n    }\n    static empty(document1) {\n        return new Property(document1, \"EMPTY\", \"\");\n    }\n    split() {\n        var separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \" \";\n        var { document: document1, name } = this;\n        return compressSpaces(this.getString()).trim().split(separator).map((value)=>new Property(document1, name, value));\n    }\n    hasValue(zeroIsValue) {\n        var { value } = this;\n        return value !== null && value !== \"\" && (zeroIsValue || value !== 0) && typeof value !== \"undefined\";\n    }\n    isString(regexp) {\n        var { value } = this;\n        var result = typeof value === \"string\";\n        if (!result || !regexp) {\n            return result;\n        }\n        return regexp.test(value);\n    }\n    isUrlDefinition() {\n        return this.isString(/^url\\(/);\n    }\n    isPixels() {\n        if (!this.hasValue()) {\n            return false;\n        }\n        var asString = this.getString();\n        switch(true){\n            case asString.endsWith(\"px\"):\n            case /^[0-9]+$/.test(asString):\n                return true;\n            default:\n                return false;\n        }\n    }\n    setValue(value) {\n        this.value = value;\n        return this;\n    }\n    getValue(def) {\n        if (typeof def === \"undefined\" || this.hasValue()) {\n            return this.value;\n        }\n        return def;\n    }\n    getNumber(def) {\n        if (!this.hasValue()) {\n            if (typeof def === \"undefined\") {\n                return 0;\n            }\n            return parseFloat(def);\n        }\n        var { value } = this;\n        var n = parseFloat(value);\n        if (this.isString(/%$/)) {\n            n /= 100.0;\n        }\n        return n;\n    }\n    getString(def) {\n        if (typeof def === \"undefined\" || this.hasValue()) {\n            return typeof this.value === \"undefined\" ? \"\" : String(this.value);\n        }\n        return String(def);\n    }\n    getColor(def) {\n        var color = this.getString(def);\n        if (this.isNormalizedColor) {\n            return color;\n        }\n        this.isNormalizedColor = true;\n        color = normalizeColor(color);\n        this.value = color;\n        return color;\n    }\n    getDpi() {\n        return 96.0; // TODO: compute?\n    }\n    getRem() {\n        return this.document.rootEmSize;\n    }\n    getEm() {\n        return this.document.emSize;\n    }\n    getUnits() {\n        return this.getString().replace(/[0-9.-]/g, \"\");\n    }\n    getPixels(axisOrIsFontSize) {\n        var processPercent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        if (!this.hasValue()) {\n            return 0;\n        }\n        var [axis, isFontSize] = typeof axisOrIsFontSize === \"boolean\" ? [\n            undefined,\n            axisOrIsFontSize\n        ] : [\n            axisOrIsFontSize\n        ];\n        var { viewPort } = this.document.screen;\n        switch(true){\n            case this.isString(/vmin$/):\n                return this.getNumber() / 100.0 * Math.min(viewPort.computeSize(\"x\"), viewPort.computeSize(\"y\"));\n            case this.isString(/vmax$/):\n                return this.getNumber() / 100.0 * Math.max(viewPort.computeSize(\"x\"), viewPort.computeSize(\"y\"));\n            case this.isString(/vw$/):\n                return this.getNumber() / 100.0 * viewPort.computeSize(\"x\");\n            case this.isString(/vh$/):\n                return this.getNumber() / 100.0 * viewPort.computeSize(\"y\");\n            case this.isString(/rem$/):\n                return this.getNumber() * this.getRem();\n            case this.isString(/em$/):\n                return this.getNumber() * this.getEm();\n            case this.isString(/ex$/):\n                return this.getNumber() * this.getEm() / 2.0;\n            case this.isString(/px$/):\n                return this.getNumber();\n            case this.isString(/pt$/):\n                return this.getNumber() * this.getDpi() * (1.0 / 72.0);\n            case this.isString(/pc$/):\n                return this.getNumber() * 15;\n            case this.isString(/cm$/):\n                return this.getNumber() * this.getDpi() / 2.54;\n            case this.isString(/mm$/):\n                return this.getNumber() * this.getDpi() / 25.4;\n            case this.isString(/in$/):\n                return this.getNumber() * this.getDpi();\n            case this.isString(/%$/) && isFontSize:\n                return this.getNumber() * this.getEm();\n            case this.isString(/%$/):\n                return this.getNumber() * viewPort.computeSize(axis);\n            default:\n                {\n                    var n = this.getNumber();\n                    if (processPercent && n < 1.0) {\n                        return n * viewPort.computeSize(axis);\n                    }\n                    return n;\n                }\n        }\n    }\n    getMilliseconds() {\n        if (!this.hasValue()) {\n            return 0;\n        }\n        if (this.isString(/ms$/)) {\n            return this.getNumber();\n        }\n        return this.getNumber() * 1000;\n    }\n    getRadians() {\n        if (!this.hasValue()) {\n            return 0;\n        }\n        switch(true){\n            case this.isString(/deg$/):\n                return this.getNumber() * (Math.PI / 180.0);\n            case this.isString(/grad$/):\n                return this.getNumber() * (Math.PI / 200.0);\n            case this.isString(/rad$/):\n                return this.getNumber();\n            default:\n                return this.getNumber() * (Math.PI / 180.0);\n        }\n    }\n    getDefinition() {\n        var asString = this.getString();\n        var name = /#([^)'\"]+)/.exec(asString);\n        if (name) {\n            name = name[1];\n        }\n        if (!name) {\n            name = asString;\n        }\n        return this.document.definitions[name];\n    }\n    getFillStyleDefinition(element, opacity) {\n        var def = this.getDefinition();\n        if (!def) {\n            return null;\n        } // gradient\n        if (typeof def.createGradient === \"function\") {\n            return def.createGradient(this.document.ctx, element, opacity);\n        } // pattern\n        if (typeof def.createPattern === \"function\") {\n            if (def.getHrefAttribute().hasValue()) {\n                var patternTransform = def.getAttribute(\"patternTransform\");\n                def = def.getHrefAttribute().getDefinition();\n                if (patternTransform.hasValue()) {\n                    def.getAttribute(\"patternTransform\", true).setValue(patternTransform.value);\n                }\n            }\n            return def.createPattern(this.document.ctx, element, opacity);\n        }\n        return null;\n    }\n    getTextBaseline() {\n        if (!this.hasValue()) {\n            return null;\n        }\n        return Property.textBaselineMapping[this.getString()];\n    }\n    addOpacity(opacity) {\n        var value = this.getColor();\n        var len = value.length;\n        var commas = 0; // Simulate old RGBColor version, which can't parse rgba.\n        for(var i = 0; i < len; i++){\n            if (value[i] === \",\") {\n                commas++;\n            }\n            if (commas === 3) {\n                break;\n            }\n        }\n        if (opacity.hasValue() && this.isString() && commas !== 3) {\n            var color = new rgbcolor__WEBPACK_IMPORTED_MODULE_13__(value);\n            if (color.ok) {\n                color.alpha = opacity.getNumber();\n                value = color.toRGBA();\n            }\n        }\n        return new Property(this.document, this.name, value);\n    }\n}\nProperty.textBaselineMapping = {\n    \"baseline\": \"alphabetic\",\n    \"before-edge\": \"top\",\n    \"text-before-edge\": \"top\",\n    \"middle\": \"middle\",\n    \"central\": \"middle\",\n    \"after-edge\": \"bottom\",\n    \"text-after-edge\": \"bottom\",\n    \"ideographic\": \"ideographic\",\n    \"alphabetic\": \"alphabetic\",\n    \"hanging\": \"hanging\",\n    \"mathematical\": \"alphabetic\"\n};\nclass ViewPort {\n    constructor(){\n        this.viewPorts = [];\n    }\n    clear() {\n        this.viewPorts = [];\n    }\n    setCurrent(width, height) {\n        this.viewPorts.push({\n            width,\n            height\n        });\n    }\n    removeCurrent() {\n        this.viewPorts.pop();\n    }\n    getCurrent() {\n        var { viewPorts } = this;\n        return viewPorts[viewPorts.length - 1];\n    }\n    get width() {\n        return this.getCurrent().width;\n    }\n    get height() {\n        return this.getCurrent().height;\n    }\n    computeSize(d) {\n        if (typeof d === \"number\") {\n            return d;\n        }\n        if (d === \"x\") {\n            return this.width;\n        }\n        if (d === \"y\") {\n            return this.height;\n        }\n        return Math.sqrt(Math.pow(this.width, 2) + Math.pow(this.height, 2)) / Math.sqrt(2);\n    }\n}\nclass Point {\n    constructor(x, y){\n        this.x = x;\n        this.y = y;\n    }\n    static parse(point) {\n        var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var [x = defaultValue, y = defaultValue] = toNumbers(point);\n        return new Point(x, y);\n    }\n    static parseScale(scale) {\n        var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n        var [x = defaultValue, y = x] = toNumbers(scale);\n        return new Point(x, y);\n    }\n    static parsePath(path) {\n        var points = toNumbers(path);\n        var len = points.length;\n        var pathPoints = [];\n        for(var i = 0; i < len; i += 2){\n            pathPoints.push(new Point(points[i], points[i + 1]));\n        }\n        return pathPoints;\n    }\n    angleTo(point) {\n        return Math.atan2(point.y - this.y, point.x - this.x);\n    }\n    applyTransform(transform) {\n        var { x, y } = this;\n        var xp = x * transform[0] + y * transform[2] + transform[4];\n        var yp = x * transform[1] + y * transform[3] + transform[5];\n        this.x = xp;\n        this.y = yp;\n    }\n}\nclass Mouse {\n    constructor(screen){\n        this.screen = screen;\n        this.working = false;\n        this.events = [];\n        this.eventElements = []; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this.onClick = this.onClick.bind(this); // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this.onMouseMove = this.onMouseMove.bind(this);\n    }\n    isWorking() {\n        return this.working;\n    }\n    start() {\n        if (this.working) {\n            return;\n        }\n        var { screen, onClick, onMouseMove } = this;\n        var canvas = screen.ctx.canvas;\n        canvas.onclick = onClick;\n        canvas.onmousemove = onMouseMove;\n        this.working = true;\n    }\n    stop() {\n        if (!this.working) {\n            return;\n        }\n        var canvas = this.screen.ctx.canvas;\n        this.working = false;\n        canvas.onclick = null;\n        canvas.onmousemove = null;\n    }\n    hasEvents() {\n        return this.working && this.events.length > 0;\n    }\n    runEvents() {\n        if (!this.working) {\n            return;\n        }\n        var { screen: document1, events, eventElements } = this;\n        var { style } = document1.ctx.canvas;\n        if (style) {\n            style.cursor = \"\";\n        }\n        events.forEach((_ref, i)=>{\n            var { run } = _ref;\n            var element = eventElements[i];\n            while(element){\n                run(element);\n                element = element.parent;\n            }\n        }); // done running, clear\n        this.events = [];\n        this.eventElements = [];\n    }\n    checkPath(element, ctx) {\n        if (!this.working || !ctx) {\n            return;\n        }\n        var { events, eventElements } = this;\n        events.forEach((_ref2, i)=>{\n            var { x, y } = _ref2;\n            if (!eventElements[i] && ctx.isPointInPath && ctx.isPointInPath(x, y)) {\n                eventElements[i] = element;\n            }\n        });\n    }\n    checkBoundingBox(element, boundingBox) {\n        if (!this.working || !boundingBox) {\n            return;\n        }\n        var { events, eventElements } = this;\n        events.forEach((_ref3, i)=>{\n            var { x, y } = _ref3;\n            if (!eventElements[i] && boundingBox.isPointInBox(x, y)) {\n                eventElements[i] = element;\n            }\n        });\n    }\n    mapXY(x, y) {\n        var { window: window1, ctx } = this.screen;\n        var point = new Point(x, y);\n        var element = ctx.canvas;\n        while(element){\n            point.x -= element.offsetLeft;\n            point.y -= element.offsetTop;\n            element = element.offsetParent;\n        }\n        if (window1.scrollX) {\n            point.x += window1.scrollX;\n        }\n        if (window1.scrollY) {\n            point.y += window1.scrollY;\n        }\n        return point;\n    }\n    onClick(event) {\n        var { x, y } = this.mapXY(event.clientX, event.clientY);\n        this.events.push({\n            type: \"onclick\",\n            x,\n            y,\n            run (eventTarget) {\n                if (eventTarget.onClick) {\n                    eventTarget.onClick();\n                }\n            }\n        });\n    }\n    onMouseMove(event) {\n        var { x, y } = this.mapXY(event.clientX, event.clientY);\n        this.events.push({\n            type: \"onmousemove\",\n            x,\n            y,\n            run (eventTarget) {\n                if (eventTarget.onMouseMove) {\n                    eventTarget.onMouseMove();\n                }\n            }\n        });\n    }\n}\nvar defaultWindow =  false ? 0 : null;\nvar defaultFetch$1 = typeof fetch !== \"undefined\" ? fetch.bind(undefined) // `fetch` depends on context: `someObject.fetch(...)` will throw error.\n : null;\nclass Screen {\n    constructor(ctx){\n        var { fetch: fetch1 = defaultFetch$1, window: window1 = defaultWindow } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.ctx = ctx;\n        this.FRAMERATE = 30;\n        this.MAX_VIRTUAL_PIXELS = 30000;\n        this.CLIENT_WIDTH = 800;\n        this.CLIENT_HEIGHT = 600;\n        this.viewPort = new ViewPort();\n        this.mouse = new Mouse(this);\n        this.animations = [];\n        this.waits = [];\n        this.frameDuration = 0;\n        this.isReadyLock = false;\n        this.isFirstRender = true;\n        this.intervalId = null;\n        this.window = window1;\n        this.fetch = fetch1;\n    }\n    wait(checker) {\n        this.waits.push(checker);\n    }\n    ready() {\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        if (!this.readyPromise) {\n            return Promise.resolve();\n        }\n        return this.readyPromise;\n    }\n    isReady() {\n        if (this.isReadyLock) {\n            return true;\n        }\n        var isReadyLock = this.waits.every((_)=>_());\n        if (isReadyLock) {\n            this.waits = [];\n            if (this.resolveReady) {\n                this.resolveReady();\n            }\n        }\n        this.isReadyLock = isReadyLock;\n        return isReadyLock;\n    }\n    setDefaults(ctx) {\n        // initial values and defaults\n        ctx.strokeStyle = \"rgba(0,0,0,0)\";\n        ctx.lineCap = \"butt\";\n        ctx.lineJoin = \"miter\";\n        ctx.miterLimit = 4;\n    }\n    setViewBox(_ref) {\n        var { document: document1, ctx, aspectRatio, width, desiredWidth, height, desiredHeight, minX = 0, minY = 0, refX, refY, clip = false, clipX = 0, clipY = 0 } = _ref;\n        // aspect ratio - http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute\n        var cleanAspectRatio = compressSpaces(aspectRatio).replace(/^defer\\s/, \"\"); // ignore defer\n        var [aspectRatioAlign, aspectRatioMeetOrSlice] = cleanAspectRatio.split(\" \");\n        var align = aspectRatioAlign || \"xMidYMid\";\n        var meetOrSlice = aspectRatioMeetOrSlice || \"meet\"; // calculate scale\n        var scaleX = width / desiredWidth;\n        var scaleY = height / desiredHeight;\n        var scaleMin = Math.min(scaleX, scaleY);\n        var scaleMax = Math.max(scaleX, scaleY);\n        var finalDesiredWidth = desiredWidth;\n        var finalDesiredHeight = desiredHeight;\n        if (meetOrSlice === \"meet\") {\n            finalDesiredWidth *= scaleMin;\n            finalDesiredHeight *= scaleMin;\n        }\n        if (meetOrSlice === \"slice\") {\n            finalDesiredWidth *= scaleMax;\n            finalDesiredHeight *= scaleMax;\n        }\n        var refXProp = new Property(document1, \"refX\", refX);\n        var refYProp = new Property(document1, \"refY\", refY);\n        var hasRefs = refXProp.hasValue() && refYProp.hasValue();\n        if (hasRefs) {\n            ctx.translate(-scaleMin * refXProp.getPixels(\"x\"), -scaleMin * refYProp.getPixels(\"y\"));\n        }\n        if (clip) {\n            var scaledClipX = scaleMin * clipX;\n            var scaledClipY = scaleMin * clipY;\n            ctx.beginPath();\n            ctx.moveTo(scaledClipX, scaledClipY);\n            ctx.lineTo(width, scaledClipY);\n            ctx.lineTo(width, height);\n            ctx.lineTo(scaledClipX, height);\n            ctx.closePath();\n            ctx.clip();\n        }\n        if (!hasRefs) {\n            var isMeetMinY = meetOrSlice === \"meet\" && scaleMin === scaleY;\n            var isSliceMaxY = meetOrSlice === \"slice\" && scaleMax === scaleY;\n            var isMeetMinX = meetOrSlice === \"meet\" && scaleMin === scaleX;\n            var isSliceMaxX = meetOrSlice === \"slice\" && scaleMax === scaleX;\n            if (align.startsWith(\"xMid\") && (isMeetMinY || isSliceMaxY)) {\n                ctx.translate(width / 2.0 - finalDesiredWidth / 2.0, 0);\n            }\n            if (align.endsWith(\"YMid\") && (isMeetMinX || isSliceMaxX)) {\n                ctx.translate(0, height / 2.0 - finalDesiredHeight / 2.0);\n            }\n            if (align.startsWith(\"xMax\") && (isMeetMinY || isSliceMaxY)) {\n                ctx.translate(width - finalDesiredWidth, 0);\n            }\n            if (align.endsWith(\"YMax\") && (isMeetMinX || isSliceMaxX)) {\n                ctx.translate(0, height - finalDesiredHeight);\n            }\n        } // scale\n        switch(true){\n            case align === \"none\":\n                ctx.scale(scaleX, scaleY);\n                break;\n            case meetOrSlice === \"meet\":\n                ctx.scale(scaleMin, scaleMin);\n                break;\n            case meetOrSlice === \"slice\":\n                ctx.scale(scaleMax, scaleMax);\n                break;\n        } // translate\n        ctx.translate(-minX, -minY);\n    }\n    start(element) {\n        var { enableRedraw = false, ignoreMouse = false, ignoreAnimation = false, ignoreDimensions = false, ignoreClear = false, forceRedraw, scaleWidth, scaleHeight, offsetX, offsetY } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { FRAMERATE, mouse } = this;\n        var frameDuration = 1000 / FRAMERATE;\n        this.frameDuration = frameDuration;\n        this.readyPromise = new Promise((resolve)=>{\n            this.resolveReady = resolve;\n        });\n        if (this.isReady()) {\n            this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);\n        }\n        if (!enableRedraw) {\n            return;\n        }\n        var now = Date.now();\n        var then = now;\n        var delta = 0;\n        var tick = ()=>{\n            now = Date.now();\n            delta = now - then;\n            if (delta >= frameDuration) {\n                then = now - delta % frameDuration;\n                if (this.shouldUpdate(ignoreAnimation, forceRedraw)) {\n                    this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);\n                    mouse.runEvents();\n                }\n            }\n            this.intervalId = raf__WEBPACK_IMPORTED_MODULE_11__(tick);\n        };\n        if (!ignoreMouse) {\n            mouse.start();\n        }\n        this.intervalId = raf__WEBPACK_IMPORTED_MODULE_11__(tick);\n    }\n    stop() {\n        if (this.intervalId) {\n            raf__WEBPACK_IMPORTED_MODULE_11__.cancel(this.intervalId);\n            this.intervalId = null;\n        }\n        this.mouse.stop();\n    }\n    shouldUpdate(ignoreAnimation, forceRedraw) {\n        // need update from animations?\n        if (!ignoreAnimation) {\n            var { frameDuration } = this;\n            var shouldUpdate = this.animations.reduce((shouldUpdate, animation)=>animation.update(frameDuration) || shouldUpdate, false);\n            if (shouldUpdate) {\n                return true;\n            }\n        } // need update from redraw?\n        if (typeof forceRedraw === \"function\" && forceRedraw()) {\n            return true;\n        }\n        if (!this.isReadyLock && this.isReady()) {\n            return true;\n        } // need update from mouse events?\n        if (this.mouse.hasEvents()) {\n            return true;\n        }\n        return false;\n    }\n    render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY) {\n        var { CLIENT_WIDTH, CLIENT_HEIGHT, viewPort, ctx, isFirstRender } = this;\n        var canvas = ctx.canvas;\n        viewPort.clear();\n        if (canvas.width && canvas.height) {\n            viewPort.setCurrent(canvas.width, canvas.height);\n        } else {\n            viewPort.setCurrent(CLIENT_WIDTH, CLIENT_HEIGHT);\n        }\n        var widthStyle = element.getStyle(\"width\");\n        var heightStyle = element.getStyle(\"height\");\n        if (!ignoreDimensions && (isFirstRender || typeof scaleWidth !== \"number\" && typeof scaleHeight !== \"number\")) {\n            // set canvas size\n            if (widthStyle.hasValue()) {\n                canvas.width = widthStyle.getPixels(\"x\");\n                if (canvas.style) {\n                    canvas.style.width = \"\".concat(canvas.width, \"px\");\n                }\n            }\n            if (heightStyle.hasValue()) {\n                canvas.height = heightStyle.getPixels(\"y\");\n                if (canvas.style) {\n                    canvas.style.height = \"\".concat(canvas.height, \"px\");\n                }\n            }\n        }\n        var cWidth = canvas.clientWidth || canvas.width;\n        var cHeight = canvas.clientHeight || canvas.height;\n        if (ignoreDimensions && widthStyle.hasValue() && heightStyle.hasValue()) {\n            cWidth = widthStyle.getPixels(\"x\");\n            cHeight = heightStyle.getPixels(\"y\");\n        }\n        viewPort.setCurrent(cWidth, cHeight);\n        if (typeof offsetX === \"number\") {\n            element.getAttribute(\"x\", true).setValue(offsetX);\n        }\n        if (typeof offsetY === \"number\") {\n            element.getAttribute(\"y\", true).setValue(offsetY);\n        }\n        if (typeof scaleWidth === \"number\" || typeof scaleHeight === \"number\") {\n            var viewBox = toNumbers(element.getAttribute(\"viewBox\").getString());\n            var xRatio = 0;\n            var yRatio = 0;\n            if (typeof scaleWidth === \"number\") {\n                var _widthStyle = element.getStyle(\"width\");\n                if (_widthStyle.hasValue()) {\n                    xRatio = _widthStyle.getPixels(\"x\") / scaleWidth;\n                } else if (!isNaN(viewBox[2])) {\n                    xRatio = viewBox[2] / scaleWidth;\n                }\n            }\n            if (typeof scaleHeight === \"number\") {\n                var _heightStyle = element.getStyle(\"height\");\n                if (_heightStyle.hasValue()) {\n                    yRatio = _heightStyle.getPixels(\"y\") / scaleHeight;\n                } else if (!isNaN(viewBox[3])) {\n                    yRatio = viewBox[3] / scaleHeight;\n                }\n            }\n            if (!xRatio) {\n                xRatio = yRatio;\n            }\n            if (!yRatio) {\n                yRatio = xRatio;\n            }\n            element.getAttribute(\"width\", true).setValue(scaleWidth);\n            element.getAttribute(\"height\", true).setValue(scaleHeight);\n            var transformStyle = element.getStyle(\"transform\", true, true);\n            transformStyle.setValue(\"\".concat(transformStyle.getString(), \" scale(\").concat(1.0 / xRatio, \", \").concat(1.0 / yRatio, \")\"));\n        } // clear and render\n        if (!ignoreClear) {\n            ctx.clearRect(0, 0, cWidth, cHeight);\n        }\n        element.render(ctx);\n        if (isFirstRender) {\n            this.isFirstRender = false;\n        }\n    }\n}\nScreen.defaultWindow = defaultWindow;\nScreen.defaultFetch = defaultFetch$1;\nvar { defaultFetch } = Screen;\nvar DefaultDOMParser = typeof DOMParser !== \"undefined\" ? DOMParser : null;\nclass Parser {\n    constructor(){\n        var { fetch: fetch1 = defaultFetch, DOMParser: DOMParser1 = DefaultDOMParser } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        this.fetch = fetch1;\n        this.DOMParser = DOMParser1;\n    }\n    parse(resource) {\n        var _this = this;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            if (resource.startsWith(\"<\")) {\n                return _this.parseFromString(resource);\n            }\n            return _this.load(resource);\n        })();\n    }\n    parseFromString(xml) {\n        var parser = new this.DOMParser();\n        try {\n            return this.checkDocument(parser.parseFromString(xml, \"image/svg+xml\"));\n        } catch (err) {\n            return this.checkDocument(parser.parseFromString(xml, \"text/xml\"));\n        }\n    }\n    checkDocument(document1) {\n        var parserError = document1.getElementsByTagName(\"parsererror\")[0];\n        if (parserError) {\n            throw new Error(parserError.textContent);\n        }\n        return document1;\n    }\n    load(url) {\n        var _this2 = this;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            var response = yield _this2.fetch(url);\n            var xml = yield response.text();\n            return _this2.parseFromString(xml);\n        })();\n    }\n}\nclass Translate {\n    constructor(_, point){\n        this.type = \"translate\";\n        this.point = null;\n        this.point = Point.parse(point);\n    }\n    apply(ctx) {\n        var { x, y } = this.point;\n        ctx.translate(x || 0.0, y || 0.0);\n    }\n    unapply(ctx) {\n        var { x, y } = this.point;\n        ctx.translate(-1.0 * x || 0.0, -1.0 * y || 0.0);\n    }\n    applyToPoint(point) {\n        var { x, y } = this.point;\n        point.applyTransform([\n            1,\n            0,\n            0,\n            1,\n            x || 0.0,\n            y || 0.0\n        ]);\n    }\n}\nclass Rotate {\n    constructor(document1, rotate, transformOrigin){\n        this.type = \"rotate\";\n        this.angle = null;\n        this.originX = null;\n        this.originY = null;\n        this.cx = 0;\n        this.cy = 0;\n        var numbers = toNumbers(rotate);\n        this.angle = new Property(document1, \"angle\", numbers[0]);\n        this.originX = transformOrigin[0];\n        this.originY = transformOrigin[1];\n        this.cx = numbers[1] || 0;\n        this.cy = numbers[2] || 0;\n    }\n    apply(ctx) {\n        var { cx, cy, originX, originY, angle } = this;\n        var tx = cx + originX.getPixels(\"x\");\n        var ty = cy + originY.getPixels(\"y\");\n        ctx.translate(tx, ty);\n        ctx.rotate(angle.getRadians());\n        ctx.translate(-tx, -ty);\n    }\n    unapply(ctx) {\n        var { cx, cy, originX, originY, angle } = this;\n        var tx = cx + originX.getPixels(\"x\");\n        var ty = cy + originY.getPixels(\"y\");\n        ctx.translate(tx, ty);\n        ctx.rotate(-1.0 * angle.getRadians());\n        ctx.translate(-tx, -ty);\n    }\n    applyToPoint(point) {\n        var { cx, cy, angle } = this;\n        var rad = angle.getRadians();\n        point.applyTransform([\n            1,\n            0,\n            0,\n            1,\n            cx || 0.0,\n            cy || 0.0 // this.p.y\n        ]);\n        point.applyTransform([\n            Math.cos(rad),\n            Math.sin(rad),\n            -Math.sin(rad),\n            Math.cos(rad),\n            0,\n            0\n        ]);\n        point.applyTransform([\n            1,\n            0,\n            0,\n            1,\n            -cx || 0.0,\n            -cy || 0.0 // -this.p.y\n        ]);\n    }\n}\nclass Scale {\n    constructor(_, scale, transformOrigin){\n        this.type = \"scale\";\n        this.scale = null;\n        this.originX = null;\n        this.originY = null;\n        var scaleSize = Point.parseScale(scale); // Workaround for node-canvas\n        if (scaleSize.x === 0 || scaleSize.y === 0) {\n            scaleSize.x = PSEUDO_ZERO;\n            scaleSize.y = PSEUDO_ZERO;\n        }\n        this.scale = scaleSize;\n        this.originX = transformOrigin[0];\n        this.originY = transformOrigin[1];\n    }\n    apply(ctx) {\n        var { scale: { x, y }, originX, originY } = this;\n        var tx = originX.getPixels(\"x\");\n        var ty = originY.getPixels(\"y\");\n        ctx.translate(tx, ty);\n        ctx.scale(x, y || x);\n        ctx.translate(-tx, -ty);\n    }\n    unapply(ctx) {\n        var { scale: { x, y }, originX, originY } = this;\n        var tx = originX.getPixels(\"x\");\n        var ty = originY.getPixels(\"y\");\n        ctx.translate(tx, ty);\n        ctx.scale(1.0 / x, 1.0 / y || x);\n        ctx.translate(-tx, -ty);\n    }\n    applyToPoint(point) {\n        var { x, y } = this.scale;\n        point.applyTransform([\n            x || 0.0,\n            0,\n            0,\n            y || 0.0,\n            0,\n            0\n        ]);\n    }\n}\nclass Matrix {\n    constructor(_, matrix, transformOrigin){\n        this.type = \"matrix\";\n        this.matrix = [];\n        this.originX = null;\n        this.originY = null;\n        this.matrix = toNumbers(matrix);\n        this.originX = transformOrigin[0];\n        this.originY = transformOrigin[1];\n    }\n    apply(ctx) {\n        var { originX, originY, matrix } = this;\n        var tx = originX.getPixels(\"x\");\n        var ty = originY.getPixels(\"y\");\n        ctx.translate(tx, ty);\n        ctx.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\n        ctx.translate(-tx, -ty);\n    }\n    unapply(ctx) {\n        var { originX, originY, matrix } = this;\n        var a = matrix[0];\n        var b = matrix[2];\n        var c = matrix[4];\n        var d = matrix[1];\n        var e = matrix[3];\n        var f = matrix[5];\n        var g = 0.0;\n        var h = 0.0;\n        var i = 1.0;\n        var det = 1 / (a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g));\n        var tx = originX.getPixels(\"x\");\n        var ty = originY.getPixels(\"y\");\n        ctx.translate(tx, ty);\n        ctx.transform(det * (e * i - f * h), det * (f * g - d * i), det * (c * h - b * i), det * (a * i - c * g), det * (b * f - c * e), det * (c * d - a * f));\n        ctx.translate(-tx, -ty);\n    }\n    applyToPoint(point) {\n        point.applyTransform(this.matrix);\n    }\n}\nclass Skew extends Matrix {\n    constructor(document1, skew, transformOrigin){\n        super(document1, skew, transformOrigin);\n        this.type = \"skew\";\n        this.angle = null;\n        this.angle = new Property(document1, \"angle\", skew);\n    }\n}\nclass SkewX extends Skew {\n    constructor(document1, skew, transformOrigin){\n        super(document1, skew, transformOrigin);\n        this.type = \"skewX\";\n        this.matrix = [\n            1,\n            0,\n            Math.tan(this.angle.getRadians()),\n            1,\n            0,\n            0\n        ];\n    }\n}\nclass SkewY extends Skew {\n    constructor(document1, skew, transformOrigin){\n        super(document1, skew, transformOrigin);\n        this.type = \"skewY\";\n        this.matrix = [\n            1,\n            Math.tan(this.angle.getRadians()),\n            0,\n            1,\n            0,\n            0\n        ];\n    }\n}\nfunction parseTransforms(transform) {\n    return compressSpaces(transform).trim().replace(/\\)([a-zA-Z])/g, \") $1\").replace(/\\)(\\s?,\\s?)/g, \") \").split(/\\s(?=[a-z])/);\n}\nfunction parseTransform(transform) {\n    var [type, value] = transform.split(\"(\");\n    return [\n        type.trim(),\n        value.trim().replace(\")\", \"\")\n    ];\n}\nclass Transform {\n    constructor(document1, transform, transformOrigin){\n        this.document = document1;\n        this.transforms = [];\n        var data = parseTransforms(transform);\n        data.forEach((transform)=>{\n            if (transform === \"none\") {\n                return;\n            }\n            var [type, value] = parseTransform(transform);\n            var TransformType = Transform.transformTypes[type];\n            if (typeof TransformType !== \"undefined\") {\n                this.transforms.push(new TransformType(this.document, value, transformOrigin));\n            }\n        });\n    }\n    static fromElement(document1, element) {\n        var transformStyle = element.getStyle(\"transform\", false, true);\n        var [transformOriginXProperty, transformOriginYProperty = transformOriginXProperty] = element.getStyle(\"transform-origin\", false, true).split();\n        var transformOrigin = [\n            transformOriginXProperty,\n            transformOriginYProperty\n        ];\n        if (transformStyle.hasValue()) {\n            return new Transform(document1, transformStyle.getString(), transformOrigin);\n        }\n        return null;\n    }\n    apply(ctx) {\n        var { transforms } = this;\n        var len = transforms.length;\n        for(var i = 0; i < len; i++){\n            transforms[i].apply(ctx);\n        }\n    }\n    unapply(ctx) {\n        var { transforms } = this;\n        var len = transforms.length;\n        for(var i = len - 1; i >= 0; i--){\n            transforms[i].unapply(ctx);\n        }\n    }\n    applyToPoint(point) {\n        var { transforms } = this;\n        var len = transforms.length;\n        for(var i = 0; i < len; i++){\n            transforms[i].applyToPoint(point);\n        }\n    }\n}\nTransform.transformTypes = {\n    translate: Translate,\n    rotate: Rotate,\n    scale: Scale,\n    matrix: Matrix,\n    skewX: SkewX,\n    skewY: SkewY\n};\nclass Element {\n    constructor(document1, node){\n        var captureTextNodes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        this.document = document1;\n        this.node = node;\n        this.captureTextNodes = captureTextNodes;\n        this.attributes = Object.create(null);\n        this.styles = Object.create(null);\n        this.stylesSpecificity = Object.create(null);\n        this.animationFrozen = false;\n        this.animationFrozenValue = \"\";\n        this.parent = null;\n        this.children = [];\n        if (!node || node.nodeType !== 1) {\n            // ELEMENT_NODE\n            return;\n        } // add attributes\n        Array.from(node.attributes).forEach((attribute)=>{\n            var nodeName = normalizeAttributeName(attribute.nodeName);\n            this.attributes[nodeName] = new Property(document1, nodeName, attribute.value);\n        });\n        this.addStylesFromStyleDefinition(); // add inline styles\n        if (this.getAttribute(\"style\").hasValue()) {\n            var styles = this.getAttribute(\"style\").getString().split(\";\").map((_)=>_.trim());\n            styles.forEach((style)=>{\n                if (!style) {\n                    return;\n                }\n                var [name, value] = style.split(\":\").map((_)=>_.trim());\n                this.styles[name] = new Property(document1, name, value);\n            });\n        }\n        var { definitions } = document1;\n        var id = this.getAttribute(\"id\"); // add id\n        if (id.hasValue()) {\n            if (!definitions[id.getString()]) {\n                definitions[id.getString()] = this;\n            }\n        }\n        Array.from(node.childNodes).forEach((childNode)=>{\n            if (childNode.nodeType === 1) {\n                this.addChild(childNode); // ELEMENT_NODE\n            } else if (captureTextNodes && (childNode.nodeType === 3 || childNode.nodeType === 4)) {\n                var textNode = document1.createTextNode(childNode);\n                if (textNode.getText().length > 0) {\n                    this.addChild(textNode); // TEXT_NODE\n                }\n            }\n        });\n    }\n    getAttribute(name) {\n        var createIfNotExists = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var attr = this.attributes[name];\n        if (!attr && createIfNotExists) {\n            var _attr = new Property(this.document, name, \"\");\n            this.attributes[name] = _attr;\n            return _attr;\n        }\n        return attr || Property.empty(this.document);\n    }\n    getHrefAttribute() {\n        for(var key in this.attributes){\n            if (key === \"href\" || key.endsWith(\":href\")) {\n                return this.attributes[key];\n            }\n        }\n        return Property.empty(this.document);\n    }\n    getStyle(name) {\n        var createIfNotExists = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var skipAncestors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var style = this.styles[name];\n        if (style) {\n            return style;\n        }\n        var attr = this.getAttribute(name);\n        if (attr !== null && attr !== void 0 && attr.hasValue()) {\n            this.styles[name] = attr; // move up to me to cache\n            return attr;\n        }\n        if (!skipAncestors) {\n            var { parent } = this;\n            if (parent) {\n                var parentStyle = parent.getStyle(name);\n                if (parentStyle !== null && parentStyle !== void 0 && parentStyle.hasValue()) {\n                    return parentStyle;\n                }\n            }\n        }\n        if (createIfNotExists) {\n            var _style = new Property(this.document, name, \"\");\n            this.styles[name] = _style;\n            return _style;\n        }\n        return style || Property.empty(this.document);\n    }\n    render(ctx) {\n        // don't render display=none\n        // don't render visibility=hidden\n        if (this.getStyle(\"display\").getString() === \"none\" || this.getStyle(\"visibility\").getString() === \"hidden\") {\n            return;\n        }\n        ctx.save();\n        if (this.getStyle(\"mask\").hasValue()) {\n            // mask\n            var mask = this.getStyle(\"mask\").getDefinition();\n            if (mask) {\n                this.applyEffects(ctx);\n                mask.apply(ctx, this);\n            }\n        } else if (this.getStyle(\"filter\").getValue(\"none\") !== \"none\") {\n            // filter\n            var filter = this.getStyle(\"filter\").getDefinition();\n            if (filter) {\n                this.applyEffects(ctx);\n                filter.apply(ctx, this);\n            }\n        } else {\n            this.setContext(ctx);\n            this.renderChildren(ctx);\n            this.clearContext(ctx);\n        }\n        ctx.restore();\n    }\n    setContext(_) {}\n    applyEffects(ctx) {\n        // transform\n        var transform = Transform.fromElement(this.document, this);\n        if (transform) {\n            transform.apply(ctx);\n        } // clip\n        var clipPathStyleProp = this.getStyle(\"clip-path\", false, true);\n        if (clipPathStyleProp.hasValue()) {\n            var clip = clipPathStyleProp.getDefinition();\n            if (clip) {\n                clip.apply(ctx);\n            }\n        }\n    }\n    clearContext(_) {}\n    renderChildren(ctx) {\n        this.children.forEach((child)=>{\n            child.render(ctx);\n        });\n    }\n    addChild(childNode) {\n        var child = childNode instanceof Element ? childNode : this.document.createElement(childNode);\n        child.parent = this;\n        if (!Element.ignoreChildTypes.includes(child.type)) {\n            this.children.push(child);\n        }\n    }\n    matchesSelector(selector) {\n        var _node$getAttribute;\n        var { node } = this;\n        if (typeof node.matches === \"function\") {\n            return node.matches(selector);\n        }\n        var styleClasses = (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, \"class\");\n        if (!styleClasses || styleClasses === \"\") {\n            return false;\n        }\n        return styleClasses.split(\" \").some((styleClass)=>\".\".concat(styleClass) === selector);\n    }\n    addStylesFromStyleDefinition() {\n        var { styles, stylesSpecificity } = this.document;\n        for(var selector in styles){\n            if (!selector.startsWith(\"@\") && this.matchesSelector(selector)) {\n                var style = styles[selector];\n                var specificity = stylesSpecificity[selector];\n                if (style) {\n                    for(var name in style){\n                        var existingSpecificity = this.stylesSpecificity[name];\n                        if (typeof existingSpecificity === \"undefined\") {\n                            existingSpecificity = \"000\";\n                        }\n                        if (specificity >= existingSpecificity) {\n                            this.styles[name] = style[name];\n                            this.stylesSpecificity[name] = specificity;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    removeStyles(element, ignoreStyles) {\n        var toRestore = ignoreStyles.reduce((toRestore, name)=>{\n            var styleProp = element.getStyle(name);\n            if (!styleProp.hasValue()) {\n                return toRestore;\n            }\n            var value = styleProp.getString();\n            styleProp.setValue(\"\");\n            return [\n                ...toRestore,\n                [\n                    name,\n                    value\n                ]\n            ];\n        }, []);\n        return toRestore;\n    }\n    restoreStyles(element, styles) {\n        styles.forEach((_ref)=>{\n            var [name, value] = _ref;\n            element.getStyle(name, true).setValue(value);\n        });\n    }\n    isFirstChild() {\n        var _this$parent;\n        return ((_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.children.indexOf(this)) === 0;\n    }\n}\nElement.ignoreChildTypes = [\n    \"title\"\n];\nclass UnknownElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n    }\n}\nfunction wrapFontFamily(fontFamily) {\n    var trimmed = fontFamily.trim();\n    return /^('|\")/.test(trimmed) ? trimmed : '\"'.concat(trimmed, '\"');\n}\nfunction prepareFontFamily(fontFamily) {\n    return typeof process === \"undefined\" ? fontFamily : fontFamily.trim().split(\",\").map(wrapFontFamily).join(\",\");\n}\n/**\r\n * https://developer.mozilla.org/en-US/docs/Web/CSS/font-style\r\n * @param fontStyle\r\n * @returns CSS font style.\r\n */ function prepareFontStyle(fontStyle) {\n    if (!fontStyle) {\n        return \"\";\n    }\n    var targetFontStyle = fontStyle.trim().toLowerCase();\n    switch(targetFontStyle){\n        case \"normal\":\n        case \"italic\":\n        case \"oblique\":\n        case \"inherit\":\n        case \"initial\":\n        case \"unset\":\n            return targetFontStyle;\n        default:\n            if (/^oblique\\s+(-|)\\d+deg$/.test(targetFontStyle)) {\n                return targetFontStyle;\n            }\n            return \"\";\n    }\n}\n/**\r\n * https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight\r\n * @param fontWeight\r\n * @returns CSS font weight.\r\n */ function prepareFontWeight(fontWeight) {\n    if (!fontWeight) {\n        return \"\";\n    }\n    var targetFontWeight = fontWeight.trim().toLowerCase();\n    switch(targetFontWeight){\n        case \"normal\":\n        case \"bold\":\n        case \"lighter\":\n        case \"bolder\":\n        case \"inherit\":\n        case \"initial\":\n        case \"unset\":\n            return targetFontWeight;\n        default:\n            if (/^[\\d.]+$/.test(targetFontWeight)) {\n                return targetFontWeight;\n            }\n            return \"\";\n    }\n}\nclass Font {\n    constructor(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit){\n        var inheritFont = inherit ? typeof inherit === \"string\" ? Font.parse(inherit) : inherit : {};\n        this.fontFamily = fontFamily || inheritFont.fontFamily;\n        this.fontSize = fontSize || inheritFont.fontSize;\n        this.fontStyle = fontStyle || inheritFont.fontStyle;\n        this.fontWeight = fontWeight || inheritFont.fontWeight;\n        this.fontVariant = fontVariant || inheritFont.fontVariant;\n    }\n    static parse() {\n        var font = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n        var inherit = arguments.length > 1 ? arguments[1] : undefined;\n        var fontStyle = \"\";\n        var fontVariant = \"\";\n        var fontWeight = \"\";\n        var fontSize = \"\";\n        var fontFamily = \"\";\n        var parts = compressSpaces(font).trim().split(\" \");\n        var set = {\n            fontSize: false,\n            fontStyle: false,\n            fontWeight: false,\n            fontVariant: false\n        };\n        parts.forEach((part)=>{\n            switch(true){\n                case !set.fontStyle && Font.styles.includes(part):\n                    if (part !== \"inherit\") {\n                        fontStyle = part;\n                    }\n                    set.fontStyle = true;\n                    break;\n                case !set.fontVariant && Font.variants.includes(part):\n                    if (part !== \"inherit\") {\n                        fontVariant = part;\n                    }\n                    set.fontStyle = true;\n                    set.fontVariant = true;\n                    break;\n                case !set.fontWeight && Font.weights.includes(part):\n                    if (part !== \"inherit\") {\n                        fontWeight = part;\n                    }\n                    set.fontStyle = true;\n                    set.fontVariant = true;\n                    set.fontWeight = true;\n                    break;\n                case !set.fontSize:\n                    if (part !== \"inherit\") {\n                        [fontSize] = part.split(\"/\");\n                    }\n                    set.fontStyle = true;\n                    set.fontVariant = true;\n                    set.fontWeight = true;\n                    set.fontSize = true;\n                    break;\n                default:\n                    if (part !== \"inherit\") {\n                        fontFamily += part;\n                    }\n            }\n        });\n        return new Font(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit);\n    }\n    toString() {\n        return [\n            prepareFontStyle(this.fontStyle),\n            this.fontVariant,\n            prepareFontWeight(this.fontWeight),\n            this.fontSize,\n            prepareFontFamily(this.fontFamily)\n        ].join(\" \").trim();\n    }\n}\nFont.styles = \"normal|italic|oblique|inherit\";\nFont.variants = \"normal|small-caps|inherit\";\nFont.weights = \"normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit\";\nclass BoundingBox {\n    constructor(){\n        var x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.NaN;\n        var y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.NaN;\n        var x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.NaN;\n        var y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Number.NaN;\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n        this.addPoint(x1, y1);\n        this.addPoint(x2, y2);\n    }\n    get x() {\n        return this.x1;\n    }\n    get y() {\n        return this.y1;\n    }\n    get width() {\n        return this.x2 - this.x1;\n    }\n    get height() {\n        return this.y2 - this.y1;\n    }\n    addPoint(x, y) {\n        if (typeof x !== \"undefined\") {\n            if (isNaN(this.x1) || isNaN(this.x2)) {\n                this.x1 = x;\n                this.x2 = x;\n            }\n            if (x < this.x1) {\n                this.x1 = x;\n            }\n            if (x > this.x2) {\n                this.x2 = x;\n            }\n        }\n        if (typeof y !== \"undefined\") {\n            if (isNaN(this.y1) || isNaN(this.y2)) {\n                this.y1 = y;\n                this.y2 = y;\n            }\n            if (y < this.y1) {\n                this.y1 = y;\n            }\n            if (y > this.y2) {\n                this.y2 = y;\n            }\n        }\n    }\n    addX(x) {\n        this.addPoint(x, null);\n    }\n    addY(y) {\n        this.addPoint(null, y);\n    }\n    addBoundingBox(boundingBox) {\n        if (!boundingBox) {\n            return;\n        }\n        var { x1, y1, x2, y2 } = boundingBox;\n        this.addPoint(x1, y1);\n        this.addPoint(x2, y2);\n    }\n    sumCubic(t, p0, p1, p2, p3) {\n        return Math.pow(1 - t, 3) * p0 + 3 * Math.pow(1 - t, 2) * t * p1 + 3 * (1 - t) * Math.pow(t, 2) * p2 + Math.pow(t, 3) * p3;\n    }\n    bezierCurveAdd(forX, p0, p1, p2, p3) {\n        var b = 6 * p0 - 12 * p1 + 6 * p2;\n        var a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;\n        var c = 3 * p1 - 3 * p0;\n        if (a === 0) {\n            if (b === 0) {\n                return;\n            }\n            var t = -c / b;\n            if (0 < t && t < 1) {\n                if (forX) {\n                    this.addX(this.sumCubic(t, p0, p1, p2, p3));\n                } else {\n                    this.addY(this.sumCubic(t, p0, p1, p2, p3));\n                }\n            }\n            return;\n        }\n        var b2ac = Math.pow(b, 2) - 4 * c * a;\n        if (b2ac < 0) {\n            return;\n        }\n        var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);\n        if (0 < t1 && t1 < 1) {\n            if (forX) {\n                this.addX(this.sumCubic(t1, p0, p1, p2, p3));\n            } else {\n                this.addY(this.sumCubic(t1, p0, p1, p2, p3));\n            }\n        }\n        var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);\n        if (0 < t2 && t2 < 1) {\n            if (forX) {\n                this.addX(this.sumCubic(t2, p0, p1, p2, p3));\n            } else {\n                this.addY(this.sumCubic(t2, p0, p1, p2, p3));\n            }\n        }\n    }\n    addBezierCurve(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {\n        this.addPoint(p0x, p0y);\n        this.addPoint(p3x, p3y);\n        this.bezierCurveAdd(true, p0x, p1x, p2x, p3x);\n        this.bezierCurveAdd(false, p0y, p1y, p2y, p3y);\n    }\n    addQuadraticCurve(p0x, p0y, p1x, p1y, p2x, p2y) {\n        var cp1x = p0x + 2 / 3 * (p1x - p0x); // CP1 = QP0 + 2/3 *(QP1-QP0)\n        var cp1y = p0y + 2 / 3 * (p1y - p0y); // CP1 = QP0 + 2/3 *(QP1-QP0)\n        var cp2x = cp1x + 1 / 3 * (p2x - p0x); // CP2 = CP1 + 1/3 *(QP2-QP0)\n        var cp2y = cp1y + 1 / 3 * (p2y - p0y); // CP2 = CP1 + 1/3 *(QP2-QP0)\n        this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);\n    }\n    isPointInBox(x, y) {\n        var { x1, y1, x2, y2 } = this;\n        return x1 <= x && x <= x2 && y1 <= y && y <= y2;\n    }\n}\nclass PathParser extends svg_pathdata__WEBPACK_IMPORTED_MODULE_17__.SVGPathData {\n    constructor(path){\n        super(path // Fix spaces after signs.\n        .replace(/([+\\-.])\\s+/gm, \"$1\") // Remove invalid part.\n        .replace(/[^MmZzLlHhVvCcSsQqTtAae\\d\\s.,+-].*/g, \"\"));\n        this.control = null;\n        this.start = null;\n        this.current = null;\n        this.command = null;\n        this.commands = this.commands;\n        this.i = -1;\n        this.previousCommand = null;\n        this.points = [];\n        this.angles = [];\n    }\n    reset() {\n        this.i = -1;\n        this.command = null;\n        this.previousCommand = null;\n        this.start = new Point(0, 0);\n        this.control = new Point(0, 0);\n        this.current = new Point(0, 0);\n        this.points = [];\n        this.angles = [];\n    }\n    isEnd() {\n        var { i, commands } = this;\n        return i >= commands.length - 1;\n    }\n    next() {\n        var command = this.commands[++this.i];\n        this.previousCommand = this.command;\n        this.command = command;\n        return command;\n    }\n    getPoint() {\n        var xProp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"x\";\n        var yProp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"y\";\n        var point = new Point(this.command[xProp], this.command[yProp]);\n        return this.makeAbsolute(point);\n    }\n    getAsControlPoint(xProp, yProp) {\n        var point = this.getPoint(xProp, yProp);\n        this.control = point;\n        return point;\n    }\n    getAsCurrentPoint(xProp, yProp) {\n        var point = this.getPoint(xProp, yProp);\n        this.current = point;\n        return point;\n    }\n    getReflectedControlPoint() {\n        var previousCommand = this.previousCommand.type;\n        if (previousCommand !== svg_pathdata__WEBPACK_IMPORTED_MODULE_17__.SVGPathData.CURVE_TO && previousCommand !== svg_pathdata__WEBPACK_IMPORTED_MODULE_17__.SVGPathData.SMOOTH_CURVE_TO && previousCommand !== svg_pathdata__WEBPACK_IMPORTED_MODULE_17__.SVGPathData.QUAD_TO && previousCommand !== svg_pathdata__WEBPACK_IMPORTED_MODULE_17__.SVGPathData.SMOOTH_QUAD_TO) {\n            return this.current;\n        } // reflect point\n        var { current: { x: cx, y: cy }, control: { x: ox, y: oy } } = this;\n        var point = new Point(2 * cx - ox, 2 * cy - oy);\n        return point;\n    }\n    makeAbsolute(point) {\n        if (this.command.relative) {\n            var { x, y } = this.current;\n            point.x += x;\n            point.y += y;\n        }\n        return point;\n    }\n    addMarker(point, from, priorTo) {\n        var { points, angles } = this; // if the last angle isn't filled in because we didn't have this point yet ...\n        if (priorTo && angles.length > 0 && !angles[angles.length - 1]) {\n            angles[angles.length - 1] = points[points.length - 1].angleTo(priorTo);\n        }\n        this.addMarkerAngle(point, from ? from.angleTo(point) : null);\n    }\n    addMarkerAngle(point, angle) {\n        this.points.push(point);\n        this.angles.push(angle);\n    }\n    getMarkerPoints() {\n        return this.points;\n    }\n    getMarkerAngles() {\n        var { angles } = this;\n        var len = angles.length;\n        for(var i = 0; i < len; i++){\n            if (!angles[i]) {\n                for(var j = i + 1; j < len; j++){\n                    if (angles[j]) {\n                        angles[i] = angles[j];\n                        break;\n                    }\n                }\n            }\n        }\n        return angles;\n    }\n}\nclass RenderedElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.modifiedEmSizeStack = false;\n    }\n    calculateOpacity() {\n        var opacity = 1.0; // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this\n        var element = this;\n        while(element){\n            var opacityStyle = element.getStyle(\"opacity\", false, true); // no ancestors on style call\n            if (opacityStyle.hasValue(true)) {\n                opacity *= opacityStyle.getNumber();\n            }\n            element = element.parent;\n        }\n        return opacity;\n    }\n    setContext(ctx) {\n        var fromMeasure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        if (!fromMeasure) {\n            // causes stack overflow when measuring text with gradients\n            // fill\n            var fillStyleProp = this.getStyle(\"fill\");\n            var fillOpacityStyleProp = this.getStyle(\"fill-opacity\");\n            var strokeStyleProp = this.getStyle(\"stroke\");\n            var strokeOpacityProp = this.getStyle(\"stroke-opacity\");\n            if (fillStyleProp.isUrlDefinition()) {\n                var fillStyle = fillStyleProp.getFillStyleDefinition(this, fillOpacityStyleProp);\n                if (fillStyle) {\n                    ctx.fillStyle = fillStyle;\n                }\n            } else if (fillStyleProp.hasValue()) {\n                if (fillStyleProp.getString() === \"currentColor\") {\n                    fillStyleProp.setValue(this.getStyle(\"color\").getColor());\n                }\n                var _fillStyle = fillStyleProp.getColor();\n                if (_fillStyle !== \"inherit\") {\n                    ctx.fillStyle = _fillStyle === \"none\" ? \"rgba(0,0,0,0)\" : _fillStyle;\n                }\n            }\n            if (fillOpacityStyleProp.hasValue()) {\n                var _fillStyle2 = new Property(this.document, \"fill\", ctx.fillStyle).addOpacity(fillOpacityStyleProp).getColor();\n                ctx.fillStyle = _fillStyle2;\n            } // stroke\n            if (strokeStyleProp.isUrlDefinition()) {\n                var strokeStyle = strokeStyleProp.getFillStyleDefinition(this, strokeOpacityProp);\n                if (strokeStyle) {\n                    ctx.strokeStyle = strokeStyle;\n                }\n            } else if (strokeStyleProp.hasValue()) {\n                if (strokeStyleProp.getString() === \"currentColor\") {\n                    strokeStyleProp.setValue(this.getStyle(\"color\").getColor());\n                }\n                var _strokeStyle = strokeStyleProp.getString();\n                if (_strokeStyle !== \"inherit\") {\n                    ctx.strokeStyle = _strokeStyle === \"none\" ? \"rgba(0,0,0,0)\" : _strokeStyle;\n                }\n            }\n            if (strokeOpacityProp.hasValue()) {\n                var _strokeStyle2 = new Property(this.document, \"stroke\", ctx.strokeStyle).addOpacity(strokeOpacityProp).getString();\n                ctx.strokeStyle = _strokeStyle2;\n            }\n            var strokeWidthStyleProp = this.getStyle(\"stroke-width\");\n            if (strokeWidthStyleProp.hasValue()) {\n                var newLineWidth = strokeWidthStyleProp.getPixels();\n                ctx.lineWidth = !newLineWidth ? PSEUDO_ZERO // browsers don't respect 0 (or node-canvas? :-)\n                 : newLineWidth;\n            }\n            var strokeLinecapStyleProp = this.getStyle(\"stroke-linecap\");\n            var strokeLinejoinStyleProp = this.getStyle(\"stroke-linejoin\");\n            var strokeMiterlimitProp = this.getStyle(\"stroke-miterlimit\"); // NEED TEST\n            // const pointOrderStyleProp = this.getStyle('paint-order');\n            var strokeDasharrayStyleProp = this.getStyle(\"stroke-dasharray\");\n            var strokeDashoffsetProp = this.getStyle(\"stroke-dashoffset\");\n            if (strokeLinecapStyleProp.hasValue()) {\n                ctx.lineCap = strokeLinecapStyleProp.getString();\n            }\n            if (strokeLinejoinStyleProp.hasValue()) {\n                ctx.lineJoin = strokeLinejoinStyleProp.getString();\n            }\n            if (strokeMiterlimitProp.hasValue()) {\n                ctx.miterLimit = strokeMiterlimitProp.getNumber();\n            } // NEED TEST\n            // if (pointOrderStyleProp.hasValue()) {\n            // \t// ?\n            // \tctx.paintOrder = pointOrderStyleProp.getValue();\n            // }\n            if (strokeDasharrayStyleProp.hasValue() && strokeDasharrayStyleProp.getString() !== \"none\") {\n                var gaps = toNumbers(strokeDasharrayStyleProp.getString());\n                if (typeof ctx.setLineDash !== \"undefined\") {\n                    ctx.setLineDash(gaps);\n                } else if (typeof ctx.webkitLineDash !== \"undefined\") {\n                    // @ts-expect-error Handle browser prefix.\n                    ctx.webkitLineDash = gaps;\n                } else if (typeof ctx.mozDash !== \"undefined\" && !(gaps.length === 1 && gaps[0] === 0)) {\n                    // @ts-expect-error Handle browser prefix.\n                    ctx.mozDash = gaps;\n                }\n                var offset = strokeDashoffsetProp.getPixels();\n                if (typeof ctx.lineDashOffset !== \"undefined\") {\n                    ctx.lineDashOffset = offset;\n                } else if (typeof ctx.webkitLineDashOffset !== \"undefined\") {\n                    // @ts-expect-error Handle browser prefix.\n                    ctx.webkitLineDashOffset = offset;\n                } else if (typeof ctx.mozDashOffset !== \"undefined\") {\n                    // @ts-expect-error Handle browser prefix.\n                    ctx.mozDashOffset = offset;\n                }\n            }\n        } // font\n        this.modifiedEmSizeStack = false;\n        if (typeof ctx.font !== \"undefined\") {\n            var fontStyleProp = this.getStyle(\"font\");\n            var fontStyleStyleProp = this.getStyle(\"font-style\");\n            var fontVariantStyleProp = this.getStyle(\"font-variant\");\n            var fontWeightStyleProp = this.getStyle(\"font-weight\");\n            var fontSizeStyleProp = this.getStyle(\"font-size\");\n            var fontFamilyStyleProp = this.getStyle(\"font-family\");\n            var font = new Font(fontStyleStyleProp.getString(), fontVariantStyleProp.getString(), fontWeightStyleProp.getString(), fontSizeStyleProp.hasValue() ? \"\".concat(fontSizeStyleProp.getPixels(true), \"px\") : \"\", fontFamilyStyleProp.getString(), Font.parse(fontStyleProp.getString(), ctx.font));\n            fontStyleStyleProp.setValue(font.fontStyle);\n            fontVariantStyleProp.setValue(font.fontVariant);\n            fontWeightStyleProp.setValue(font.fontWeight);\n            fontSizeStyleProp.setValue(font.fontSize);\n            fontFamilyStyleProp.setValue(font.fontFamily);\n            ctx.font = font.toString();\n            if (fontSizeStyleProp.isPixels()) {\n                this.document.emSize = fontSizeStyleProp.getPixels();\n                this.modifiedEmSizeStack = true;\n            }\n        }\n        if (!fromMeasure) {\n            // effects\n            this.applyEffects(ctx); // opacity\n            ctx.globalAlpha = this.calculateOpacity();\n        }\n    }\n    clearContext(ctx) {\n        super.clearContext(ctx);\n        if (this.modifiedEmSizeStack) {\n            this.document.popEmSize();\n        }\n    }\n}\nclass PathElement extends RenderedElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"path\";\n        this.pathParser = null;\n        this.pathParser = new PathParser(this.getAttribute(\"d\").getString());\n    }\n    path(ctx) {\n        var { pathParser } = this;\n        var boundingBox = new BoundingBox();\n        pathParser.reset();\n        if (ctx) {\n            ctx.beginPath();\n        }\n        while(!pathParser.isEnd()){\n            switch(pathParser.next().type){\n                case PathParser.MOVE_TO:\n                    this.pathM(ctx, boundingBox);\n                    break;\n                case PathParser.LINE_TO:\n                    this.pathL(ctx, boundingBox);\n                    break;\n                case PathParser.HORIZ_LINE_TO:\n                    this.pathH(ctx, boundingBox);\n                    break;\n                case PathParser.VERT_LINE_TO:\n                    this.pathV(ctx, boundingBox);\n                    break;\n                case PathParser.CURVE_TO:\n                    this.pathC(ctx, boundingBox);\n                    break;\n                case PathParser.SMOOTH_CURVE_TO:\n                    this.pathS(ctx, boundingBox);\n                    break;\n                case PathParser.QUAD_TO:\n                    this.pathQ(ctx, boundingBox);\n                    break;\n                case PathParser.SMOOTH_QUAD_TO:\n                    this.pathT(ctx, boundingBox);\n                    break;\n                case PathParser.ARC:\n                    this.pathA(ctx, boundingBox);\n                    break;\n                case PathParser.CLOSE_PATH:\n                    this.pathZ(ctx, boundingBox);\n                    break;\n            }\n        }\n        return boundingBox;\n    }\n    getBoundingBox(_) {\n        return this.path();\n    }\n    getMarkers() {\n        var { pathParser } = this;\n        var points = pathParser.getMarkerPoints();\n        var angles = pathParser.getMarkerAngles();\n        var markers = points.map((point, i)=>[\n                point,\n                angles[i]\n            ]);\n        return markers;\n    }\n    renderChildren(ctx) {\n        this.path(ctx);\n        this.document.screen.mouse.checkPath(this, ctx);\n        var fillRuleStyleProp = this.getStyle(\"fill-rule\");\n        if (ctx.fillStyle !== \"\") {\n            if (fillRuleStyleProp.getString(\"inherit\") !== \"inherit\") {\n                ctx.fill(fillRuleStyleProp.getString());\n            } else {\n                ctx.fill();\n            }\n        }\n        if (ctx.strokeStyle !== \"\") {\n            if (this.getAttribute(\"vector-effect\").getString() === \"non-scaling-stroke\") {\n                ctx.save();\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.stroke();\n                ctx.restore();\n            } else {\n                ctx.stroke();\n            }\n        }\n        var markers = this.getMarkers();\n        if (markers) {\n            var markersLastIndex = markers.length - 1;\n            var markerStartStyleProp = this.getStyle(\"marker-start\");\n            var markerMidStyleProp = this.getStyle(\"marker-mid\");\n            var markerEndStyleProp = this.getStyle(\"marker-end\");\n            if (markerStartStyleProp.isUrlDefinition()) {\n                var marker = markerStartStyleProp.getDefinition();\n                var [point, angle] = markers[0];\n                marker.render(ctx, point, angle);\n            }\n            if (markerMidStyleProp.isUrlDefinition()) {\n                var _marker = markerMidStyleProp.getDefinition();\n                for(var i = 1; i < markersLastIndex; i++){\n                    var [_point, _angle] = markers[i];\n                    _marker.render(ctx, _point, _angle);\n                }\n            }\n            if (markerEndStyleProp.isUrlDefinition()) {\n                var _marker2 = markerEndStyleProp.getDefinition();\n                var [_point2, _angle2] = markers[markersLastIndex];\n                _marker2.render(ctx, _point2, _angle2);\n            }\n        }\n    }\n    static pathM(pathParser) {\n        var point = pathParser.getAsCurrentPoint();\n        pathParser.start = pathParser.current;\n        return {\n            point\n        };\n    }\n    pathM(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { point } = PathElement.pathM(pathParser);\n        var { x, y } = point;\n        pathParser.addMarker(point);\n        boundingBox.addPoint(x, y);\n        if (ctx) {\n            ctx.moveTo(x, y);\n        }\n    }\n    static pathL(pathParser) {\n        var { current } = pathParser;\n        var point = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            point\n        };\n    }\n    pathL(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, point } = PathElement.pathL(pathParser);\n        var { x, y } = point;\n        pathParser.addMarker(point, current);\n        boundingBox.addPoint(x, y);\n        if (ctx) {\n            ctx.lineTo(x, y);\n        }\n    }\n    static pathH(pathParser) {\n        var { current, command } = pathParser;\n        var point = new Point((command.relative ? current.x : 0) + command.x, current.y);\n        pathParser.current = point;\n        return {\n            current,\n            point\n        };\n    }\n    pathH(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, point } = PathElement.pathH(pathParser);\n        var { x, y } = point;\n        pathParser.addMarker(point, current);\n        boundingBox.addPoint(x, y);\n        if (ctx) {\n            ctx.lineTo(x, y);\n        }\n    }\n    static pathV(pathParser) {\n        var { current, command } = pathParser;\n        var point = new Point(current.x, (command.relative ? current.y : 0) + command.y);\n        pathParser.current = point;\n        return {\n            current,\n            point\n        };\n    }\n    pathV(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, point } = PathElement.pathV(pathParser);\n        var { x, y } = point;\n        pathParser.addMarker(point, current);\n        boundingBox.addPoint(x, y);\n        if (ctx) {\n            ctx.lineTo(x, y);\n        }\n    }\n    static pathC(pathParser) {\n        var { current } = pathParser;\n        var point = pathParser.getPoint(\"x1\", \"y1\");\n        var controlPoint = pathParser.getAsControlPoint(\"x2\", \"y2\");\n        var currentPoint = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            point,\n            controlPoint,\n            currentPoint\n        };\n    }\n    pathC(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, point, controlPoint, currentPoint } = PathElement.pathC(pathParser);\n        pathParser.addMarker(currentPoint, controlPoint, point);\n        boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        if (ctx) {\n            ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        }\n    }\n    static pathS(pathParser) {\n        var { current } = pathParser;\n        var point = pathParser.getReflectedControlPoint();\n        var controlPoint = pathParser.getAsControlPoint(\"x2\", \"y2\");\n        var currentPoint = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            point,\n            controlPoint,\n            currentPoint\n        };\n    }\n    pathS(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, point, controlPoint, currentPoint } = PathElement.pathS(pathParser);\n        pathParser.addMarker(currentPoint, controlPoint, point);\n        boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        if (ctx) {\n            ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        }\n    }\n    static pathQ(pathParser) {\n        var { current } = pathParser;\n        var controlPoint = pathParser.getAsControlPoint(\"x1\", \"y1\");\n        var currentPoint = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            controlPoint,\n            currentPoint\n        };\n    }\n    pathQ(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, controlPoint, currentPoint } = PathElement.pathQ(pathParser);\n        pathParser.addMarker(currentPoint, controlPoint, controlPoint);\n        boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        if (ctx) {\n            ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        }\n    }\n    static pathT(pathParser) {\n        var { current } = pathParser;\n        var controlPoint = pathParser.getReflectedControlPoint();\n        pathParser.control = controlPoint;\n        var currentPoint = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            controlPoint,\n            currentPoint\n        };\n    }\n    pathT(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, controlPoint, currentPoint } = PathElement.pathT(pathParser);\n        pathParser.addMarker(currentPoint, controlPoint, controlPoint);\n        boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        if (ctx) {\n            ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        }\n    }\n    static pathA(pathParser) {\n        var { current, command } = pathParser;\n        var { rX, rY, xRot, lArcFlag, sweepFlag } = command;\n        var xAxisRotation = xRot * (Math.PI / 180.0);\n        var currentPoint = pathParser.getAsCurrentPoint(); // Conversion from endpoint to center parameterization\n        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n        // x1', y1'\n        var currp = new Point(Math.cos(xAxisRotation) * (current.x - currentPoint.x) / 2.0 + Math.sin(xAxisRotation) * (current.y - currentPoint.y) / 2.0, -Math.sin(xAxisRotation) * (current.x - currentPoint.x) / 2.0 + Math.cos(xAxisRotation) * (current.y - currentPoint.y) / 2.0); // adjust radii\n        var l = Math.pow(currp.x, 2) / Math.pow(rX, 2) + Math.pow(currp.y, 2) / Math.pow(rY, 2);\n        if (l > 1) {\n            rX *= Math.sqrt(l);\n            rY *= Math.sqrt(l);\n        } // cx', cy'\n        var s = (lArcFlag === sweepFlag ? -1 : 1) * Math.sqrt((Math.pow(rX, 2) * Math.pow(rY, 2) - Math.pow(rX, 2) * Math.pow(currp.y, 2) - Math.pow(rY, 2) * Math.pow(currp.x, 2)) / (Math.pow(rX, 2) * Math.pow(currp.y, 2) + Math.pow(rY, 2) * Math.pow(currp.x, 2)));\n        if (isNaN(s)) {\n            s = 0;\n        }\n        var cpp = new Point(s * rX * currp.y / rY, s * -rY * currp.x / rX); // cx, cy\n        var centp = new Point((current.x + currentPoint.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y, (current.y + currentPoint.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y); // initial angle\n        var a1 = vectorsAngle([\n            1,\n            0\n        ], [\n            (currp.x - cpp.x) / rX,\n            (currp.y - cpp.y) / rY\n        ]); // θ1\n        // angle delta\n        var u = [\n            (currp.x - cpp.x) / rX,\n            (currp.y - cpp.y) / rY\n        ];\n        var v = [\n            (-currp.x - cpp.x) / rX,\n            (-currp.y - cpp.y) / rY\n        ];\n        var ad = vectorsAngle(u, v); // Δθ\n        if (vectorsRatio(u, v) <= -1) {\n            ad = Math.PI;\n        }\n        if (vectorsRatio(u, v) >= 1) {\n            ad = 0;\n        }\n        return {\n            currentPoint,\n            rX,\n            rY,\n            sweepFlag,\n            xAxisRotation,\n            centp,\n            a1,\n            ad\n        };\n    }\n    pathA(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { currentPoint, rX, rY, sweepFlag, xAxisRotation, centp, a1, ad } = PathElement.pathA(pathParser); // for markers\n        var dir = 1 - sweepFlag ? 1.0 : -1.0;\n        var ah = a1 + dir * (ad / 2.0);\n        var halfWay = new Point(centp.x + rX * Math.cos(ah), centp.y + rY * Math.sin(ah));\n        pathParser.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);\n        pathParser.addMarkerAngle(currentPoint, ah - dir * Math.PI);\n        boundingBox.addPoint(currentPoint.x, currentPoint.y); // TODO: this is too naive, make it better\n        if (ctx && !isNaN(a1) && !isNaN(ad)) {\n            var r = rX > rY ? rX : rY;\n            var sx = rX > rY ? 1 : rX / rY;\n            var sy = rX > rY ? rY / rX : 1;\n            ctx.translate(centp.x, centp.y);\n            ctx.rotate(xAxisRotation);\n            ctx.scale(sx, sy);\n            ctx.arc(0, 0, r, a1, a1 + ad, Boolean(1 - sweepFlag));\n            ctx.scale(1 / sx, 1 / sy);\n            ctx.rotate(-xAxisRotation);\n            ctx.translate(-centp.x, -centp.y);\n        }\n    }\n    static pathZ(pathParser) {\n        pathParser.current = pathParser.start;\n    }\n    pathZ(ctx, boundingBox) {\n        PathElement.pathZ(this.pathParser);\n        if (ctx) {\n            // only close path if it is not a straight line\n            if (boundingBox.x1 !== boundingBox.x2 && boundingBox.y1 !== boundingBox.y2) {\n                ctx.closePath();\n            }\n        }\n    }\n}\nclass GlyphElement extends PathElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"glyph\";\n        this.horizAdvX = this.getAttribute(\"horiz-adv-x\").getNumber();\n        this.unicode = this.getAttribute(\"unicode\").getString();\n        this.arabicForm = this.getAttribute(\"arabic-form\").getString();\n    }\n}\nclass TextElement extends RenderedElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, new.target === TextElement ? true : captureTextNodes);\n        this.type = \"text\";\n        this.x = 0;\n        this.y = 0;\n        this.measureCache = -1;\n    }\n    setContext(ctx) {\n        var fromMeasure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        super.setContext(ctx, fromMeasure);\n        var textBaseline = this.getStyle(\"dominant-baseline\").getTextBaseline() || this.getStyle(\"alignment-baseline\").getTextBaseline();\n        if (textBaseline) {\n            ctx.textBaseline = textBaseline;\n        }\n    }\n    initializeCoordinates() {\n        this.x = 0;\n        this.y = 0;\n        this.leafTexts = [];\n        this.textChunkStart = 0;\n        this.minX = Number.POSITIVE_INFINITY;\n        this.maxX = Number.NEGATIVE_INFINITY;\n    }\n    getBoundingBox(ctx) {\n        if (this.type !== \"text\") {\n            return this.getTElementBoundingBox(ctx);\n        } // first, calculate child positions\n        this.initializeCoordinates();\n        this.adjustChildCoordinatesRecursive(ctx);\n        var boundingBox = null; // then calculate bounding box\n        this.children.forEach((_, i)=>{\n            var childBoundingBox = this.getChildBoundingBox(ctx, this, this, i);\n            if (!boundingBox) {\n                boundingBox = childBoundingBox;\n            } else {\n                boundingBox.addBoundingBox(childBoundingBox);\n            }\n        });\n        return boundingBox;\n    }\n    getFontSize() {\n        var { document: document1, parent } = this;\n        var inheritFontSize = Font.parse(document1.ctx.font).fontSize;\n        var fontSize = parent.getStyle(\"font-size\").getNumber(inheritFontSize);\n        return fontSize;\n    }\n    getTElementBoundingBox(ctx) {\n        var fontSize = this.getFontSize();\n        return new BoundingBox(this.x, this.y - fontSize, this.x + this.measureText(ctx), this.y);\n    }\n    getGlyph(font, text, i) {\n        var char = text[i];\n        var glyph = null;\n        if (font.isArabic) {\n            var len = text.length;\n            var prevChar = text[i - 1];\n            var nextChar = text[i + 1];\n            var arabicForm = \"isolated\";\n            if ((i === 0 || prevChar === \" \") && i < len - 1 && nextChar !== \" \") {\n                arabicForm = \"terminal\";\n            }\n            if (i > 0 && prevChar !== \" \" && i < len - 1 && nextChar !== \" \") {\n                arabicForm = \"medial\";\n            }\n            if (i > 0 && prevChar !== \" \" && (i === len - 1 || nextChar === \" \")) {\n                arabicForm = \"initial\";\n            }\n            if (typeof font.glyphs[char] !== \"undefined\") {\n                // NEED TEST\n                var maybeGlyph = font.glyphs[char];\n                glyph = maybeGlyph instanceof GlyphElement ? maybeGlyph : maybeGlyph[arabicForm];\n            }\n        } else {\n            glyph = font.glyphs[char];\n        }\n        if (!glyph) {\n            glyph = font.missingGlyph;\n        }\n        return glyph;\n    }\n    getText() {\n        return \"\";\n    }\n    getTextFromNode(node) {\n        var textNode = node || this.node;\n        var childNodes = Array.from(textNode.parentNode.childNodes);\n        var index = childNodes.indexOf(textNode);\n        var lastIndex = childNodes.length - 1;\n        var text = compressSpaces(// || textNode.text\n        textNode.textContent || \"\");\n        if (index === 0) {\n            text = trimLeft(text);\n        }\n        if (index === lastIndex) {\n            text = trimRight(text);\n        }\n        return text;\n    }\n    renderChildren(ctx) {\n        if (this.type !== \"text\") {\n            this.renderTElementChildren(ctx);\n            return;\n        } // first, calculate child positions\n        this.initializeCoordinates();\n        this.adjustChildCoordinatesRecursive(ctx); // then render\n        this.children.forEach((_, i)=>{\n            this.renderChild(ctx, this, this, i);\n        });\n        var { mouse } = this.document.screen; // Do not calc bounding box if mouse is not working.\n        if (mouse.isWorking()) {\n            mouse.checkBoundingBox(this, this.getBoundingBox(ctx));\n        }\n    }\n    renderTElementChildren(ctx) {\n        var { document: document1, parent } = this;\n        var renderText = this.getText();\n        var customFont = parent.getStyle(\"font-family\").getDefinition();\n        if (customFont) {\n            var { unitsPerEm } = customFont.fontFace;\n            var ctxFont = Font.parse(document1.ctx.font);\n            var fontSize = parent.getStyle(\"font-size\").getNumber(ctxFont.fontSize);\n            var fontStyle = parent.getStyle(\"font-style\").getString(ctxFont.fontStyle);\n            var scale = fontSize / unitsPerEm;\n            var text = customFont.isRTL ? renderText.split(\"\").reverse().join(\"\") : renderText;\n            var dx = toNumbers(parent.getAttribute(\"dx\").getString());\n            var len = text.length;\n            for(var i = 0; i < len; i++){\n                var glyph = this.getGlyph(customFont, text, i);\n                ctx.translate(this.x, this.y);\n                ctx.scale(scale, -scale);\n                var lw = ctx.lineWidth;\n                ctx.lineWidth = ctx.lineWidth * unitsPerEm / fontSize;\n                if (fontStyle === \"italic\") {\n                    ctx.transform(1, 0, .4, 1, 0, 0);\n                }\n                glyph.render(ctx);\n                if (fontStyle === \"italic\") {\n                    ctx.transform(1, 0, -.4, 1, 0, 0);\n                }\n                ctx.lineWidth = lw;\n                ctx.scale(1 / scale, -1 / scale);\n                ctx.translate(-this.x, -this.y);\n                this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / unitsPerEm;\n                if (typeof dx[i] !== \"undefined\" && !isNaN(dx[i])) {\n                    this.x += dx[i];\n                }\n            }\n            return;\n        }\n        var { x, y } = this; // NEED TEST\n        // if (ctx.paintOrder === 'stroke') {\n        // \tif (ctx.strokeStyle) {\n        // \t\tctx.strokeText(renderText, x, y);\n        // \t}\n        // \tif (ctx.fillStyle) {\n        // \t\tctx.fillText(renderText, x, y);\n        // \t}\n        // } else {\n        if (ctx.fillStyle) {\n            ctx.fillText(renderText, x, y);\n        }\n        if (ctx.strokeStyle) {\n            ctx.strokeText(renderText, x, y);\n        } // }\n    }\n    applyAnchoring() {\n        if (this.textChunkStart >= this.leafTexts.length) {\n            return;\n        } // This is basically the \"Apply anchoring\" part of https://www.w3.org/TR/SVG2/text.html#TextLayoutAlgorithm.\n        // The difference is that we apply the anchoring as soon as a chunk is finished. This saves some extra looping.\n        // Vertical text is not supported.\n        var firstElement = this.leafTexts[this.textChunkStart];\n        var textAnchor = firstElement.getStyle(\"text-anchor\").getString(\"start\");\n        var isRTL = false; // we treat RTL like LTR\n        var shift = 0;\n        if (textAnchor === \"start\" && !isRTL || textAnchor === \"end\" && isRTL) {\n            shift = firstElement.x - this.minX;\n        } else if (textAnchor === \"end\" && !isRTL || textAnchor === \"start\" && isRTL) {\n            shift = firstElement.x - this.maxX;\n        } else {\n            shift = firstElement.x - (this.minX + this.maxX) / 2;\n        }\n        for(var i = this.textChunkStart; i < this.leafTexts.length; i++){\n            this.leafTexts[i].x += shift;\n        } // start new chunk\n        this.minX = Number.POSITIVE_INFINITY;\n        this.maxX = Number.NEGATIVE_INFINITY;\n        this.textChunkStart = this.leafTexts.length;\n    }\n    adjustChildCoordinatesRecursive(ctx) {\n        this.children.forEach((_, i)=>{\n            this.adjustChildCoordinatesRecursiveCore(ctx, this, this, i);\n        });\n        this.applyAnchoring();\n    }\n    adjustChildCoordinatesRecursiveCore(ctx, textParent, parent, i) {\n        var child = parent.children[i];\n        if (child.children.length > 0) {\n            child.children.forEach((_, i)=>{\n                textParent.adjustChildCoordinatesRecursiveCore(ctx, textParent, child, i);\n            });\n        } else {\n            // only leafs are relevant\n            this.adjustChildCoordinates(ctx, textParent, parent, i);\n        }\n    }\n    adjustChildCoordinates(ctx, textParent, parent, i) {\n        var child = parent.children[i];\n        if (typeof child.measureText !== \"function\") {\n            return child;\n        }\n        ctx.save();\n        child.setContext(ctx, true);\n        var xAttr = child.getAttribute(\"x\");\n        var yAttr = child.getAttribute(\"y\");\n        var dxAttr = child.getAttribute(\"dx\");\n        var dyAttr = child.getAttribute(\"dy\");\n        var customFont = child.getStyle(\"font-family\").getDefinition();\n        var isRTL = Boolean(customFont) && customFont.isRTL;\n        if (i === 0) {\n            // First children inherit attributes from parent(s). Positional attributes\n            // are only inherited from a parent to it's first child.\n            if (!xAttr.hasValue()) {\n                xAttr.setValue(child.getInheritedAttribute(\"x\"));\n            }\n            if (!yAttr.hasValue()) {\n                yAttr.setValue(child.getInheritedAttribute(\"y\"));\n            }\n            if (!dxAttr.hasValue()) {\n                dxAttr.setValue(child.getInheritedAttribute(\"dx\"));\n            }\n            if (!dyAttr.hasValue()) {\n                dyAttr.setValue(child.getInheritedAttribute(\"dy\"));\n            }\n        }\n        var width = child.measureText(ctx);\n        if (isRTL) {\n            textParent.x -= width;\n        }\n        if (xAttr.hasValue()) {\n            // an \"x\" attribute marks the start of a new chunk\n            textParent.applyAnchoring();\n            child.x = xAttr.getPixels(\"x\");\n            if (dxAttr.hasValue()) {\n                child.x += dxAttr.getPixels(\"x\");\n            }\n        } else {\n            if (dxAttr.hasValue()) {\n                textParent.x += dxAttr.getPixels(\"x\");\n            }\n            child.x = textParent.x;\n        }\n        textParent.x = child.x;\n        if (!isRTL) {\n            textParent.x += width;\n        }\n        if (yAttr.hasValue()) {\n            child.y = yAttr.getPixels(\"y\");\n            if (dyAttr.hasValue()) {\n                child.y += dyAttr.getPixels(\"y\");\n            }\n        } else {\n            if (dyAttr.hasValue()) {\n                textParent.y += dyAttr.getPixels(\"y\");\n            }\n            child.y = textParent.y;\n        }\n        textParent.y = child.y; // update the current chunk and it's bounds\n        textParent.leafTexts.push(child);\n        textParent.minX = Math.min(textParent.minX, child.x, child.x + width);\n        textParent.maxX = Math.max(textParent.maxX, child.x, child.x + width);\n        child.clearContext(ctx);\n        ctx.restore();\n        return child;\n    }\n    getChildBoundingBox(ctx, textParent, parent, i) {\n        var child = parent.children[i]; // not a text node?\n        if (typeof child.getBoundingBox !== \"function\") {\n            return null;\n        }\n        var boundingBox = child.getBoundingBox(ctx);\n        if (!boundingBox) {\n            return null;\n        }\n        child.children.forEach((_, i)=>{\n            var childBoundingBox = textParent.getChildBoundingBox(ctx, textParent, child, i);\n            boundingBox.addBoundingBox(childBoundingBox);\n        });\n        return boundingBox;\n    }\n    renderChild(ctx, textParent, parent, i) {\n        var child = parent.children[i];\n        child.render(ctx);\n        child.children.forEach((_, i)=>{\n            textParent.renderChild(ctx, textParent, child, i);\n        });\n    }\n    measureText(ctx) {\n        var { measureCache } = this;\n        if (~measureCache) {\n            return measureCache;\n        }\n        var renderText = this.getText();\n        var measure = this.measureTargetText(ctx, renderText);\n        this.measureCache = measure;\n        return measure;\n    }\n    measureTargetText(ctx, targetText) {\n        if (!targetText.length) {\n            return 0;\n        }\n        var { parent } = this;\n        var customFont = parent.getStyle(\"font-family\").getDefinition();\n        if (customFont) {\n            var fontSize = this.getFontSize();\n            var text = customFont.isRTL ? targetText.split(\"\").reverse().join(\"\") : targetText;\n            var dx = toNumbers(parent.getAttribute(\"dx\").getString());\n            var len = text.length;\n            var _measure = 0;\n            for(var i = 0; i < len; i++){\n                var glyph = this.getGlyph(customFont, text, i);\n                _measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;\n                if (typeof dx[i] !== \"undefined\" && !isNaN(dx[i])) {\n                    _measure += dx[i];\n                }\n            }\n            return _measure;\n        }\n        if (!ctx.measureText) {\n            return targetText.length * 10;\n        }\n        ctx.save();\n        this.setContext(ctx, true);\n        var { width: measure } = ctx.measureText(targetText);\n        this.clearContext(ctx);\n        ctx.restore();\n        return measure;\n    }\n    /**\r\n   * Inherits positional attributes from {@link TextElement} parent(s). Attributes\r\n   * are only inherited from a parent to its first child.\r\n   * @param name - The attribute name.\r\n   * @returns The attribute value or null.\r\n   */ getInheritedAttribute(name) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias,consistent-this\n        var current = this;\n        while(current instanceof TextElement && current.isFirstChild()){\n            var parentAttr = current.parent.getAttribute(name);\n            if (parentAttr.hasValue(true)) {\n                return parentAttr.getValue(\"0\");\n            }\n            current = current.parent;\n        }\n        return null;\n    }\n}\nclass TSpanElement extends TextElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, new.target === TSpanElement ? true : captureTextNodes);\n        this.type = \"tspan\"; // if this node has children, then they own the text\n        this.text = this.children.length > 0 ? \"\" : this.getTextFromNode();\n    }\n    getText() {\n        return this.text;\n    }\n}\nclass TextNode extends TSpanElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"textNode\";\n    }\n}\nclass SVGElement extends RenderedElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"svg\";\n        this.root = false;\n    }\n    setContext(ctx) {\n        var _this$node$parentNode;\n        var { document: document1 } = this;\n        var { screen, window: window1 } = document1;\n        var canvas = ctx.canvas;\n        screen.setDefaults(ctx);\n        if (canvas.style && typeof ctx.font !== \"undefined\" && window1 && typeof window1.getComputedStyle !== \"undefined\") {\n            ctx.font = window1.getComputedStyle(canvas).getPropertyValue(\"font\");\n            var fontSizeProp = new Property(document1, \"fontSize\", Font.parse(ctx.font).fontSize);\n            if (fontSizeProp.hasValue()) {\n                document1.rootEmSize = fontSizeProp.getPixels(\"y\");\n                document1.emSize = document1.rootEmSize;\n            }\n        } // create new view port\n        if (!this.getAttribute(\"x\").hasValue()) {\n            this.getAttribute(\"x\", true).setValue(0);\n        }\n        if (!this.getAttribute(\"y\").hasValue()) {\n            this.getAttribute(\"y\", true).setValue(0);\n        }\n        var { width, height } = screen.viewPort;\n        if (!this.getStyle(\"width\").hasValue()) {\n            this.getStyle(\"width\", true).setValue(\"100%\");\n        }\n        if (!this.getStyle(\"height\").hasValue()) {\n            this.getStyle(\"height\", true).setValue(\"100%\");\n        }\n        if (!this.getStyle(\"color\").hasValue()) {\n            this.getStyle(\"color\", true).setValue(\"black\");\n        }\n        var refXAttr = this.getAttribute(\"refX\");\n        var refYAttr = this.getAttribute(\"refY\");\n        var viewBoxAttr = this.getAttribute(\"viewBox\");\n        var viewBox = viewBoxAttr.hasValue() ? toNumbers(viewBoxAttr.getString()) : null;\n        var clip = !this.root && this.getStyle(\"overflow\").getValue(\"hidden\") !== \"visible\";\n        var minX = 0;\n        var minY = 0;\n        var clipX = 0;\n        var clipY = 0;\n        if (viewBox) {\n            minX = viewBox[0];\n            minY = viewBox[1];\n        }\n        if (!this.root) {\n            width = this.getStyle(\"width\").getPixels(\"x\");\n            height = this.getStyle(\"height\").getPixels(\"y\");\n            if (this.type === \"marker\") {\n                clipX = minX;\n                clipY = minY;\n                minX = 0;\n                minY = 0;\n            }\n        }\n        screen.viewPort.setCurrent(width, height); // Default value of transform-origin is center only for root SVG elements\n        // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform-origin\n        if (this.node // is not temporary SVGElement\n         && (!this.parent || ((_this$node$parentNode = this.node.parentNode) === null || _this$node$parentNode === void 0 ? void 0 : _this$node$parentNode.nodeName) === \"foreignObject\") && this.getStyle(\"transform\", false, true).hasValue() && !this.getStyle(\"transform-origin\", false, true).hasValue()) {\n            this.getStyle(\"transform-origin\", true, true).setValue(\"50% 50%\");\n        }\n        super.setContext(ctx);\n        ctx.translate(this.getAttribute(\"x\").getPixels(\"x\"), this.getAttribute(\"y\").getPixels(\"y\"));\n        if (viewBox) {\n            width = viewBox[2];\n            height = viewBox[3];\n        }\n        document1.setViewBox({\n            ctx,\n            aspectRatio: this.getAttribute(\"preserveAspectRatio\").getString(),\n            width: screen.viewPort.width,\n            desiredWidth: width,\n            height: screen.viewPort.height,\n            desiredHeight: height,\n            minX,\n            minY,\n            refX: refXAttr.getValue(),\n            refY: refYAttr.getValue(),\n            clip,\n            clipX,\n            clipY\n        });\n        if (viewBox) {\n            screen.viewPort.removeCurrent();\n            screen.viewPort.setCurrent(width, height);\n        }\n    }\n    clearContext(ctx) {\n        super.clearContext(ctx);\n        this.document.screen.viewPort.removeCurrent();\n    }\n    /**\r\n   * Resize SVG to fit in given size.\r\n   * @param width\r\n   * @param height\r\n   * @param preserveAspectRatio\r\n   */ resize(width) {\n        var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : width;\n        var preserveAspectRatio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var widthAttr = this.getAttribute(\"width\", true);\n        var heightAttr = this.getAttribute(\"height\", true);\n        var viewBoxAttr = this.getAttribute(\"viewBox\");\n        var styleAttr = this.getAttribute(\"style\");\n        var originWidth = widthAttr.getNumber(0);\n        var originHeight = heightAttr.getNumber(0);\n        if (preserveAspectRatio) {\n            if (typeof preserveAspectRatio === \"string\") {\n                this.getAttribute(\"preserveAspectRatio\", true).setValue(preserveAspectRatio);\n            } else {\n                var preserveAspectRatioAttr = this.getAttribute(\"preserveAspectRatio\");\n                if (preserveAspectRatioAttr.hasValue()) {\n                    preserveAspectRatioAttr.setValue(preserveAspectRatioAttr.getString().replace(/^\\s*(\\S.*\\S)\\s*$/, \"$1\"));\n                }\n            }\n        }\n        widthAttr.setValue(width);\n        heightAttr.setValue(height);\n        if (!viewBoxAttr.hasValue()) {\n            viewBoxAttr.setValue(\"0 0 \".concat(originWidth || width, \" \").concat(originHeight || height));\n        }\n        if (styleAttr.hasValue()) {\n            var widthStyle = this.getStyle(\"width\");\n            var heightStyle = this.getStyle(\"height\");\n            if (widthStyle.hasValue()) {\n                widthStyle.setValue(\"\".concat(width, \"px\"));\n            }\n            if (heightStyle.hasValue()) {\n                heightStyle.setValue(\"\".concat(height, \"px\"));\n            }\n        }\n    }\n}\nclass RectElement extends PathElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"rect\";\n    }\n    path(ctx) {\n        var x = this.getAttribute(\"x\").getPixels(\"x\");\n        var y = this.getAttribute(\"y\").getPixels(\"y\");\n        var width = this.getStyle(\"width\", false, true).getPixels(\"x\");\n        var height = this.getStyle(\"height\", false, true).getPixels(\"y\");\n        var rxAttr = this.getAttribute(\"rx\");\n        var ryAttr = this.getAttribute(\"ry\");\n        var rx = rxAttr.getPixels(\"x\");\n        var ry = ryAttr.getPixels(\"y\");\n        if (rxAttr.hasValue() && !ryAttr.hasValue()) {\n            ry = rx;\n        }\n        if (ryAttr.hasValue() && !rxAttr.hasValue()) {\n            rx = ry;\n        }\n        rx = Math.min(rx, width / 2.0);\n        ry = Math.min(ry, height / 2.0);\n        if (ctx) {\n            var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);\n            ctx.beginPath(); // always start the path so we don't fill prior paths\n            if (height > 0 && width > 0) {\n                ctx.moveTo(x + rx, y);\n                ctx.lineTo(x + width - rx, y);\n                ctx.bezierCurveTo(x + width - rx + KAPPA * rx, y, x + width, y + ry - KAPPA * ry, x + width, y + ry);\n                ctx.lineTo(x + width, y + height - ry);\n                ctx.bezierCurveTo(x + width, y + height - ry + KAPPA * ry, x + width - rx + KAPPA * rx, y + height, x + width - rx, y + height);\n                ctx.lineTo(x + rx, y + height);\n                ctx.bezierCurveTo(x + rx - KAPPA * rx, y + height, x, y + height - ry + KAPPA * ry, x, y + height - ry);\n                ctx.lineTo(x, y + ry);\n                ctx.bezierCurveTo(x, y + ry - KAPPA * ry, x + rx - KAPPA * rx, y, x + rx, y);\n                ctx.closePath();\n            }\n        }\n        return new BoundingBox(x, y, x + width, y + height);\n    }\n    getMarkers() {\n        return null;\n    }\n}\nclass CircleElement extends PathElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"circle\";\n    }\n    path(ctx) {\n        var cx = this.getAttribute(\"cx\").getPixels(\"x\");\n        var cy = this.getAttribute(\"cy\").getPixels(\"y\");\n        var r = this.getAttribute(\"r\").getPixels();\n        if (ctx && r > 0) {\n            ctx.beginPath();\n            ctx.arc(cx, cy, r, 0, Math.PI * 2, false);\n            ctx.closePath();\n        }\n        return new BoundingBox(cx - r, cy - r, cx + r, cy + r);\n    }\n    getMarkers() {\n        return null;\n    }\n}\nclass EllipseElement extends PathElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"ellipse\";\n    }\n    path(ctx) {\n        var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);\n        var rx = this.getAttribute(\"rx\").getPixels(\"x\");\n        var ry = this.getAttribute(\"ry\").getPixels(\"y\");\n        var cx = this.getAttribute(\"cx\").getPixels(\"x\");\n        var cy = this.getAttribute(\"cy\").getPixels(\"y\");\n        if (ctx && rx > 0 && ry > 0) {\n            ctx.beginPath();\n            ctx.moveTo(cx + rx, cy);\n            ctx.bezierCurveTo(cx + rx, cy + KAPPA * ry, cx + KAPPA * rx, cy + ry, cx, cy + ry);\n            ctx.bezierCurveTo(cx - KAPPA * rx, cy + ry, cx - rx, cy + KAPPA * ry, cx - rx, cy);\n            ctx.bezierCurveTo(cx - rx, cy - KAPPA * ry, cx - KAPPA * rx, cy - ry, cx, cy - ry);\n            ctx.bezierCurveTo(cx + KAPPA * rx, cy - ry, cx + rx, cy - KAPPA * ry, cx + rx, cy);\n            ctx.closePath();\n        }\n        return new BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);\n    }\n    getMarkers() {\n        return null;\n    }\n}\nclass LineElement extends PathElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"line\";\n    }\n    getPoints() {\n        return [\n            new Point(this.getAttribute(\"x1\").getPixels(\"x\"), this.getAttribute(\"y1\").getPixels(\"y\")),\n            new Point(this.getAttribute(\"x2\").getPixels(\"x\"), this.getAttribute(\"y2\").getPixels(\"y\"))\n        ];\n    }\n    path(ctx) {\n        var [{ x: x0, y: y0 }, { x: x1, y: y1 }] = this.getPoints();\n        if (ctx) {\n            ctx.beginPath();\n            ctx.moveTo(x0, y0);\n            ctx.lineTo(x1, y1);\n        }\n        return new BoundingBox(x0, y0, x1, y1);\n    }\n    getMarkers() {\n        var [p0, p1] = this.getPoints();\n        var a = p0.angleTo(p1);\n        return [\n            [\n                p0,\n                a\n            ],\n            [\n                p1,\n                a\n            ]\n        ];\n    }\n}\nclass PolylineElement extends PathElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"polyline\";\n        this.points = [];\n        this.points = Point.parsePath(this.getAttribute(\"points\").getString());\n    }\n    path(ctx) {\n        var { points } = this;\n        var [{ x: x0, y: y0 }] = points;\n        var boundingBox = new BoundingBox(x0, y0);\n        if (ctx) {\n            ctx.beginPath();\n            ctx.moveTo(x0, y0);\n        }\n        points.forEach((_ref)=>{\n            var { x, y } = _ref;\n            boundingBox.addPoint(x, y);\n            if (ctx) {\n                ctx.lineTo(x, y);\n            }\n        });\n        return boundingBox;\n    }\n    getMarkers() {\n        var { points } = this;\n        var lastIndex = points.length - 1;\n        var markers = [];\n        points.forEach((point, i)=>{\n            if (i === lastIndex) {\n                return;\n            }\n            markers.push([\n                point,\n                point.angleTo(points[i + 1])\n            ]);\n        });\n        if (markers.length > 0) {\n            markers.push([\n                points[points.length - 1],\n                markers[markers.length - 1][1]\n            ]);\n        }\n        return markers;\n    }\n}\nclass PolygonElement extends PolylineElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"polygon\";\n    }\n    path(ctx) {\n        var boundingBox = super.path(ctx);\n        var [{ x, y }] = this.points;\n        if (ctx) {\n            ctx.lineTo(x, y);\n            ctx.closePath();\n        }\n        return boundingBox;\n    }\n}\nclass PatternElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"pattern\";\n    }\n    createPattern(ctx, _, parentOpacityProp) {\n        var width = this.getStyle(\"width\").getPixels(\"x\", true);\n        var height = this.getStyle(\"height\").getPixels(\"y\", true); // render me using a temporary svg element\n        var patternSvg = new SVGElement(this.document, null);\n        patternSvg.attributes.viewBox = new Property(this.document, \"viewBox\", this.getAttribute(\"viewBox\").getValue());\n        patternSvg.attributes.width = new Property(this.document, \"width\", \"\".concat(width, \"px\"));\n        patternSvg.attributes.height = new Property(this.document, \"height\", \"\".concat(height, \"px\"));\n        patternSvg.attributes.transform = new Property(this.document, \"transform\", this.getAttribute(\"patternTransform\").getValue());\n        patternSvg.children = this.children;\n        var patternCanvas = this.document.createCanvas(width, height);\n        var patternCtx = patternCanvas.getContext(\"2d\");\n        var xAttr = this.getAttribute(\"x\");\n        var yAttr = this.getAttribute(\"y\");\n        if (xAttr.hasValue() && yAttr.hasValue()) {\n            patternCtx.translate(xAttr.getPixels(\"x\", true), yAttr.getPixels(\"y\", true));\n        }\n        if (parentOpacityProp.hasValue()) {\n            this.styles[\"fill-opacity\"] = parentOpacityProp;\n        } else {\n            Reflect.deleteProperty(this.styles, \"fill-opacity\");\n        } // render 3x3 grid so when we transform there's no white space on edges\n        for(var x = -1; x <= 1; x++){\n            for(var y = -1; y <= 1; y++){\n                patternCtx.save();\n                patternSvg.attributes.x = new Property(this.document, \"x\", x * patternCanvas.width);\n                patternSvg.attributes.y = new Property(this.document, \"y\", y * patternCanvas.height);\n                patternSvg.render(patternCtx);\n                patternCtx.restore();\n            }\n        }\n        var pattern = ctx.createPattern(patternCanvas, \"repeat\");\n        return pattern;\n    }\n}\nclass MarkerElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"marker\";\n    }\n    render(ctx, point, angle) {\n        if (!point) {\n            return;\n        }\n        var { x, y } = point;\n        var orient = this.getAttribute(\"orient\").getString(\"auto\");\n        var markerUnits = this.getAttribute(\"markerUnits\").getString(\"strokeWidth\");\n        ctx.translate(x, y);\n        if (orient === \"auto\") {\n            ctx.rotate(angle);\n        }\n        if (markerUnits === \"strokeWidth\") {\n            ctx.scale(ctx.lineWidth, ctx.lineWidth);\n        }\n        ctx.save(); // render me using a temporary svg element\n        var markerSvg = new SVGElement(this.document, null);\n        markerSvg.type = this.type;\n        markerSvg.attributes.viewBox = new Property(this.document, \"viewBox\", this.getAttribute(\"viewBox\").getValue());\n        markerSvg.attributes.refX = new Property(this.document, \"refX\", this.getAttribute(\"refX\").getValue());\n        markerSvg.attributes.refY = new Property(this.document, \"refY\", this.getAttribute(\"refY\").getValue());\n        markerSvg.attributes.width = new Property(this.document, \"width\", this.getAttribute(\"markerWidth\").getValue());\n        markerSvg.attributes.height = new Property(this.document, \"height\", this.getAttribute(\"markerHeight\").getValue());\n        markerSvg.attributes.overflow = new Property(this.document, \"overflow\", this.getAttribute(\"overflow\").getValue());\n        markerSvg.attributes.fill = new Property(this.document, \"fill\", this.getAttribute(\"fill\").getColor(\"black\"));\n        markerSvg.attributes.stroke = new Property(this.document, \"stroke\", this.getAttribute(\"stroke\").getValue(\"none\"));\n        markerSvg.children = this.children;\n        markerSvg.render(ctx);\n        ctx.restore();\n        if (markerUnits === \"strokeWidth\") {\n            ctx.scale(1 / ctx.lineWidth, 1 / ctx.lineWidth);\n        }\n        if (orient === \"auto\") {\n            ctx.rotate(-angle);\n        }\n        ctx.translate(-x, -y);\n    }\n}\nclass DefsElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"defs\";\n    }\n    render() {}\n}\nclass GElement extends RenderedElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"g\";\n    }\n    getBoundingBox(ctx) {\n        var boundingBox = new BoundingBox();\n        this.children.forEach((child)=>{\n            boundingBox.addBoundingBox(child.getBoundingBox(ctx));\n        });\n        return boundingBox;\n    }\n}\nclass GradientElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.attributesToInherit = [\n            \"gradientUnits\"\n        ];\n        this.stops = [];\n        var { stops, children } = this;\n        children.forEach((child)=>{\n            if (child.type === \"stop\") {\n                stops.push(child);\n            }\n        });\n    }\n    getGradientUnits() {\n        return this.getAttribute(\"gradientUnits\").getString(\"objectBoundingBox\");\n    }\n    createGradient(ctx, element, parentOpacityProp) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this\n        var stopsContainer = this;\n        if (this.getHrefAttribute().hasValue()) {\n            stopsContainer = this.getHrefAttribute().getDefinition();\n            this.inheritStopContainer(stopsContainer);\n        }\n        var { stops } = stopsContainer;\n        var gradient = this.getGradient(ctx, element);\n        if (!gradient) {\n            return this.addParentOpacity(parentOpacityProp, stops[stops.length - 1].color);\n        }\n        stops.forEach((stop)=>{\n            gradient.addColorStop(stop.offset, this.addParentOpacity(parentOpacityProp, stop.color));\n        });\n        if (this.getAttribute(\"gradientTransform\").hasValue()) {\n            // render as transformed pattern on temporary canvas\n            var { document: document1 } = this;\n            var { MAX_VIRTUAL_PIXELS, viewPort } = document1.screen;\n            var [rootView] = viewPort.viewPorts;\n            var rect = new RectElement(document1, null);\n            rect.attributes.x = new Property(document1, \"x\", -MAX_VIRTUAL_PIXELS / 3.0);\n            rect.attributes.y = new Property(document1, \"y\", -MAX_VIRTUAL_PIXELS / 3.0);\n            rect.attributes.width = new Property(document1, \"width\", MAX_VIRTUAL_PIXELS);\n            rect.attributes.height = new Property(document1, \"height\", MAX_VIRTUAL_PIXELS);\n            var group = new GElement(document1, null);\n            group.attributes.transform = new Property(document1, \"transform\", this.getAttribute(\"gradientTransform\").getValue());\n            group.children = [\n                rect\n            ];\n            var patternSvg = new SVGElement(document1, null);\n            patternSvg.attributes.x = new Property(document1, \"x\", 0);\n            patternSvg.attributes.y = new Property(document1, \"y\", 0);\n            patternSvg.attributes.width = new Property(document1, \"width\", rootView.width);\n            patternSvg.attributes.height = new Property(document1, \"height\", rootView.height);\n            patternSvg.children = [\n                group\n            ];\n            var patternCanvas = document1.createCanvas(rootView.width, rootView.height);\n            var patternCtx = patternCanvas.getContext(\"2d\");\n            patternCtx.fillStyle = gradient;\n            patternSvg.render(patternCtx);\n            return patternCtx.createPattern(patternCanvas, \"no-repeat\");\n        }\n        return gradient;\n    }\n    inheritStopContainer(stopsContainer) {\n        this.attributesToInherit.forEach((attributeToInherit)=>{\n            if (!this.getAttribute(attributeToInherit).hasValue() && stopsContainer.getAttribute(attributeToInherit).hasValue()) {\n                this.getAttribute(attributeToInherit, true).setValue(stopsContainer.getAttribute(attributeToInherit).getValue());\n            }\n        });\n    }\n    addParentOpacity(parentOpacityProp, color) {\n        if (parentOpacityProp.hasValue()) {\n            var colorProp = new Property(this.document, \"color\", color);\n            return colorProp.addOpacity(parentOpacityProp).getColor();\n        }\n        return color;\n    }\n}\nclass LinearGradientElement extends GradientElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"linearGradient\";\n        this.attributesToInherit.push(\"x1\", \"y1\", \"x2\", \"y2\");\n    }\n    getGradient(ctx, element) {\n        var isBoundingBoxUnits = this.getGradientUnits() === \"objectBoundingBox\";\n        var boundingBox = isBoundingBoxUnits ? element.getBoundingBox(ctx) : null;\n        if (isBoundingBoxUnits && !boundingBox) {\n            return null;\n        }\n        if (!this.getAttribute(\"x1\").hasValue() && !this.getAttribute(\"y1\").hasValue() && !this.getAttribute(\"x2\").hasValue() && !this.getAttribute(\"y2\").hasValue()) {\n            this.getAttribute(\"x1\", true).setValue(0);\n            this.getAttribute(\"y1\", true).setValue(0);\n            this.getAttribute(\"x2\", true).setValue(1);\n            this.getAttribute(\"y2\", true).setValue(0);\n        }\n        var x1 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute(\"x1\").getNumber() : this.getAttribute(\"x1\").getPixels(\"x\");\n        var y1 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute(\"y1\").getNumber() : this.getAttribute(\"y1\").getPixels(\"y\");\n        var x2 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute(\"x2\").getNumber() : this.getAttribute(\"x2\").getPixels(\"x\");\n        var y2 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute(\"y2\").getNumber() : this.getAttribute(\"y2\").getPixels(\"y\");\n        if (x1 === x2 && y1 === y2) {\n            return null;\n        }\n        return ctx.createLinearGradient(x1, y1, x2, y2);\n    }\n}\nclass RadialGradientElement extends GradientElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"radialGradient\";\n        this.attributesToInherit.push(\"cx\", \"cy\", \"r\", \"fx\", \"fy\", \"fr\");\n    }\n    getGradient(ctx, element) {\n        var isBoundingBoxUnits = this.getGradientUnits() === \"objectBoundingBox\";\n        var boundingBox = element.getBoundingBox(ctx);\n        if (isBoundingBoxUnits && !boundingBox) {\n            return null;\n        }\n        if (!this.getAttribute(\"cx\").hasValue()) {\n            this.getAttribute(\"cx\", true).setValue(\"50%\");\n        }\n        if (!this.getAttribute(\"cy\").hasValue()) {\n            this.getAttribute(\"cy\", true).setValue(\"50%\");\n        }\n        if (!this.getAttribute(\"r\").hasValue()) {\n            this.getAttribute(\"r\", true).setValue(\"50%\");\n        }\n        var cx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute(\"cx\").getNumber() : this.getAttribute(\"cx\").getPixels(\"x\");\n        var cy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute(\"cy\").getNumber() : this.getAttribute(\"cy\").getPixels(\"y\");\n        var fx = cx;\n        var fy = cy;\n        if (this.getAttribute(\"fx\").hasValue()) {\n            fx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute(\"fx\").getNumber() : this.getAttribute(\"fx\").getPixels(\"x\");\n        }\n        if (this.getAttribute(\"fy\").hasValue()) {\n            fy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute(\"fy\").getNumber() : this.getAttribute(\"fy\").getPixels(\"y\");\n        }\n        var r = isBoundingBoxUnits ? (boundingBox.width + boundingBox.height) / 2.0 * this.getAttribute(\"r\").getNumber() : this.getAttribute(\"r\").getPixels();\n        var fr = this.getAttribute(\"fr\").getPixels();\n        return ctx.createRadialGradient(fx, fy, fr, cx, cy, r);\n    }\n}\nclass StopElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"stop\";\n        var offset = Math.max(0, Math.min(1, this.getAttribute(\"offset\").getNumber()));\n        var stopOpacity = this.getStyle(\"stop-opacity\");\n        var stopColor = this.getStyle(\"stop-color\", true);\n        if (stopColor.getString() === \"\") {\n            stopColor.setValue(\"#000\");\n        }\n        if (stopOpacity.hasValue()) {\n            stopColor = stopColor.addOpacity(stopOpacity);\n        }\n        this.offset = offset;\n        this.color = stopColor.getColor();\n    }\n}\nclass AnimateElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"animate\";\n        this.duration = 0;\n        this.initialValue = null;\n        this.initialUnits = \"\";\n        this.removed = false;\n        this.frozen = false;\n        document1.screen.animations.push(this);\n        this.begin = this.getAttribute(\"begin\").getMilliseconds();\n        this.maxDuration = this.begin + this.getAttribute(\"dur\").getMilliseconds();\n        this.from = this.getAttribute(\"from\");\n        this.to = this.getAttribute(\"to\");\n        this.values = new Property(document1, \"values\", null);\n        var valuesAttr = this.getAttribute(\"values\");\n        if (valuesAttr.hasValue()) {\n            this.values.setValue(valuesAttr.getString().split(\";\"));\n        }\n    }\n    getProperty() {\n        var attributeType = this.getAttribute(\"attributeType\").getString();\n        var attributeName = this.getAttribute(\"attributeName\").getString();\n        if (attributeType === \"CSS\") {\n            return this.parent.getStyle(attributeName, true);\n        }\n        return this.parent.getAttribute(attributeName, true);\n    }\n    calcValue() {\n        var { initialUnits } = this;\n        var { progress, from, to } = this.getProgress(); // tween value linearly\n        var newValue = from.getNumber() + (to.getNumber() - from.getNumber()) * progress;\n        if (initialUnits === \"%\") {\n            newValue *= 100.0; // numValue() returns 0-1 whereas properties are 0-100\n        }\n        return \"\".concat(newValue).concat(initialUnits);\n    }\n    update(delta) {\n        var { parent } = this;\n        var prop = this.getProperty(); // set initial value\n        if (!this.initialValue) {\n            this.initialValue = prop.getString();\n            this.initialUnits = prop.getUnits();\n        } // if we're past the end time\n        if (this.duration > this.maxDuration) {\n            var fill = this.getAttribute(\"fill\").getString(\"remove\"); // loop for indefinitely repeating animations\n            if (this.getAttribute(\"repeatCount\").getString() === \"indefinite\" || this.getAttribute(\"repeatDur\").getString() === \"indefinite\") {\n                this.duration = 0;\n            } else if (fill === \"freeze\" && !this.frozen) {\n                this.frozen = true;\n                parent.animationFrozen = true;\n                parent.animationFrozenValue = prop.getString();\n            } else if (fill === \"remove\" && !this.removed) {\n                this.removed = true;\n                prop.setValue(parent.animationFrozen ? parent.animationFrozenValue : this.initialValue);\n                return true;\n            }\n            return false;\n        }\n        this.duration += delta; // if we're past the begin time\n        var updated = false;\n        if (this.begin < this.duration) {\n            var newValue = this.calcValue(); // tween\n            var typeAttr = this.getAttribute(\"type\");\n            if (typeAttr.hasValue()) {\n                // for transform, etc.\n                var type = typeAttr.getString();\n                newValue = \"\".concat(type, \"(\").concat(newValue, \")\");\n            }\n            prop.setValue(newValue);\n            updated = true;\n        }\n        return updated;\n    }\n    getProgress() {\n        var { document: document1, values } = this;\n        var result = {\n            progress: (this.duration - this.begin) / (this.maxDuration - this.begin)\n        };\n        if (values.hasValue()) {\n            var p = result.progress * (values.getValue().length - 1);\n            var lb = Math.floor(p);\n            var ub = Math.ceil(p);\n            result.from = new Property(document1, \"from\", parseFloat(values.getValue()[lb]));\n            result.to = new Property(document1, \"to\", parseFloat(values.getValue()[ub]));\n            result.progress = (p - lb) / (ub - lb);\n        } else {\n            result.from = this.from;\n            result.to = this.to;\n        }\n        return result;\n    }\n}\nclass AnimateColorElement extends AnimateElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"animateColor\";\n    }\n    calcValue() {\n        var { progress, from, to } = this.getProgress();\n        var colorFrom = new rgbcolor__WEBPACK_IMPORTED_MODULE_13__(from.getColor());\n        var colorTo = new rgbcolor__WEBPACK_IMPORTED_MODULE_13__(to.getColor());\n        if (colorFrom.ok && colorTo.ok) {\n            // tween color linearly\n            var r = colorFrom.r + (colorTo.r - colorFrom.r) * progress;\n            var g = colorFrom.g + (colorTo.g - colorFrom.g) * progress;\n            var b = colorFrom.b + (colorTo.b - colorFrom.b) * progress; // ? alpha\n            return \"rgb(\".concat(Math.floor(r), \", \").concat(Math.floor(g), \", \").concat(Math.floor(b), \")\");\n        }\n        return this.getAttribute(\"from\").getColor();\n    }\n}\nclass AnimateTransformElement extends AnimateElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"animateTransform\";\n    }\n    calcValue() {\n        var { progress, from, to } = this.getProgress(); // tween value linearly\n        var transformFrom = toNumbers(from.getString());\n        var transformTo = toNumbers(to.getString());\n        var newValue = transformFrom.map((from, i)=>{\n            var to = transformTo[i];\n            return from + (to - from) * progress;\n        }).join(\" \");\n        return newValue;\n    }\n}\nclass FontElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"font\";\n        this.glyphs = Object.create(null);\n        this.horizAdvX = this.getAttribute(\"horiz-adv-x\").getNumber();\n        var { definitions } = document1;\n        var { children } = this;\n        for (var child of children){\n            switch(child.type){\n                case \"font-face\":\n                    {\n                        this.fontFace = child;\n                        var fontFamilyStyle = child.getStyle(\"font-family\");\n                        if (fontFamilyStyle.hasValue()) {\n                            definitions[fontFamilyStyle.getString()] = this;\n                        }\n                        break;\n                    }\n                case \"missing-glyph\":\n                    this.missingGlyph = child;\n                    break;\n                case \"glyph\":\n                    {\n                        var glyph = child;\n                        if (glyph.arabicForm) {\n                            this.isRTL = true;\n                            this.isArabic = true;\n                            if (typeof this.glyphs[glyph.unicode] === \"undefined\") {\n                                this.glyphs[glyph.unicode] = Object.create(null);\n                            }\n                            this.glyphs[glyph.unicode][glyph.arabicForm] = glyph;\n                        } else {\n                            this.glyphs[glyph.unicode] = glyph;\n                        }\n                        break;\n                    }\n            }\n        }\n    }\n    render() {}\n}\nclass FontFaceElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"font-face\";\n        this.ascent = this.getAttribute(\"ascent\").getNumber();\n        this.descent = this.getAttribute(\"descent\").getNumber();\n        this.unitsPerEm = this.getAttribute(\"units-per-em\").getNumber();\n    }\n}\nclass MissingGlyphElement extends PathElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"missing-glyph\";\n        this.horizAdvX = 0;\n    }\n}\nclass TRefElement extends TextElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"tref\";\n    }\n    getText() {\n        var element = this.getHrefAttribute().getDefinition();\n        if (element) {\n            var firstChild = element.children[0];\n            if (firstChild) {\n                return firstChild.getText();\n            }\n        }\n        return \"\";\n    }\n}\nclass AElement extends TextElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"a\";\n        var { childNodes } = node;\n        var firstChild = childNodes[0];\n        var hasText = childNodes.length > 0 && Array.from(childNodes).every((node)=>node.nodeType === 3);\n        this.hasText = hasText;\n        this.text = hasText ? this.getTextFromNode(firstChild) : \"\";\n    }\n    getText() {\n        return this.text;\n    }\n    renderChildren(ctx) {\n        if (this.hasText) {\n            // render as text element\n            super.renderChildren(ctx);\n            var { document: document1, x, y } = this;\n            var { mouse } = document1.screen;\n            var fontSize = new Property(document1, \"fontSize\", Font.parse(document1.ctx.font).fontSize); // Do not calc bounding box if mouse is not working.\n            if (mouse.isWorking()) {\n                mouse.checkBoundingBox(this, new BoundingBox(x, y - fontSize.getPixels(\"y\"), x + this.measureText(ctx), y));\n            }\n        } else if (this.children.length > 0) {\n            // render as temporary group\n            var g = new GElement(this.document, null);\n            g.children = this.children;\n            g.parent = this;\n            g.render(ctx);\n        }\n    }\n    onClick() {\n        var { window: window1 } = this.document;\n        if (window1) {\n            window1.open(this.getHrefAttribute().getString());\n        }\n    }\n    onMouseMove() {\n        var ctx = this.document.ctx;\n        ctx.canvas.style.cursor = \"pointer\";\n    }\n}\nfunction ownKeys$2(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$2(Object(source), true).forEach(function(key) {\n                _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$2(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nclass TextPathElement extends TextElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"textPath\";\n        this.textWidth = 0;\n        this.textHeight = 0;\n        this.pathLength = -1;\n        this.glyphInfo = null;\n        this.letterSpacingCache = [];\n        this.measuresCache = new Map([\n            [\n                \"\",\n                0\n            ]\n        ]);\n        var pathElement = this.getHrefAttribute().getDefinition();\n        this.text = this.getTextFromNode();\n        this.dataArray = this.parsePathData(pathElement);\n    }\n    getText() {\n        return this.text;\n    }\n    path(ctx) {\n        var { dataArray } = this;\n        if (ctx) {\n            ctx.beginPath();\n        }\n        dataArray.forEach((_ref)=>{\n            var { type, points } = _ref;\n            switch(type){\n                case PathParser.LINE_TO:\n                    if (ctx) {\n                        ctx.lineTo(points[0], points[1]);\n                    }\n                    break;\n                case PathParser.MOVE_TO:\n                    if (ctx) {\n                        ctx.moveTo(points[0], points[1]);\n                    }\n                    break;\n                case PathParser.CURVE_TO:\n                    if (ctx) {\n                        ctx.bezierCurveTo(points[0], points[1], points[2], points[3], points[4], points[5]);\n                    }\n                    break;\n                case PathParser.QUAD_TO:\n                    if (ctx) {\n                        ctx.quadraticCurveTo(points[0], points[1], points[2], points[3]);\n                    }\n                    break;\n                case PathParser.ARC:\n                    {\n                        var [cx, cy, rx, ry, theta, dTheta, psi, fs] = points;\n                        var r = rx > ry ? rx : ry;\n                        var scaleX = rx > ry ? 1 : rx / ry;\n                        var scaleY = rx > ry ? ry / rx : 1;\n                        if (ctx) {\n                            ctx.translate(cx, cy);\n                            ctx.rotate(psi);\n                            ctx.scale(scaleX, scaleY);\n                            ctx.arc(0, 0, r, theta, theta + dTheta, Boolean(1 - fs));\n                            ctx.scale(1 / scaleX, 1 / scaleY);\n                            ctx.rotate(-psi);\n                            ctx.translate(-cx, -cy);\n                        }\n                        break;\n                    }\n                case PathParser.CLOSE_PATH:\n                    if (ctx) {\n                        ctx.closePath();\n                    }\n                    break;\n            }\n        });\n    }\n    renderChildren(ctx) {\n        this.setTextData(ctx);\n        ctx.save();\n        var textDecoration = this.parent.getStyle(\"text-decoration\").getString();\n        var fontSize = this.getFontSize();\n        var { glyphInfo } = this;\n        var fill = ctx.fillStyle;\n        if (textDecoration === \"underline\") {\n            ctx.beginPath();\n        }\n        glyphInfo.forEach((glyph, i)=>{\n            var { p0, p1, rotation, text: partialText } = glyph;\n            ctx.save();\n            ctx.translate(p0.x, p0.y);\n            ctx.rotate(rotation);\n            if (ctx.fillStyle) {\n                ctx.fillText(partialText, 0, 0);\n            }\n            if (ctx.strokeStyle) {\n                ctx.strokeText(partialText, 0, 0);\n            }\n            ctx.restore();\n            if (textDecoration === \"underline\") {\n                if (i === 0) {\n                    ctx.moveTo(p0.x, p0.y + fontSize / 8);\n                }\n                ctx.lineTo(p1.x, p1.y + fontSize / 5);\n            } // // To assist with debugging visually, uncomment following\n        //\n        // ctx.beginPath();\n        // if (i % 2)\n        // \tctx.strokeStyle = 'red';\n        // else\n        // \tctx.strokeStyle = 'green';\n        // ctx.moveTo(p0.x, p0.y);\n        // ctx.lineTo(p1.x, p1.y);\n        // ctx.stroke();\n        // ctx.closePath();\n        });\n        if (textDecoration === \"underline\") {\n            ctx.lineWidth = fontSize / 20;\n            ctx.strokeStyle = fill;\n            ctx.stroke();\n            ctx.closePath();\n        }\n        ctx.restore();\n    }\n    getLetterSpacingAt() {\n        var idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        return this.letterSpacingCache[idx] || 0;\n    }\n    findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, inputOffset, dy, c, charI) {\n        var offset = inputOffset;\n        var glyphWidth = this.measureText(ctx, c);\n        if (c === \" \" && anchor === \"justify\" && textFullWidth < fullPathWidth) {\n            glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\n        }\n        if (charI > -1) {\n            offset += this.getLetterSpacingAt(charI);\n        }\n        var splineStep = this.textHeight / 20;\n        var p0 = this.getEquidistantPointOnPath(offset, splineStep, 0);\n        var p1 = this.getEquidistantPointOnPath(offset + glyphWidth, splineStep, 0);\n        var segment = {\n            p0,\n            p1\n        };\n        var rotation = p0 && p1 ? Math.atan2(p1.y - p0.y, p1.x - p0.x) : 0;\n        if (dy) {\n            var dyX = Math.cos(Math.PI / 2 + rotation) * dy;\n            var dyY = Math.cos(-rotation) * dy;\n            segment.p0 = _objectSpread$2(_objectSpread$2({}, p0), {}, {\n                x: p0.x + dyX,\n                y: p0.y + dyY\n            });\n            segment.p1 = _objectSpread$2(_objectSpread$2({}, p1), {}, {\n                x: p1.x + dyX,\n                y: p1.y + dyY\n            });\n        }\n        offset += glyphWidth;\n        return {\n            offset,\n            segment,\n            rotation\n        };\n    }\n    measureText(ctx, text) {\n        var { measuresCache } = this;\n        var targetText = text || this.getText();\n        if (measuresCache.has(targetText)) {\n            return measuresCache.get(targetText);\n        }\n        var measure = this.measureTargetText(ctx, targetText);\n        measuresCache.set(targetText, measure);\n        return measure;\n    }\n    // If some font will be loaded after this method call, <textPath> will not be rendered correctly.\n    // You need to call this method manually to update glyphs cache.\n    setTextData(ctx) {\n        if (this.glyphInfo) {\n            return;\n        }\n        var renderText = this.getText();\n        var chars = renderText.split(\"\");\n        var spacesNumber = renderText.split(\" \").length - 1;\n        var dx = this.parent.getAttribute(\"dx\").split().map((_)=>_.getPixels(\"x\"));\n        var dy = this.parent.getAttribute(\"dy\").getPixels(\"y\");\n        var anchor = this.parent.getStyle(\"text-anchor\").getString(\"start\");\n        var thisSpacing = this.getStyle(\"letter-spacing\");\n        var parentSpacing = this.parent.getStyle(\"letter-spacing\");\n        var letterSpacing = 0;\n        if (!thisSpacing.hasValue() || thisSpacing.getValue() === \"inherit\") {\n            letterSpacing = parentSpacing.getPixels();\n        } else if (thisSpacing.hasValue()) {\n            if (thisSpacing.getValue() !== \"initial\" && thisSpacing.getValue() !== \"unset\") {\n                letterSpacing = thisSpacing.getPixels();\n            }\n        } // fill letter-spacing cache\n        var letterSpacingCache = [];\n        var textLen = renderText.length;\n        this.letterSpacingCache = letterSpacingCache;\n        for(var i = 0; i < textLen; i++){\n            letterSpacingCache.push(typeof dx[i] !== \"undefined\" ? dx[i] : letterSpacing);\n        }\n        var dxSum = letterSpacingCache.reduce((acc, cur, i)=>i === 0 ? 0 : acc + cur || 0, 0);\n        var textWidth = this.measureText(ctx);\n        var textFullWidth = Math.max(textWidth + dxSum, 0);\n        this.textWidth = textWidth;\n        this.textHeight = this.getFontSize();\n        this.glyphInfo = [];\n        var fullPathWidth = this.getPathLength();\n        var startOffset = this.getStyle(\"startOffset\").getNumber(0) * fullPathWidth;\n        var offset = 0;\n        if (anchor === \"middle\" || anchor === \"center\") {\n            offset = -textFullWidth / 2;\n        }\n        if (anchor === \"end\" || anchor === \"right\") {\n            offset = -textFullWidth;\n        }\n        offset += startOffset;\n        chars.forEach((char, i)=>{\n            // Find such segment what distance between p0 and p1 is approx. width of glyph\n            var { offset: nextOffset, segment, rotation } = this.findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, offset, dy, char, i);\n            offset = nextOffset;\n            if (!segment.p0 || !segment.p1) {\n                return;\n            } // const width = this.getLineLength(\n            // \tsegment.p0.x,\n            // \tsegment.p0.y,\n            // \tsegment.p1.x,\n            // \tsegment.p1.y\n            // );\n            // Note: Since glyphs are rendered one at a time, any kerning pair data built into the font will not be used.\n            // Can foresee having a rough pair table built in that the developer can override as needed.\n            // Or use \"dx\" attribute of the <text> node as a naive replacement\n            // const kern = 0;\n            // placeholder for future implementation\n            // const midpoint = this.getPointOnLine(\n            // \tkern + width / 2.0,\n            // \tsegment.p0.x, segment.p0.y, segment.p1.x, segment.p1.y\n            // );\n            this.glyphInfo.push({\n                // transposeX: midpoint.x,\n                // transposeY: midpoint.y,\n                text: chars[i],\n                p0: segment.p0,\n                p1: segment.p1,\n                rotation\n            });\n        });\n    }\n    parsePathData(path) {\n        this.pathLength = -1; // reset path length\n        if (!path) {\n            return [];\n        }\n        var pathCommands = [];\n        var { pathParser } = path;\n        pathParser.reset(); // convert l, H, h, V, and v to L\n        while(!pathParser.isEnd()){\n            var { current } = pathParser;\n            var startX = current ? current.x : 0;\n            var startY = current ? current.y : 0;\n            var command = pathParser.next();\n            var nextCommandType = command.type;\n            var points = [];\n            switch(command.type){\n                case PathParser.MOVE_TO:\n                    this.pathM(pathParser, points);\n                    break;\n                case PathParser.LINE_TO:\n                    nextCommandType = this.pathL(pathParser, points);\n                    break;\n                case PathParser.HORIZ_LINE_TO:\n                    nextCommandType = this.pathH(pathParser, points);\n                    break;\n                case PathParser.VERT_LINE_TO:\n                    nextCommandType = this.pathV(pathParser, points);\n                    break;\n                case PathParser.CURVE_TO:\n                    this.pathC(pathParser, points);\n                    break;\n                case PathParser.SMOOTH_CURVE_TO:\n                    nextCommandType = this.pathS(pathParser, points);\n                    break;\n                case PathParser.QUAD_TO:\n                    this.pathQ(pathParser, points);\n                    break;\n                case PathParser.SMOOTH_QUAD_TO:\n                    nextCommandType = this.pathT(pathParser, points);\n                    break;\n                case PathParser.ARC:\n                    points = this.pathA(pathParser);\n                    break;\n                case PathParser.CLOSE_PATH:\n                    PathElement.pathZ(pathParser);\n                    break;\n            }\n            if (command.type !== PathParser.CLOSE_PATH) {\n                pathCommands.push({\n                    type: nextCommandType,\n                    points,\n                    start: {\n                        x: startX,\n                        y: startY\n                    },\n                    pathLength: this.calcLength(startX, startY, nextCommandType, points)\n                });\n            } else {\n                pathCommands.push({\n                    type: PathParser.CLOSE_PATH,\n                    points: [],\n                    pathLength: 0\n                });\n            }\n        }\n        return pathCommands;\n    }\n    pathM(pathParser, points) {\n        var { x, y } = PathElement.pathM(pathParser).point;\n        points.push(x, y);\n    }\n    pathL(pathParser, points) {\n        var { x, y } = PathElement.pathL(pathParser).point;\n        points.push(x, y);\n        return PathParser.LINE_TO;\n    }\n    pathH(pathParser, points) {\n        var { x, y } = PathElement.pathH(pathParser).point;\n        points.push(x, y);\n        return PathParser.LINE_TO;\n    }\n    pathV(pathParser, points) {\n        var { x, y } = PathElement.pathV(pathParser).point;\n        points.push(x, y);\n        return PathParser.LINE_TO;\n    }\n    pathC(pathParser, points) {\n        var { point, controlPoint, currentPoint } = PathElement.pathC(pathParser);\n        points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n    }\n    pathS(pathParser, points) {\n        var { point, controlPoint, currentPoint } = PathElement.pathS(pathParser);\n        points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        return PathParser.CURVE_TO;\n    }\n    pathQ(pathParser, points) {\n        var { controlPoint, currentPoint } = PathElement.pathQ(pathParser);\n        points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n    }\n    pathT(pathParser, points) {\n        var { controlPoint, currentPoint } = PathElement.pathT(pathParser);\n        points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        return PathParser.QUAD_TO;\n    }\n    pathA(pathParser) {\n        var { rX, rY, sweepFlag, xAxisRotation, centp, a1, ad } = PathElement.pathA(pathParser);\n        if (sweepFlag === 0 && ad > 0) {\n            ad -= 2 * Math.PI;\n        }\n        if (sweepFlag === 1 && ad < 0) {\n            ad += 2 * Math.PI;\n        }\n        return [\n            centp.x,\n            centp.y,\n            rX,\n            rY,\n            a1,\n            ad,\n            xAxisRotation,\n            sweepFlag\n        ];\n    }\n    calcLength(x, y, commandType, points) {\n        var len = 0;\n        var p1 = null;\n        var p2 = null;\n        var t = 0;\n        switch(commandType){\n            case PathParser.LINE_TO:\n                return this.getLineLength(x, y, points[0], points[1]);\n            case PathParser.CURVE_TO:\n                // Approximates by breaking curve into 100 line segments\n                len = 0.0;\n                p1 = this.getPointOnCubicBezier(0, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);\n                for(t = 0.01; t <= 1; t += 0.01){\n                    p2 = this.getPointOnCubicBezier(t, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);\n                    len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                    p1 = p2;\n                }\n                return len;\n            case PathParser.QUAD_TO:\n                // Approximates by breaking curve into 100 line segments\n                len = 0.0;\n                p1 = this.getPointOnQuadraticBezier(0, x, y, points[0], points[1], points[2], points[3]);\n                for(t = 0.01; t <= 1; t += 0.01){\n                    p2 = this.getPointOnQuadraticBezier(t, x, y, points[0], points[1], points[2], points[3]);\n                    len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                    p1 = p2;\n                }\n                return len;\n            case PathParser.ARC:\n                {\n                    // Approximates by breaking curve into line segments\n                    len = 0.0;\n                    var start = points[4]; // 4 = theta\n                    var dTheta = points[5]; // 5 = dTheta\n                    var end = points[4] + dTheta;\n                    var inc = Math.PI / 180.0; // 1 degree resolution\n                    if (Math.abs(start - end) < inc) {\n                        inc = Math.abs(start - end);\n                    } // Note: for purpose of calculating arc length, not going to worry about rotating X-axis by angle psi\n                    p1 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);\n                    if (dTheta < 0) {\n                        // clockwise\n                        for(t = start - inc; t > end; t -= inc){\n                            p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);\n                            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                            p1 = p2;\n                        }\n                    } else {\n                        // counter-clockwise\n                        for(t = start + inc; t < end; t += inc){\n                            p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);\n                            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                            p1 = p2;\n                        }\n                    }\n                    p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);\n                    len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                    return len;\n                }\n        }\n        return 0;\n    }\n    getPointOnLine(dist, p1x, p1y, p2x, p2y) {\n        var fromX = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : p1x;\n        var fromY = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : p1y;\n        var m = (p2y - p1y) / (p2x - p1x + PSEUDO_ZERO);\n        var run = Math.sqrt(dist * dist / (1 + m * m));\n        if (p2x < p1x) {\n            run *= -1;\n        }\n        var rise = m * run;\n        var pt = null;\n        if (p2x === p1x) {\n            // vertical line\n            pt = {\n                x: fromX,\n                y: fromY + rise\n            };\n        } else if ((fromY - p1y) / (fromX - p1x + PSEUDO_ZERO) === m) {\n            pt = {\n                x: fromX + run,\n                y: fromY + rise\n            };\n        } else {\n            var ix = 0;\n            var iy = 0;\n            var len = this.getLineLength(p1x, p1y, p2x, p2y);\n            if (len < PSEUDO_ZERO) {\n                return null;\n            }\n            var u = (fromX - p1x) * (p2x - p1x) + (fromY - p1y) * (p2y - p1y);\n            u /= len * len;\n            ix = p1x + u * (p2x - p1x);\n            iy = p1y + u * (p2y - p1y);\n            var pRise = this.getLineLength(fromX, fromY, ix, iy);\n            var pRun = Math.sqrt(dist * dist - pRise * pRise);\n            run = Math.sqrt(pRun * pRun / (1 + m * m));\n            if (p2x < p1x) {\n                run *= -1;\n            }\n            rise = m * run;\n            pt = {\n                x: ix + run,\n                y: iy + rise\n            };\n        }\n        return pt;\n    }\n    getPointOnPath(distance) {\n        var fullLen = this.getPathLength();\n        var cumulativePathLength = 0;\n        var p = null;\n        if (distance < -0.00005 || distance - 0.00005 > fullLen) {\n            return null;\n        }\n        var { dataArray } = this;\n        for (var command of dataArray){\n            if (command && (command.pathLength < 0.00005 || cumulativePathLength + command.pathLength + 0.00005 < distance)) {\n                cumulativePathLength += command.pathLength;\n                continue;\n            }\n            var delta = distance - cumulativePathLength;\n            var currentT = 0;\n            switch(command.type){\n                case PathParser.LINE_TO:\n                    p = this.getPointOnLine(delta, command.start.x, command.start.y, command.points[0], command.points[1], command.start.x, command.start.y);\n                    break;\n                case PathParser.ARC:\n                    {\n                        var start = command.points[4]; // 4 = theta\n                        var dTheta = command.points[5]; // 5 = dTheta\n                        var end = command.points[4] + dTheta;\n                        currentT = start + delta / command.pathLength * dTheta;\n                        if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {\n                            break;\n                        }\n                        p = this.getPointOnEllipticalArc(command.points[0], command.points[1], command.points[2], command.points[3], currentT, command.points[6]);\n                        break;\n                    }\n                case PathParser.CURVE_TO:\n                    currentT = delta / command.pathLength;\n                    if (currentT > 1) {\n                        currentT = 1;\n                    }\n                    p = this.getPointOnCubicBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3], command.points[4], command.points[5]);\n                    break;\n                case PathParser.QUAD_TO:\n                    currentT = delta / command.pathLength;\n                    if (currentT > 1) {\n                        currentT = 1;\n                    }\n                    p = this.getPointOnQuadraticBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3]);\n                    break;\n            }\n            if (p) {\n                return p;\n            }\n            break;\n        }\n        return null;\n    }\n    getLineLength(x1, y1, x2, y2) {\n        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    }\n    getPathLength() {\n        if (this.pathLength === -1) {\n            this.pathLength = this.dataArray.reduce((length, command)=>command.pathLength > 0 ? length + command.pathLength : length, 0);\n        }\n        return this.pathLength;\n    }\n    getPointOnCubicBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {\n        var x = p4x * CB1(pct) + p3x * CB2(pct) + p2x * CB3(pct) + p1x * CB4(pct);\n        var y = p4y * CB1(pct) + p3y * CB2(pct) + p2y * CB3(pct) + p1y * CB4(pct);\n        return {\n            x,\n            y\n        };\n    }\n    getPointOnQuadraticBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y) {\n        var x = p3x * QB1(pct) + p2x * QB2(pct) + p1x * QB3(pct);\n        var y = p3y * QB1(pct) + p2y * QB2(pct) + p1y * QB3(pct);\n        return {\n            x,\n            y\n        };\n    }\n    getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi) {\n        var cosPsi = Math.cos(psi);\n        var sinPsi = Math.sin(psi);\n        var pt = {\n            x: rx * Math.cos(theta),\n            y: ry * Math.sin(theta)\n        };\n        return {\n            x: cx + (pt.x * cosPsi - pt.y * sinPsi),\n            y: cy + (pt.x * sinPsi + pt.y * cosPsi)\n        };\n    }\n    buildEquidistantCache(inputStep, inputPrecision) {\n        var fullLen = this.getPathLength();\n        var precision = inputPrecision || 0.25; // accuracy vs performance\n        var step = inputStep || fullLen / 100;\n        if (!this.equidistantCache || this.equidistantCache.step !== step || this.equidistantCache.precision !== precision) {\n            // Prepare cache\n            this.equidistantCache = {\n                step,\n                precision,\n                points: []\n            }; // Calculate points\n            var s = 0;\n            for(var l = 0; l <= fullLen; l += precision){\n                var p0 = this.getPointOnPath(l);\n                var p1 = this.getPointOnPath(l + precision);\n                if (!p0 || !p1) {\n                    continue;\n                }\n                s += this.getLineLength(p0.x, p0.y, p1.x, p1.y);\n                if (s >= step) {\n                    this.equidistantCache.points.push({\n                        x: p0.x,\n                        y: p0.y,\n                        distance: l\n                    });\n                    s -= step;\n                }\n            }\n        }\n    }\n    getEquidistantPointOnPath(targetDistance, step, precision) {\n        this.buildEquidistantCache(step, precision);\n        if (targetDistance < 0 || targetDistance - this.getPathLength() > 0.00005) {\n            return null;\n        }\n        var idx = Math.round(targetDistance / this.getPathLength() * (this.equidistantCache.points.length - 1));\n        return this.equidistantCache.points[idx] || null;\n    }\n}\nvar dataUriRegex = /^\\s*data:(([^/,;]+\\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,(.*)$/i;\nclass ImageElement extends RenderedElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"image\";\n        this.loaded = false;\n        var href = this.getHrefAttribute().getString();\n        if (!href) {\n            return;\n        }\n        var isSvg = href.endsWith(\".svg\") || /^\\s*data:image\\/svg\\+xml/i.test(href);\n        document1.images.push(this);\n        if (!isSvg) {\n            void this.loadImage(href);\n        } else {\n            void this.loadSvg(href);\n        }\n        this.isSvg = isSvg;\n    }\n    loadImage(href) {\n        var _this = this;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            try {\n                var image = yield _this.document.createImage(href);\n                _this.image = image;\n            } catch (err) {\n                console.error('Error while loading image \"'.concat(href, '\":'), err);\n            }\n            _this.loaded = true;\n        })();\n    }\n    loadSvg(href) {\n        var _this2 = this;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            var match = dataUriRegex.exec(href);\n            if (match) {\n                var data = match[5];\n                if (match[4] === \"base64\") {\n                    _this2.image = atob(data);\n                } else {\n                    _this2.image = decodeURIComponent(data);\n                }\n            } else {\n                try {\n                    var response = yield _this2.document.fetch(href);\n                    var svg = yield response.text();\n                    _this2.image = svg;\n                } catch (err) {\n                    console.error('Error while loading image \"'.concat(href, '\":'), err);\n                }\n            }\n            _this2.loaded = true;\n        })();\n    }\n    renderChildren(ctx) {\n        var { document: document1, image, loaded } = this;\n        var x = this.getAttribute(\"x\").getPixels(\"x\");\n        var y = this.getAttribute(\"y\").getPixels(\"y\");\n        var width = this.getStyle(\"width\").getPixels(\"x\");\n        var height = this.getStyle(\"height\").getPixels(\"y\");\n        if (!loaded || !image || !width || !height) {\n            return;\n        }\n        ctx.save();\n        ctx.translate(x, y);\n        if (this.isSvg) {\n            var subDocument = document1.canvg.forkString(ctx, this.image, {\n                ignoreMouse: true,\n                ignoreAnimation: true,\n                ignoreDimensions: true,\n                ignoreClear: true,\n                offsetX: 0,\n                offsetY: 0,\n                scaleWidth: width,\n                scaleHeight: height\n            });\n            subDocument.document.documentElement.parent = this;\n            void subDocument.render();\n        } else {\n            var _image = this.image;\n            document1.setViewBox({\n                ctx,\n                aspectRatio: this.getAttribute(\"preserveAspectRatio\").getString(),\n                width,\n                desiredWidth: _image.width,\n                height,\n                desiredHeight: _image.height\n            });\n            if (this.loaded) {\n                if (typeof _image.complete === \"undefined\" || _image.complete) {\n                    ctx.drawImage(_image, 0, 0);\n                }\n            }\n        }\n        ctx.restore();\n    }\n    getBoundingBox() {\n        var x = this.getAttribute(\"x\").getPixels(\"x\");\n        var y = this.getAttribute(\"y\").getPixels(\"y\");\n        var width = this.getStyle(\"width\").getPixels(\"x\");\n        var height = this.getStyle(\"height\").getPixels(\"y\");\n        return new BoundingBox(x, y, x + width, y + height);\n    }\n}\nclass SymbolElement extends RenderedElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"symbol\";\n    }\n    render(_) {}\n}\nclass SVGFontLoader {\n    constructor(document1){\n        this.document = document1;\n        this.loaded = false;\n        document1.fonts.push(this);\n    }\n    load(fontFamily, url) {\n        var _this = this;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            try {\n                var { document: document1 } = _this;\n                var svgDocument = yield document1.canvg.parser.load(url);\n                var fonts = svgDocument.getElementsByTagName(\"font\");\n                Array.from(fonts).forEach((fontNode)=>{\n                    var font = document1.createElement(fontNode);\n                    document1.definitions[fontFamily] = font;\n                });\n            } catch (err) {\n                console.error('Error while loading font \"'.concat(url, '\":'), err);\n            }\n            _this.loaded = true;\n        })();\n    }\n}\nclass StyleElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"style\";\n        var css = compressSpaces(Array.from(node.childNodes) // NEED TEST\n        .map((_)=>_.textContent).join(\"\").replace(/(\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*+\\/)|(^[\\s]*\\/\\/.*)/gm, \"\") // remove comments\n        .replace(/@import.*;/g, \"\") // remove imports\n        );\n        var cssDefs = css.split(\"}\");\n        cssDefs.forEach((_)=>{\n            var def = _.trim();\n            if (!def) {\n                return;\n            }\n            var cssParts = def.split(\"{\");\n            var cssClasses = cssParts[0].split(\",\");\n            var cssProps = cssParts[1].split(\";\");\n            cssClasses.forEach((_)=>{\n                var cssClass = _.trim();\n                if (!cssClass) {\n                    return;\n                }\n                var props = document1.styles[cssClass] || {};\n                cssProps.forEach((cssProp)=>{\n                    var prop = cssProp.indexOf(\":\");\n                    var name = cssProp.substr(0, prop).trim();\n                    var value = cssProp.substr(prop + 1, cssProp.length - prop).trim();\n                    if (name && value) {\n                        props[name] = new Property(document1, name, value);\n                    }\n                });\n                document1.styles[cssClass] = props;\n                document1.stylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);\n                if (cssClass === \"@font-face\") {\n                    //  && !nodeEnv\n                    var fontFamily = props[\"font-family\"].getString().replace(/\"|'/g, \"\");\n                    var srcs = props.src.getString().split(\",\");\n                    srcs.forEach((src)=>{\n                        if (src.indexOf('format(\"svg\")') > 0) {\n                            var url = parseExternalUrl(src);\n                            if (url) {\n                                void new SVGFontLoader(document1).load(fontFamily, url);\n                            }\n                        }\n                    });\n                }\n            });\n        });\n    }\n}\nStyleElement.parseExternalUrl = parseExternalUrl;\nclass UseElement extends RenderedElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"use\";\n    }\n    setContext(ctx) {\n        super.setContext(ctx);\n        var xAttr = this.getAttribute(\"x\");\n        var yAttr = this.getAttribute(\"y\");\n        if (xAttr.hasValue()) {\n            ctx.translate(xAttr.getPixels(\"x\"), 0);\n        }\n        if (yAttr.hasValue()) {\n            ctx.translate(0, yAttr.getPixels(\"y\"));\n        }\n    }\n    path(ctx) {\n        var { element } = this;\n        if (element) {\n            element.path(ctx);\n        }\n    }\n    renderChildren(ctx) {\n        var { document: document1, element } = this;\n        if (element) {\n            var tempSvg = element;\n            if (element.type === \"symbol\") {\n                // render me using a temporary svg element in symbol cases (http://www.w3.org/TR/SVG/struct.html#UseElement)\n                tempSvg = new SVGElement(document1, null);\n                tempSvg.attributes.viewBox = new Property(document1, \"viewBox\", element.getAttribute(\"viewBox\").getString());\n                tempSvg.attributes.preserveAspectRatio = new Property(document1, \"preserveAspectRatio\", element.getAttribute(\"preserveAspectRatio\").getString());\n                tempSvg.attributes.overflow = new Property(document1, \"overflow\", element.getAttribute(\"overflow\").getString());\n                tempSvg.children = element.children; // element is still the parent of the children\n                element.styles.opacity = new Property(document1, \"opacity\", this.calculateOpacity());\n            }\n            if (tempSvg.type === \"svg\") {\n                var widthStyle = this.getStyle(\"width\", false, true);\n                var heightStyle = this.getStyle(\"height\", false, true); // if symbol or svg, inherit width/height from me\n                if (widthStyle.hasValue()) {\n                    tempSvg.attributes.width = new Property(document1, \"width\", widthStyle.getString());\n                }\n                if (heightStyle.hasValue()) {\n                    tempSvg.attributes.height = new Property(document1, \"height\", heightStyle.getString());\n                }\n            }\n            var oldParent = tempSvg.parent;\n            tempSvg.parent = this;\n            tempSvg.render(ctx);\n            tempSvg.parent = oldParent;\n        }\n    }\n    getBoundingBox(ctx) {\n        var { element } = this;\n        if (element) {\n            return element.getBoundingBox(ctx);\n        }\n        return null;\n    }\n    elementTransform() {\n        var { document: document1, element } = this;\n        return Transform.fromElement(document1, element);\n    }\n    get element() {\n        if (!this.cachedElement) {\n            this.cachedElement = this.getHrefAttribute().getDefinition();\n        }\n        return this.cachedElement;\n    }\n}\nfunction imGet(img, x, y, width, _height, rgba) {\n    return img[y * width * 4 + x * 4 + rgba];\n}\nfunction imSet(img, x, y, width, _height, rgba, val) {\n    img[y * width * 4 + x * 4 + rgba] = val;\n}\nfunction m(matrix, i, v) {\n    var mi = matrix[i];\n    return mi * v;\n}\nfunction c(a, m1, m2, m3) {\n    return m1 + Math.cos(a) * m2 + Math.sin(a) * m3;\n}\nclass FeColorMatrixElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"feColorMatrix\";\n        var matrix = toNumbers(this.getAttribute(\"values\").getString());\n        switch(this.getAttribute(\"type\").getString(\"matrix\")){\n            // http://www.w3.org/TR/SVG/filters.html#feColorMatrixElement\n            case \"saturate\":\n                {\n                    var s = matrix[0];\n                    /* eslint-disable array-element-newline */ matrix = [\n                        0.213 + 0.787 * s,\n                        0.715 - 0.715 * s,\n                        0.072 - 0.072 * s,\n                        0,\n                        0,\n                        0.213 - 0.213 * s,\n                        0.715 + 0.285 * s,\n                        0.072 - 0.072 * s,\n                        0,\n                        0,\n                        0.213 - 0.213 * s,\n                        0.715 - 0.715 * s,\n                        0.072 + 0.928 * s,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1\n                    ];\n                    break;\n                }\n            case \"hueRotate\":\n                {\n                    var a = matrix[0] * Math.PI / 180.0;\n                    /* eslint-disable array-element-newline */ matrix = [\n                        c(a, 0.213, 0.787, -0.213),\n                        c(a, 0.715, -0.715, -0.715),\n                        c(a, 0.072, -0.072, 0.928),\n                        0,\n                        0,\n                        c(a, 0.213, -0.213, 0.143),\n                        c(a, 0.715, 0.285, 0.140),\n                        c(a, 0.072, -0.072, -0.283),\n                        0,\n                        0,\n                        c(a, 0.213, -0.213, -0.787),\n                        c(a, 0.715, -0.715, 0.715),\n                        c(a, 0.072, 0.928, 0.072),\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1\n                    ];\n                    break;\n                }\n            case \"luminanceToAlpha\":\n                /* eslint-disable array-element-newline */ matrix = [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0.2125,\n                    0.7154,\n                    0.0721,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    1\n                ];\n                break;\n        }\n        this.matrix = matrix;\n        this.includeOpacity = this.getAttribute(\"includeOpacity\").hasValue();\n    }\n    apply(ctx, _x, _y, width, height) {\n        // assuming x==0 && y==0 for now\n        var { includeOpacity, matrix } = this;\n        var srcData = ctx.getImageData(0, 0, width, height);\n        for(var y = 0; y < height; y++){\n            for(var x = 0; x < width; x++){\n                var r = imGet(srcData.data, x, y, width, height, 0);\n                var g = imGet(srcData.data, x, y, width, height, 1);\n                var b = imGet(srcData.data, x, y, width, height, 2);\n                var a = imGet(srcData.data, x, y, width, height, 3);\n                var nr = m(matrix, 0, r) + m(matrix, 1, g) + m(matrix, 2, b) + m(matrix, 3, a) + m(matrix, 4, 1);\n                var ng = m(matrix, 5, r) + m(matrix, 6, g) + m(matrix, 7, b) + m(matrix, 8, a) + m(matrix, 9, 1);\n                var nb = m(matrix, 10, r) + m(matrix, 11, g) + m(matrix, 12, b) + m(matrix, 13, a) + m(matrix, 14, 1);\n                var na = m(matrix, 15, r) + m(matrix, 16, g) + m(matrix, 17, b) + m(matrix, 18, a) + m(matrix, 19, 1);\n                if (includeOpacity) {\n                    nr = 0;\n                    ng = 0;\n                    nb = 0;\n                    na *= a / 255;\n                }\n                imSet(srcData.data, x, y, width, height, 0, nr);\n                imSet(srcData.data, x, y, width, height, 1, ng);\n                imSet(srcData.data, x, y, width, height, 2, nb);\n                imSet(srcData.data, x, y, width, height, 3, na);\n            }\n        }\n        ctx.clearRect(0, 0, width, height);\n        ctx.putImageData(srcData, 0, 0);\n    }\n}\nclass MaskElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"mask\";\n    }\n    apply(ctx, element) {\n        var { document: document1 } = this; // render as temp svg\n        var x = this.getAttribute(\"x\").getPixels(\"x\");\n        var y = this.getAttribute(\"y\").getPixels(\"y\");\n        var width = this.getStyle(\"width\").getPixels(\"x\");\n        var height = this.getStyle(\"height\").getPixels(\"y\");\n        if (!width && !height) {\n            var boundingBox = new BoundingBox();\n            this.children.forEach((child)=>{\n                boundingBox.addBoundingBox(child.getBoundingBox(ctx));\n            });\n            x = Math.floor(boundingBox.x1);\n            y = Math.floor(boundingBox.y1);\n            width = Math.floor(boundingBox.width);\n            height = Math.floor(boundingBox.height);\n        }\n        var ignoredStyles = this.removeStyles(element, MaskElement.ignoreStyles);\n        var maskCanvas = document1.createCanvas(x + width, y + height);\n        var maskCtx = maskCanvas.getContext(\"2d\");\n        document1.screen.setDefaults(maskCtx);\n        this.renderChildren(maskCtx); // convert mask to alpha with a fake node\n        // TODO: refactor out apply from feColorMatrix\n        new FeColorMatrixElement(document1, {\n            nodeType: 1,\n            childNodes: [],\n            attributes: [\n                {\n                    nodeName: \"type\",\n                    value: \"luminanceToAlpha\"\n                },\n                {\n                    nodeName: \"includeOpacity\",\n                    value: \"true\"\n                }\n            ]\n        }).apply(maskCtx, 0, 0, x + width, y + height);\n        var tmpCanvas = document1.createCanvas(x + width, y + height);\n        var tmpCtx = tmpCanvas.getContext(\"2d\");\n        document1.screen.setDefaults(tmpCtx);\n        element.render(tmpCtx);\n        tmpCtx.globalCompositeOperation = \"destination-in\";\n        tmpCtx.fillStyle = maskCtx.createPattern(maskCanvas, \"no-repeat\");\n        tmpCtx.fillRect(0, 0, x + width, y + height);\n        ctx.fillStyle = tmpCtx.createPattern(tmpCanvas, \"no-repeat\");\n        ctx.fillRect(0, 0, x + width, y + height); // reassign mask\n        this.restoreStyles(element, ignoredStyles);\n    }\n    render(_) {}\n}\nMaskElement.ignoreStyles = [\n    \"mask\",\n    \"transform\",\n    \"clip-path\"\n];\nvar noop = ()=>{};\nclass ClipPathElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"clipPath\";\n    }\n    apply(ctx) {\n        var { document: document1 } = this;\n        var contextProto = Reflect.getPrototypeOf(ctx);\n        var { beginPath, closePath } = ctx;\n        if (contextProto) {\n            contextProto.beginPath = noop;\n            contextProto.closePath = noop;\n        }\n        Reflect.apply(beginPath, ctx, []);\n        this.children.forEach((child)=>{\n            if (typeof child.path === \"undefined\") {\n                return;\n            }\n            var transform = typeof child.elementTransform !== \"undefined\" ? child.elementTransform() : null; // handle <use />\n            if (!transform) {\n                transform = Transform.fromElement(document1, child);\n            }\n            if (transform) {\n                transform.apply(ctx);\n            }\n            child.path(ctx);\n            if (contextProto) {\n                contextProto.closePath = closePath;\n            }\n            if (transform) {\n                transform.unapply(ctx);\n            }\n        });\n        Reflect.apply(closePath, ctx, []);\n        ctx.clip();\n        if (contextProto) {\n            contextProto.beginPath = beginPath;\n            contextProto.closePath = closePath;\n        }\n    }\n    render(_) {}\n}\nclass FilterElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"filter\";\n    }\n    apply(ctx, element) {\n        // render as temp svg\n        var { document: document1, children } = this;\n        var boundingBox = element.getBoundingBox(ctx);\n        if (!boundingBox) {\n            return;\n        }\n        var px = 0;\n        var py = 0;\n        children.forEach((child)=>{\n            var efd = child.extraFilterDistance || 0;\n            px = Math.max(px, efd);\n            py = Math.max(py, efd);\n        });\n        var width = Math.floor(boundingBox.width);\n        var height = Math.floor(boundingBox.height);\n        var tmpCanvasWidth = width + 2 * px;\n        var tmpCanvasHeight = height + 2 * py;\n        if (tmpCanvasWidth < 1 || tmpCanvasHeight < 1) {\n            return;\n        }\n        var x = Math.floor(boundingBox.x);\n        var y = Math.floor(boundingBox.y);\n        var ignoredStyles = this.removeStyles(element, FilterElement.ignoreStyles);\n        var tmpCanvas = document1.createCanvas(tmpCanvasWidth, tmpCanvasHeight);\n        var tmpCtx = tmpCanvas.getContext(\"2d\");\n        document1.screen.setDefaults(tmpCtx);\n        tmpCtx.translate(-x + px, -y + py);\n        element.render(tmpCtx); // apply filters\n        children.forEach((child)=>{\n            if (typeof child.apply === \"function\") {\n                child.apply(tmpCtx, 0, 0, tmpCanvasWidth, tmpCanvasHeight);\n            }\n        }); // render on me\n        ctx.drawImage(tmpCanvas, 0, 0, tmpCanvasWidth, tmpCanvasHeight, x - px, y - py, tmpCanvasWidth, tmpCanvasHeight);\n        this.restoreStyles(element, ignoredStyles);\n    }\n    render(_) {}\n}\nFilterElement.ignoreStyles = [\n    \"filter\",\n    \"transform\",\n    \"clip-path\"\n];\nclass FeDropShadowElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"feDropShadow\";\n        this.addStylesFromStyleDefinition();\n    }\n    apply(_, _x, _y, _width, _height) {}\n}\nclass FeMorphologyElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"feMorphology\";\n    }\n    apply(_, _x, _y, _width, _height) {}\n}\nclass FeCompositeElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"feComposite\";\n    }\n    apply(_, _x, _y, _width, _height) {}\n}\nclass FeGaussianBlurElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"feGaussianBlur\";\n        this.blurRadius = Math.floor(this.getAttribute(\"stdDeviation\").getNumber());\n        this.extraFilterDistance = this.blurRadius;\n    }\n    apply(ctx, x, y, width, height) {\n        var { document: document1, blurRadius } = this;\n        var body = document1.window ? document1.window.document.body : null;\n        var canvas = ctx.canvas; // StackBlur requires canvas be on document\n        canvas.id = document1.getUniqueId();\n        if (body) {\n            canvas.style.display = \"none\";\n            body.appendChild(canvas);\n        }\n        (0,stackblur_canvas__WEBPACK_IMPORTED_MODULE_19__.canvasRGBA)(canvas, x, y, width, height, blurRadius);\n        if (body) {\n            body.removeChild(canvas);\n        }\n    }\n}\nclass TitleElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"title\";\n    }\n}\nclass DescElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"desc\";\n    }\n}\nvar elements = {\n    \"svg\": SVGElement,\n    \"rect\": RectElement,\n    \"circle\": CircleElement,\n    \"ellipse\": EllipseElement,\n    \"line\": LineElement,\n    \"polyline\": PolylineElement,\n    \"polygon\": PolygonElement,\n    \"path\": PathElement,\n    \"pattern\": PatternElement,\n    \"marker\": MarkerElement,\n    \"defs\": DefsElement,\n    \"linearGradient\": LinearGradientElement,\n    \"radialGradient\": RadialGradientElement,\n    \"stop\": StopElement,\n    \"animate\": AnimateElement,\n    \"animateColor\": AnimateColorElement,\n    \"animateTransform\": AnimateTransformElement,\n    \"font\": FontElement,\n    \"font-face\": FontFaceElement,\n    \"missing-glyph\": MissingGlyphElement,\n    \"glyph\": GlyphElement,\n    \"text\": TextElement,\n    \"tspan\": TSpanElement,\n    \"tref\": TRefElement,\n    \"a\": AElement,\n    \"textPath\": TextPathElement,\n    \"image\": ImageElement,\n    \"g\": GElement,\n    \"symbol\": SymbolElement,\n    \"style\": StyleElement,\n    \"use\": UseElement,\n    \"mask\": MaskElement,\n    \"clipPath\": ClipPathElement,\n    \"filter\": FilterElement,\n    \"feDropShadow\": FeDropShadowElement,\n    \"feMorphology\": FeMorphologyElement,\n    \"feComposite\": FeCompositeElement,\n    \"feColorMatrix\": FeColorMatrixElement,\n    \"feGaussianBlur\": FeGaussianBlurElement,\n    \"title\": TitleElement,\n    \"desc\": DescElement\n};\nfunction ownKeys$1(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$1(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$1(Object(source), true).forEach(function(key) {\n                _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$1(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nfunction createCanvas(width, height) {\n    var canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n}\nfunction createImage(_x) {\n    return _createImage.apply(this, arguments);\n}\nfunction _createImage() {\n    _createImage = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*(src) {\n        var anonymousCrossOrigin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var image = document.createElement(\"img\");\n        if (anonymousCrossOrigin) {\n            image.crossOrigin = \"Anonymous\";\n        }\n        return new Promise((resolve, reject)=>{\n            image.onload = ()=>{\n                resolve(image);\n            };\n            image.onerror = (_event, _source, _lineno, _colno, error)=>{\n                reject(error);\n            };\n            image.src = src;\n        });\n    });\n    return _createImage.apply(this, arguments);\n}\nclass Document {\n    constructor(canvg){\n        var { rootEmSize = 12, emSize = 12, createCanvas = Document.createCanvas, createImage = Document.createImage, anonymousCrossOrigin } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.canvg = canvg;\n        this.definitions = Object.create(null);\n        this.styles = Object.create(null);\n        this.stylesSpecificity = Object.create(null);\n        this.images = [];\n        this.fonts = [];\n        this.emSizeStack = [];\n        this.uniqueId = 0;\n        this.screen = canvg.screen;\n        this.rootEmSize = rootEmSize;\n        this.emSize = emSize;\n        this.createCanvas = createCanvas;\n        this.createImage = this.bindCreateImage(createImage, anonymousCrossOrigin);\n        this.screen.wait(this.isImagesLoaded.bind(this));\n        this.screen.wait(this.isFontsLoaded.bind(this));\n    }\n    bindCreateImage(createImage, anonymousCrossOrigin) {\n        if (typeof anonymousCrossOrigin === \"boolean\") {\n            return (source, forceAnonymousCrossOrigin)=>createImage(source, typeof forceAnonymousCrossOrigin === \"boolean\" ? forceAnonymousCrossOrigin : anonymousCrossOrigin);\n        }\n        return createImage;\n    }\n    get window() {\n        return this.screen.window;\n    }\n    get fetch() {\n        return this.screen.fetch;\n    }\n    get ctx() {\n        return this.screen.ctx;\n    }\n    get emSize() {\n        var { emSizeStack } = this;\n        return emSizeStack[emSizeStack.length - 1];\n    }\n    set emSize(value) {\n        var { emSizeStack } = this;\n        emSizeStack.push(value);\n    }\n    popEmSize() {\n        var { emSizeStack } = this;\n        emSizeStack.pop();\n    }\n    getUniqueId() {\n        return \"canvg\".concat(++this.uniqueId);\n    }\n    isImagesLoaded() {\n        return this.images.every((_)=>_.loaded);\n    }\n    isFontsLoaded() {\n        return this.fonts.every((_)=>_.loaded);\n    }\n    createDocumentElement(document1) {\n        var documentElement = this.createElement(document1.documentElement);\n        documentElement.root = true;\n        documentElement.addStylesFromStyleDefinition();\n        this.documentElement = documentElement;\n        return documentElement;\n    }\n    createElement(node) {\n        var elementType = node.nodeName.replace(/^[^:]+:/, \"\");\n        var ElementType = Document.elementTypes[elementType];\n        if (typeof ElementType !== \"undefined\") {\n            return new ElementType(this, node);\n        }\n        return new UnknownElement(this, node);\n    }\n    createTextNode(node) {\n        return new TextNode(this, node);\n    }\n    setViewBox(config) {\n        this.screen.setViewBox(_objectSpread$1({\n            document: this\n        }, config));\n    }\n}\nDocument.createCanvas = createCanvas;\nDocument.createImage = createImage;\nDocument.elementTypes = elements;\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys(Object(source), true).forEach(function(key) {\n                _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\n/**\r\n * SVG renderer on canvas.\r\n */ class Canvg {\n    /**\r\n   * Main constructor.\r\n   * @param ctx - Rendering context.\r\n   * @param svg - SVG Document.\r\n   * @param options - Rendering options.\r\n   */ constructor(ctx, svg){\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        this.parser = new Parser(options);\n        this.screen = new Screen(ctx, options);\n        this.options = options;\n        var document1 = new Document(this, options);\n        var documentElement = document1.createDocumentElement(svg);\n        this.document = document1;\n        this.documentElement = documentElement;\n    }\n    /**\r\n   * Create Canvg instance from SVG source string or URL.\r\n   * @param ctx - Rendering context.\r\n   * @param svg - SVG source string or URL.\r\n   * @param options - Rendering options.\r\n   * @returns Canvg instance.\r\n   */ static from(ctx, svg) {\n        var _arguments = arguments;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            var options = _arguments.length > 2 && _arguments[2] !== undefined ? _arguments[2] : {};\n            var parser = new Parser(options);\n            var svgDocument = yield parser.parse(svg);\n            return new Canvg(ctx, svgDocument, options);\n        })();\n    }\n    /**\r\n   * Create Canvg instance from SVG source string.\r\n   * @param ctx - Rendering context.\r\n   * @param svg - SVG source string.\r\n   * @param options - Rendering options.\r\n   * @returns Canvg instance.\r\n   */ static fromString(ctx, svg) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var parser = new Parser(options);\n        var svgDocument = parser.parseFromString(svg);\n        return new Canvg(ctx, svgDocument, options);\n    }\n    /**\r\n   * Create new Canvg instance with inherited options.\r\n   * @param ctx - Rendering context.\r\n   * @param svg - SVG source string or URL.\r\n   * @param options - Rendering options.\r\n   * @returns Canvg instance.\r\n   */ fork(ctx, svg) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return Canvg.from(ctx, svg, _objectSpread(_objectSpread({}, this.options), options));\n    }\n    /**\r\n   * Create new Canvg instance with inherited options.\r\n   * @param ctx - Rendering context.\r\n   * @param svg - SVG source string.\r\n   * @param options - Rendering options.\r\n   * @returns Canvg instance.\r\n   */ forkString(ctx, svg) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return Canvg.fromString(ctx, svg, _objectSpread(_objectSpread({}, this.options), options));\n    }\n    /**\r\n   * Document is ready promise.\r\n   * @returns Ready promise.\r\n   */ ready() {\n        return this.screen.ready();\n    }\n    /**\r\n   * Document is ready value.\r\n   * @returns Is ready or not.\r\n   */ isReady() {\n        return this.screen.isReady();\n    }\n    /**\r\n   * Render only first frame, ignoring animations and mouse.\r\n   * @param options - Rendering options.\r\n   */ render() {\n        var _arguments2 = arguments, _this = this;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            var options = _arguments2.length > 0 && _arguments2[0] !== undefined ? _arguments2[0] : {};\n            _this.start(_objectSpread({\n                enableRedraw: true,\n                ignoreAnimation: true,\n                ignoreMouse: true\n            }, options));\n            yield _this.ready();\n            _this.stop();\n        })();\n    }\n    /**\r\n   * Start rendering.\r\n   * @param options - Render options.\r\n   */ start() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var { documentElement, screen, options: baseOptions } = this;\n        screen.start(documentElement, _objectSpread(_objectSpread({\n            enableRedraw: true\n        }, baseOptions), options));\n    }\n    /**\r\n   * Stop rendering.\r\n   */ stop() {\n        this.screen.stop();\n    }\n    /**\r\n   * Resize SVG to fit in given size.\r\n   * @param width\r\n   * @param height\r\n   * @param preserveAspectRatio\r\n   */ resize(width) {\n        var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : width;\n        var preserveAspectRatio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        this.documentElement.resize(width, height, preserveAspectRatio);\n    }\n}\n //# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguZXMuanMiLCJzb3VyY2VzIjpbXSwic291cmNlc0NvbnRlbnQiOltdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2FudmcvbGliL2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUM7QUFDaUM7QUFDNUI7QUFDRTtBQUNJO0FBQ0o7QUFDVztBQUNXO0FBQ3hCO0FBQ0k7QUFDSjtBQUNKO0FBQ0c7QUFDWDtBQUNjO0FBQ0M7QUFDRjtBQUNGO0FBQ0s7QUFDRjtBQUU5Qzs7Ozs7Q0FLQyxHQUNELFNBQVNNO0lBQ1AsSUFBSSxFQUNGQyxXQUFXQyxpQkFBaUIsRUFDN0IsR0FBR0MsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUtFLFlBQVlGLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztJQUN6RSxJQUFJRyxTQUFTO1FBQ1hDLFFBQVE7UUFDUkMsaUJBQWlCO1FBQ2pCQyxhQUFhO1FBQ2JSLFdBQVdDO1FBRVhRLGNBQWFDLEtBQUssRUFBRUMsTUFBTTtZQUN4QixPQUFPLElBQUlDLGdCQUFnQkYsT0FBT0M7UUFDcEM7UUFFQUUsYUFBWUMsR0FBRztZQUNiLE9BQU9yQixvRUFBaUJBLENBQUM7Z0JBQ3ZCLElBQUlzQixXQUFXLE1BQU1DLE1BQU1GO2dCQUMzQixJQUFJRyxPQUFPLE1BQU1GLFNBQVNFLElBQUk7Z0JBQzlCLElBQUlDLE1BQU0sTUFBTUMsa0JBQWtCRjtnQkFDbEMsT0FBT0M7WUFDVDtRQUNGO0lBRUY7SUFFQSxJQUFJLE9BQU9sQixjQUFjLGVBQWUsT0FBT0Msc0JBQXNCLGFBQWE7UUFDaEZtQixRQUFRQyxjQUFjLENBQUNoQixRQUFRO0lBQ2pDO0lBRUEsT0FBT0E7QUFDVDtBQUVBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTaUIsS0FBS0MsSUFBSTtJQUNoQixJQUFJLEVBQ0Z2QixXQUFBQSxVQUFTLEVBQ1R3QixNQUFNLEVBQ05SLE9BQUFBLE1BQUssRUFDTixHQUFHTztJQUNKLE9BQU87UUFDTGpCLFFBQVE7UUFDUkMsaUJBQWlCO1FBQ2pCQyxhQUFhO1FBQ2JSLFdBQUFBO1FBQ0FnQixPQUFBQTtRQUNBUCxjQUFjZSxPQUFPZixZQUFZO1FBQ2pDSSxhQUFhVyxPQUFPQyxTQUFTO0lBQy9CO0FBQ0Y7QUFFQSxJQUFJQyxRQUFRLFdBQVcsR0FBRUMsT0FBT0MsTUFBTSxDQUFDO0lBQ3RDQyxXQUFXO0lBQ1g5QixXQUFXQTtJQUNYdUIsTUFBTUE7QUFDUDtBQUVBOzs7O0NBSUMsR0FDRCxTQUFTUSxlQUFlQyxHQUFHO0lBQ3pCLE9BQU9BLElBQUlDLE9BQU8sQ0FBQyxtQkFBbUI7QUFDeEM7QUFDQTs7OztDQUlDLEdBRUQsU0FBU0MsU0FBU0YsR0FBRztJQUNuQixPQUFPQSxJQUFJQyxPQUFPLENBQUMsYUFBYTtBQUNsQztBQUNBOzs7O0NBSUMsR0FFRCxTQUFTRSxVQUFVSCxHQUFHO0lBQ3BCLE9BQU9BLElBQUlDLE9BQU8sQ0FBQyxhQUFhO0FBQ2xDO0FBQ0E7Ozs7Q0FJQyxHQUVELFNBQVNHLFVBQVVKLEdBQUc7SUFDcEIsSUFBSUssVUFBVSxDQUFDTCxPQUFPLEVBQUMsRUFBR00sS0FBSyxDQUFDLHlEQUF5RCxFQUFFO0lBQzNGLE9BQU9ELFFBQVFFLEdBQUcsQ0FBQ0M7QUFDckIsRUFBRSxxQkFBcUI7QUFFdkIsSUFBSUMsZUFBZTtBQUNuQjs7OztDQUlDLEdBRUQsU0FBU0MsdUJBQXVCQyxJQUFJO0lBQ2xDLElBQUlGLGFBQWFHLElBQUksQ0FBQ0QsT0FBTztRQUMzQixPQUFPQSxLQUFLRSxXQUFXO0lBQ3pCO0lBRUEsT0FBT0Y7QUFDVDtBQUNBOzs7O0NBSUMsR0FFRCxTQUFTRyxpQkFBaUIvQixHQUFHO0lBQzNCLHlDQUF5QztJQUN6QyxtREFBbUQ7SUFDbkQseURBQXlEO0lBQ3pELDZDQUE2QztJQUM3QyxJQUFJZ0MsV0FBVyx5Q0FBeUNDLElBQUksQ0FBQ2pDLFFBQVEsRUFBRTtJQUN2RSxPQUFPZ0MsUUFBUSxDQUFDLEVBQUUsSUFBSUEsUUFBUSxDQUFDLEVBQUUsSUFBSUEsUUFBUSxDQUFDLEVBQUU7QUFDbEQ7QUFDQTs7OztDQUlDLEdBRUQsU0FBU0UsZUFBZUMsS0FBSztJQUMzQixJQUFJLENBQUNBLE1BQU1DLFVBQVUsQ0FBQyxRQUFRO1FBQzVCLE9BQU9EO0lBQ1Q7SUFFQSxJQUFJRSxXQUFXO0lBQ2YsSUFBSUMsa0JBQWtCSCxNQUFNakIsT0FBTyxDQUFDLGdCQUFnQixDQUFDcUIsS0FBS0MsVUFBWUgsY0FBY0csVUFBVUMsT0FBT0MsS0FBS0MsS0FBSyxDQUFDbEIsV0FBV2MsU0FBU0E7SUFDcEksT0FBT0Q7QUFDVDtBQUVBLHNHQUFzRztBQUN0RyxJQUFJTSxpQkFBaUI7QUFDckIsSUFBSUMsVUFBVTtBQUNkLElBQUlDLGFBQWE7QUFDakIsSUFBSUMscUJBQXFCO0FBQ3pCLElBQUlDLCtCQUErQjtBQUNuQyxJQUFJQyxtQkFBbUI7QUFDdkIsSUFBSUMsZUFBZTtBQUVuQixTQUFTQyxrQkFBa0JDLFFBQVEsRUFBRUMsS0FBSztJQUN4QyxJQUFJL0IsVUFBVStCLE1BQU1wQixJQUFJLENBQUNtQjtJQUV6QixJQUFJLENBQUM5QixTQUFTO1FBQ1osT0FBTztZQUFDOEI7WUFBVTtTQUFFO0lBQ3RCO0lBRUEsT0FBTztRQUFDQSxTQUFTbEMsT0FBTyxDQUFDbUMsT0FBTztRQUFNL0IsUUFBUWpDLE1BQU07S0FBQztBQUN2RDtBQUNBOzs7O0NBSUMsR0FHRCxTQUFTaUUsdUJBQXVCRixRQUFRO0lBQ3RDLElBQUlHLGNBQWM7UUFBQztRQUFHO1FBQUc7S0FBRTtJQUMzQixJQUFJQyxrQkFBa0JKLFNBQVNsQyxPQUFPLENBQUMsb0JBQW9CLFlBQVlBLE9BQU8sQ0FBQyxjQUFjO0lBQzdGLElBQUl1QyxRQUFRO0lBQ1osQ0FBQ0QsaUJBQWlCQyxNQUFNLEdBQUdOLGtCQUFrQkssaUJBQWlCWjtJQUM5RFcsV0FBVyxDQUFDLEVBQUUsSUFBSUU7SUFDbEIsQ0FBQ0QsaUJBQWlCQyxNQUFNLEdBQUdOLGtCQUFrQkssaUJBQWlCWDtJQUM5RFUsV0FBVyxDQUFDLEVBQUUsSUFBSUU7SUFDbEIsQ0FBQ0QsaUJBQWlCQyxNQUFNLEdBQUdOLGtCQUFrQkssaUJBQWlCVjtJQUM5RFMsV0FBVyxDQUFDLEVBQUUsSUFBSUU7SUFDbEIsQ0FBQ0QsaUJBQWlCQyxNQUFNLEdBQUdOLGtCQUFrQkssaUJBQWlCVDtJQUM5RFEsV0FBVyxDQUFDLEVBQUUsSUFBSUU7SUFDbEIsQ0FBQ0QsaUJBQWlCQyxNQUFNLEdBQUdOLGtCQUFrQkssaUJBQWlCUjtJQUM5RE8sV0FBVyxDQUFDLEVBQUUsSUFBSUU7SUFDbEIsQ0FBQ0QsaUJBQWlCQyxNQUFNLEdBQUdOLGtCQUFrQkssaUJBQWlCUDtJQUM5RE0sV0FBVyxDQUFDLEVBQUUsSUFBSUU7SUFDbEJELGtCQUFrQkEsZ0JBQWdCdEMsT0FBTyxDQUFDLGFBQWEsS0FBS0EsT0FBTyxDQUFDLFNBQVM7SUFDN0UsQ0FBQ3NDLGlCQUFpQkMsTUFBTSxHQUFHTixrQkFBa0JLLGlCQUFpQk4sZUFBZSx3Q0FBd0M7SUFFckhLLFdBQVcsQ0FBQyxFQUFFLElBQUlFO0lBQ2xCLE9BQU9GLFlBQVlHLElBQUksQ0FBQztBQUMxQjtBQUVBLElBQUlDLGNBQWM7QUFDbEI7Ozs7Q0FJQyxHQUVELFNBQVNDLGdCQUFnQkMsQ0FBQztJQUN4QixPQUFPbkIsS0FBS29CLElBQUksQ0FBQ3BCLEtBQUtxQixHQUFHLENBQUNGLENBQUMsQ0FBQyxFQUFFLEVBQUUsS0FBS25CLEtBQUtxQixHQUFHLENBQUNGLENBQUMsQ0FBQyxFQUFFLEVBQUU7QUFDdEQ7QUFDQTs7Ozs7Q0FLQyxHQUVELFNBQVNHLGFBQWFDLENBQUMsRUFBRUosQ0FBQztJQUN4QixPQUFPLENBQUNJLENBQUMsQ0FBQyxFQUFFLEdBQUdKLENBQUMsQ0FBQyxFQUFFLEdBQUdJLENBQUMsQ0FBQyxFQUFFLEdBQUdKLENBQUMsQ0FBQyxFQUFFLElBQUtELENBQUFBLGdCQUFnQkssS0FBS0wsZ0JBQWdCQyxFQUFDO0FBQzlFO0FBQ0E7Ozs7O0NBS0MsR0FFRCxTQUFTSyxhQUFhRCxDQUFDLEVBQUVKLENBQUM7SUFDeEIsT0FBTyxDQUFDSSxDQUFDLENBQUMsRUFBRSxHQUFHSixDQUFDLENBQUMsRUFBRSxHQUFHSSxDQUFDLENBQUMsRUFBRSxHQUFHSixDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsSUFBSSxLQUFLbkIsS0FBS3lCLElBQUksQ0FBQ0gsYUFBYUMsR0FBR0o7QUFDMUU7QUFDQSxTQUFTTyxJQUFJQyxDQUFDO0lBQ1osT0FBT0EsSUFBSUEsSUFBSUE7QUFDakI7QUFDQSxTQUFTQyxJQUFJRCxDQUFDO0lBQ1osT0FBTyxJQUFJQSxJQUFJQSxJQUFLLEtBQUlBLENBQUFBO0FBQzFCO0FBQ0EsU0FBU0UsSUFBSUYsQ0FBQztJQUNaLE9BQU8sSUFBSUEsSUFBSyxLQUFJQSxDQUFBQSxJQUFNLEtBQUlBLENBQUFBO0FBQ2hDO0FBQ0EsU0FBU0csSUFBSUgsQ0FBQztJQUNaLE9BQU8sQ0FBQyxJQUFJQSxDQUFBQSxJQUFNLEtBQUlBLENBQUFBLElBQU0sS0FBSUEsQ0FBQUE7QUFDbEM7QUFDQSxTQUFTSSxJQUFJSixDQUFDO0lBQ1osT0FBT0EsSUFBSUE7QUFDYjtBQUNBLFNBQVNLLElBQUlMLENBQUM7SUFDWixPQUFPLElBQUlBLElBQUssS0FBSUEsQ0FBQUE7QUFDdEI7QUFDQSxTQUFTTSxJQUFJTixDQUFDO0lBQ1osT0FBTyxDQUFDLElBQUlBLENBQUFBLElBQU0sS0FBSUEsQ0FBQUE7QUFDeEI7QUFFQSxNQUFNTztJQUNKQyxZQUFZQyxTQUFRLEVBQUVsRCxJQUFJLEVBQUVtRCxLQUFLLENBQUU7UUFDakMsSUFBSSxDQUFDRCxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ2xELElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNtRCxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztJQUMzQjtJQUVBLE9BQU9DLE1BQU1ILFNBQVEsRUFBRTtRQUNyQixPQUFPLElBQUlGLFNBQVNFLFdBQVUsU0FBUztJQUN6QztJQUVBSSxRQUFRO1FBQ04sSUFBSUMsWUFBWS9GLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3BGLElBQUksRUFDRjBGLFVBQUFBLFNBQVEsRUFDUmxELElBQUksRUFDTCxHQUFHLElBQUk7UUFDUixPQUFPWixlQUFlLElBQUksQ0FBQ29FLFNBQVMsSUFBSUMsSUFBSSxHQUFHSCxLQUFLLENBQUNDLFdBQVczRCxHQUFHLENBQUN1RCxDQUFBQSxRQUFTLElBQUlILFNBQVNFLFdBQVVsRCxNQUFNbUQ7SUFDNUc7SUFFQU8sU0FBU0MsV0FBVyxFQUFFO1FBQ3BCLElBQUksRUFDRlIsS0FBSyxFQUNOLEdBQUcsSUFBSTtRQUNSLE9BQU9BLFVBQVUsUUFBUUEsVUFBVSxNQUFPUSxDQUFBQSxlQUFlUixVQUFVLE1BQU0sT0FBT0EsVUFBVTtJQUM1RjtJQUVBUyxTQUFTQyxNQUFNLEVBQUU7UUFDZixJQUFJLEVBQ0ZWLEtBQUssRUFDTixHQUFHLElBQUk7UUFDUixJQUFJVyxTQUFTLE9BQU9YLFVBQVU7UUFFOUIsSUFBSSxDQUFDVyxVQUFVLENBQUNELFFBQVE7WUFDdEIsT0FBT0M7UUFDVDtRQUVBLE9BQU9ELE9BQU81RCxJQUFJLENBQUNrRDtJQUNyQjtJQUVBWSxrQkFBa0I7UUFDaEIsT0FBTyxJQUFJLENBQUNILFFBQVEsQ0FBQztJQUN2QjtJQUVBSSxXQUFXO1FBQ1QsSUFBSSxDQUFDLElBQUksQ0FBQ04sUUFBUSxJQUFJO1lBQ3BCLE9BQU87UUFDVDtRQUVBLElBQUlPLFdBQVcsSUFBSSxDQUFDVCxTQUFTO1FBRTdCLE9BQVE7WUFDTixLQUFLUyxTQUFTQyxRQUFRLENBQUM7WUFDdkIsS0FBSyxXQUFXakUsSUFBSSxDQUFDZ0U7Z0JBQ25CLE9BQU87WUFFVDtnQkFDRSxPQUFPO1FBQ1g7SUFDRjtJQUVBRSxTQUFTaEIsS0FBSyxFQUFFO1FBQ2QsSUFBSSxDQUFDQSxLQUFLLEdBQUdBO1FBQ2IsT0FBTyxJQUFJO0lBQ2I7SUFFQWlCLFNBQVNDLEdBQUcsRUFBRTtRQUNaLElBQUksT0FBT0EsUUFBUSxlQUFlLElBQUksQ0FBQ1gsUUFBUSxJQUFJO1lBQ2pELE9BQU8sSUFBSSxDQUFDUCxLQUFLO1FBQ25CO1FBRUEsT0FBT2tCO0lBQ1Q7SUFFQUMsVUFBVUQsR0FBRyxFQUFFO1FBQ2IsSUFBSSxDQUFDLElBQUksQ0FBQ1gsUUFBUSxJQUFJO1lBQ3BCLElBQUksT0FBT1csUUFBUSxhQUFhO2dCQUM5QixPQUFPO1lBQ1Q7WUFFQSxPQUFPeEUsV0FBV3dFO1FBQ3BCO1FBRUEsSUFBSSxFQUNGbEIsS0FBSyxFQUNOLEdBQUcsSUFBSTtRQUNSLElBQUlvQixJQUFJMUUsV0FBV3NEO1FBRW5CLElBQUksSUFBSSxDQUFDUyxRQUFRLENBQUMsT0FBTztZQUN2QlcsS0FBSztRQUNQO1FBRUEsT0FBT0E7SUFDVDtJQUVBZixVQUFVYSxHQUFHLEVBQUU7UUFDYixJQUFJLE9BQU9BLFFBQVEsZUFBZSxJQUFJLENBQUNYLFFBQVEsSUFBSTtZQUNqRCxPQUFPLE9BQU8sSUFBSSxDQUFDUCxLQUFLLEtBQUssY0FBYyxLQUFLdEMsT0FBTyxJQUFJLENBQUNzQyxLQUFLO1FBQ25FO1FBRUEsT0FBT3RDLE9BQU93RDtJQUNoQjtJQUVBRyxTQUFTSCxHQUFHLEVBQUU7UUFDWixJQUFJOUQsUUFBUSxJQUFJLENBQUNpRCxTQUFTLENBQUNhO1FBRTNCLElBQUksSUFBSSxDQUFDakIsaUJBQWlCLEVBQUU7WUFDMUIsT0FBTzdDO1FBQ1Q7UUFFQSxJQUFJLENBQUM2QyxpQkFBaUIsR0FBRztRQUN6QjdDLFFBQVFELGVBQWVDO1FBQ3ZCLElBQUksQ0FBQzRDLEtBQUssR0FBRzVDO1FBQ2IsT0FBT0E7SUFDVDtJQUVBa0UsU0FBUztRQUNQLE9BQU8sTUFBTSxpQkFBaUI7SUFDaEM7SUFFQUMsU0FBUztRQUNQLE9BQU8sSUFBSSxDQUFDeEIsUUFBUSxDQUFDeUIsVUFBVTtJQUNqQztJQUVBQyxRQUFRO1FBQ04sT0FBTyxJQUFJLENBQUMxQixRQUFRLENBQUMyQixNQUFNO0lBQzdCO0lBRUFDLFdBQVc7UUFDVCxPQUFPLElBQUksQ0FBQ3RCLFNBQVMsR0FBR2xFLE9BQU8sQ0FBQyxZQUFZO0lBQzlDO0lBRUF5RixVQUFVQyxnQkFBZ0IsRUFBRTtRQUMxQixJQUFJQyxpQkFBaUJ6SCxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRztRQUV6RixJQUFJLENBQUMsSUFBSSxDQUFDa0csUUFBUSxJQUFJO1lBQ3BCLE9BQU87UUFDVDtRQUVBLElBQUksQ0FBQ3dCLE1BQU1DLFdBQVcsR0FBRyxPQUFPSCxxQkFBcUIsWUFBWTtZQUFDdEg7WUFBV3NIO1NBQWlCLEdBQUc7WUFBQ0E7U0FBaUI7UUFDbkgsSUFBSSxFQUNGSSxRQUFRLEVBQ1QsR0FBRyxJQUFJLENBQUNsQyxRQUFRLENBQUNtQyxNQUFNO1FBRXhCLE9BQVE7WUFDTixLQUFLLElBQUksQ0FBQ3pCLFFBQVEsQ0FBQztnQkFDakIsT0FBTyxJQUFJLENBQUNVLFNBQVMsS0FBSyxRQUFReEQsS0FBS3dFLEdBQUcsQ0FBQ0YsU0FBU0csV0FBVyxDQUFDLE1BQU1ILFNBQVNHLFdBQVcsQ0FBQztZQUU3RixLQUFLLElBQUksQ0FBQzNCLFFBQVEsQ0FBQztnQkFDakIsT0FBTyxJQUFJLENBQUNVLFNBQVMsS0FBSyxRQUFReEQsS0FBSzBFLEdBQUcsQ0FBQ0osU0FBU0csV0FBVyxDQUFDLE1BQU1ILFNBQVNHLFdBQVcsQ0FBQztZQUU3RixLQUFLLElBQUksQ0FBQzNCLFFBQVEsQ0FBQztnQkFDakIsT0FBTyxJQUFJLENBQUNVLFNBQVMsS0FBSyxRQUFRYyxTQUFTRyxXQUFXLENBQUM7WUFFekQsS0FBSyxJQUFJLENBQUMzQixRQUFRLENBQUM7Z0JBQ2pCLE9BQU8sSUFBSSxDQUFDVSxTQUFTLEtBQUssUUFBUWMsU0FBU0csV0FBVyxDQUFDO1lBRXpELEtBQUssSUFBSSxDQUFDM0IsUUFBUSxDQUFDO2dCQUNqQixPQUFPLElBQUksQ0FBQ1UsU0FBUyxLQUFLLElBQUksQ0FBQ0ksTUFBTTtZQUV2QyxLQUFLLElBQUksQ0FBQ2QsUUFBUSxDQUFDO2dCQUNqQixPQUFPLElBQUksQ0FBQ1UsU0FBUyxLQUFLLElBQUksQ0FBQ00sS0FBSztZQUV0QyxLQUFLLElBQUksQ0FBQ2hCLFFBQVEsQ0FBQztnQkFDakIsT0FBTyxJQUFJLENBQUNVLFNBQVMsS0FBSyxJQUFJLENBQUNNLEtBQUssS0FBSztZQUUzQyxLQUFLLElBQUksQ0FBQ2hCLFFBQVEsQ0FBQztnQkFDakIsT0FBTyxJQUFJLENBQUNVLFNBQVM7WUFFdkIsS0FBSyxJQUFJLENBQUNWLFFBQVEsQ0FBQztnQkFDakIsT0FBTyxJQUFJLENBQUNVLFNBQVMsS0FBSyxJQUFJLENBQUNHLE1BQU0sS0FBTSxPQUFNLElBQUc7WUFFdEQsS0FBSyxJQUFJLENBQUNiLFFBQVEsQ0FBQztnQkFDakIsT0FBTyxJQUFJLENBQUNVLFNBQVMsS0FBSztZQUU1QixLQUFLLElBQUksQ0FBQ1YsUUFBUSxDQUFDO2dCQUNqQixPQUFPLElBQUksQ0FBQ1UsU0FBUyxLQUFLLElBQUksQ0FBQ0csTUFBTSxLQUFLO1lBRTVDLEtBQUssSUFBSSxDQUFDYixRQUFRLENBQUM7Z0JBQ2pCLE9BQU8sSUFBSSxDQUFDVSxTQUFTLEtBQUssSUFBSSxDQUFDRyxNQUFNLEtBQUs7WUFFNUMsS0FBSyxJQUFJLENBQUNiLFFBQVEsQ0FBQztnQkFDakIsT0FBTyxJQUFJLENBQUNVLFNBQVMsS0FBSyxJQUFJLENBQUNHLE1BQU07WUFFdkMsS0FBSyxJQUFJLENBQUNiLFFBQVEsQ0FBQyxTQUFTdUI7Z0JBQzFCLE9BQU8sSUFBSSxDQUFDYixTQUFTLEtBQUssSUFBSSxDQUFDTSxLQUFLO1lBRXRDLEtBQUssSUFBSSxDQUFDaEIsUUFBUSxDQUFDO2dCQUNqQixPQUFPLElBQUksQ0FBQ1UsU0FBUyxLQUFLYyxTQUFTRyxXQUFXLENBQUNMO1lBRWpEO2dCQUNFO29CQUNFLElBQUlYLElBQUksSUFBSSxDQUFDRCxTQUFTO29CQUV0QixJQUFJVyxrQkFBa0JWLElBQUksS0FBSzt3QkFDN0IsT0FBT0EsSUFBSWEsU0FBU0csV0FBVyxDQUFDTDtvQkFDbEM7b0JBRUEsT0FBT1g7Z0JBQ1Q7UUFDSjtJQUNGO0lBRUFrQixrQkFBa0I7UUFDaEIsSUFBSSxDQUFDLElBQUksQ0FBQy9CLFFBQVEsSUFBSTtZQUNwQixPQUFPO1FBQ1Q7UUFFQSxJQUFJLElBQUksQ0FBQ0UsUUFBUSxDQUFDLFFBQVE7WUFDeEIsT0FBTyxJQUFJLENBQUNVLFNBQVM7UUFDdkI7UUFFQSxPQUFPLElBQUksQ0FBQ0EsU0FBUyxLQUFLO0lBQzVCO0lBRUFvQixhQUFhO1FBQ1gsSUFBSSxDQUFDLElBQUksQ0FBQ2hDLFFBQVEsSUFBSTtZQUNwQixPQUFPO1FBQ1Q7UUFFQSxPQUFRO1lBQ04sS0FBSyxJQUFJLENBQUNFLFFBQVEsQ0FBQztnQkFDakIsT0FBTyxJQUFJLENBQUNVLFNBQVMsS0FBTXhELENBQUFBLEtBQUs2RSxFQUFFLEdBQUcsS0FBSTtZQUUzQyxLQUFLLElBQUksQ0FBQy9CLFFBQVEsQ0FBQztnQkFDakIsT0FBTyxJQUFJLENBQUNVLFNBQVMsS0FBTXhELENBQUFBLEtBQUs2RSxFQUFFLEdBQUcsS0FBSTtZQUUzQyxLQUFLLElBQUksQ0FBQy9CLFFBQVEsQ0FBQztnQkFDakIsT0FBTyxJQUFJLENBQUNVLFNBQVM7WUFFdkI7Z0JBQ0UsT0FBTyxJQUFJLENBQUNBLFNBQVMsS0FBTXhELENBQUFBLEtBQUs2RSxFQUFFLEdBQUcsS0FBSTtRQUM3QztJQUNGO0lBRUFDLGdCQUFnQjtRQUNkLElBQUkzQixXQUFXLElBQUksQ0FBQ1QsU0FBUztRQUM3QixJQUFJeEQsT0FBTyxhQUFhSyxJQUFJLENBQUM0RDtRQUU3QixJQUFJakUsTUFBTTtZQUNSQSxPQUFPQSxJQUFJLENBQUMsRUFBRTtRQUNoQjtRQUVBLElBQUksQ0FBQ0EsTUFBTTtZQUNUQSxPQUFPaUU7UUFDVDtRQUVBLE9BQU8sSUFBSSxDQUFDZixRQUFRLENBQUMyQyxXQUFXLENBQUM3RixLQUFLO0lBQ3hDO0lBRUE4Rix1QkFBdUJDLE9BQU8sRUFBRUMsT0FBTyxFQUFFO1FBQ3ZDLElBQUkzQixNQUFNLElBQUksQ0FBQ3VCLGFBQWE7UUFFNUIsSUFBSSxDQUFDdkIsS0FBSztZQUNSLE9BQU87UUFDVCxFQUFFLFdBQVc7UUFHYixJQUFJLE9BQU9BLElBQUk0QixjQUFjLEtBQUssWUFBWTtZQUM1QyxPQUFPNUIsSUFBSTRCLGNBQWMsQ0FBQyxJQUFJLENBQUMvQyxRQUFRLENBQUNnRCxHQUFHLEVBQUVILFNBQVNDO1FBQ3hELEVBQUUsVUFBVTtRQUdaLElBQUksT0FBTzNCLElBQUk4QixhQUFhLEtBQUssWUFBWTtZQUMzQyxJQUFJOUIsSUFBSStCLGdCQUFnQixHQUFHMUMsUUFBUSxJQUFJO2dCQUNyQyxJQUFJMkMsbUJBQW1CaEMsSUFBSWlDLFlBQVksQ0FBQztnQkFDeENqQyxNQUFNQSxJQUFJK0IsZ0JBQWdCLEdBQUdSLGFBQWE7Z0JBRTFDLElBQUlTLGlCQUFpQjNDLFFBQVEsSUFBSTtvQkFDL0JXLElBQUlpQyxZQUFZLENBQUMsb0JBQW9CLE1BQU1uQyxRQUFRLENBQUNrQyxpQkFBaUJsRCxLQUFLO2dCQUM1RTtZQUNGO1lBRUEsT0FBT2tCLElBQUk4QixhQUFhLENBQUMsSUFBSSxDQUFDakQsUUFBUSxDQUFDZ0QsR0FBRyxFQUFFSCxTQUFTQztRQUN2RDtRQUVBLE9BQU87SUFDVDtJQUVBTyxrQkFBa0I7UUFDaEIsSUFBSSxDQUFDLElBQUksQ0FBQzdDLFFBQVEsSUFBSTtZQUNwQixPQUFPO1FBQ1Q7UUFFQSxPQUFPVixTQUFTd0QsbUJBQW1CLENBQUMsSUFBSSxDQUFDaEQsU0FBUyxHQUFHO0lBQ3ZEO0lBRUFpRCxXQUFXVCxPQUFPLEVBQUU7UUFDbEIsSUFBSTdDLFFBQVEsSUFBSSxDQUFDcUIsUUFBUTtRQUN6QixJQUFJa0MsTUFBTXZELE1BQU0xRixNQUFNO1FBQ3RCLElBQUlrSixTQUFTLEdBQUcseURBQXlEO1FBRXpFLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRixLQUFLRSxJQUFLO1lBQzVCLElBQUl6RCxLQUFLLENBQUN5RCxFQUFFLEtBQUssS0FBSztnQkFDcEJEO1lBQ0Y7WUFFQSxJQUFJQSxXQUFXLEdBQUc7Z0JBQ2hCO1lBQ0Y7UUFDRjtRQUVBLElBQUlYLFFBQVF0QyxRQUFRLE1BQU0sSUFBSSxDQUFDRSxRQUFRLE1BQU0rQyxXQUFXLEdBQUc7WUFDekQsSUFBSXBHLFFBQVEsSUFBSXJELHNDQUFRQSxDQUFDaUc7WUFFekIsSUFBSTVDLE1BQU1zRyxFQUFFLEVBQUU7Z0JBQ1p0RyxNQUFNdUcsS0FBSyxHQUFHZCxRQUFRMUIsU0FBUztnQkFDL0JuQixRQUFRNUMsTUFBTXdHLE1BQU07WUFDdEI7UUFDRjtRQUVBLE9BQU8sSUFBSS9ELFNBQVMsSUFBSSxDQUFDRSxRQUFRLEVBQUUsSUFBSSxDQUFDbEQsSUFBSSxFQUFFbUQ7SUFDaEQ7QUFFRjtBQUNBSCxTQUFTd0QsbUJBQW1CLEdBQUc7SUFDN0IsWUFBWTtJQUNaLGVBQWU7SUFDZixvQkFBb0I7SUFDcEIsVUFBVTtJQUNWLFdBQVc7SUFDWCxjQUFjO0lBQ2QsbUJBQW1CO0lBQ25CLGVBQWU7SUFDZixjQUFjO0lBQ2QsV0FBVztJQUNYLGdCQUFnQjtBQUNsQjtBQUVBLE1BQU1RO0lBQ0ovRCxhQUFjO1FBQ1osSUFBSSxDQUFDZ0UsU0FBUyxHQUFHLEVBQUU7SUFDckI7SUFFQUMsUUFBUTtRQUNOLElBQUksQ0FBQ0QsU0FBUyxHQUFHLEVBQUU7SUFDckI7SUFFQUUsV0FBV25KLEtBQUssRUFBRUMsTUFBTSxFQUFFO1FBQ3hCLElBQUksQ0FBQ2dKLFNBQVMsQ0FBQ0csSUFBSSxDQUFDO1lBQ2xCcEo7WUFDQUM7UUFDRjtJQUNGO0lBRUFvSixnQkFBZ0I7UUFDZCxJQUFJLENBQUNKLFNBQVMsQ0FBQ0ssR0FBRztJQUNwQjtJQUVBQyxhQUFhO1FBQ1gsSUFBSSxFQUNGTixTQUFTLEVBQ1YsR0FBRyxJQUFJO1FBQ1IsT0FBT0EsU0FBUyxDQUFDQSxVQUFVeEosTUFBTSxHQUFHLEVBQUU7SUFDeEM7SUFFQSxJQUFJTyxRQUFRO1FBQ1YsT0FBTyxJQUFJLENBQUN1SixVQUFVLEdBQUd2SixLQUFLO0lBQ2hDO0lBRUEsSUFBSUMsU0FBUztRQUNYLE9BQU8sSUFBSSxDQUFDc0osVUFBVSxHQUFHdEosTUFBTTtJQUNqQztJQUVBc0gsWUFBWWlDLENBQUMsRUFBRTtRQUNiLElBQUksT0FBT0EsTUFBTSxVQUFVO1lBQ3pCLE9BQU9BO1FBQ1Q7UUFFQSxJQUFJQSxNQUFNLEtBQUs7WUFDYixPQUFPLElBQUksQ0FBQ3hKLEtBQUs7UUFDbkI7UUFFQSxJQUFJd0osTUFBTSxLQUFLO1lBQ2IsT0FBTyxJQUFJLENBQUN2SixNQUFNO1FBQ3BCO1FBRUEsT0FBTzZDLEtBQUtvQixJQUFJLENBQUNwQixLQUFLcUIsR0FBRyxDQUFDLElBQUksQ0FBQ25FLEtBQUssRUFBRSxLQUFLOEMsS0FBS3FCLEdBQUcsQ0FBQyxJQUFJLENBQUNsRSxNQUFNLEVBQUUsTUFBTTZDLEtBQUtvQixJQUFJLENBQUM7SUFDbkY7QUFFRjtBQUVBLE1BQU11RjtJQUNKeEUsWUFBWXlFLENBQUMsRUFBRUMsQ0FBQyxDQUFFO1FBQ2hCLElBQUksQ0FBQ0QsQ0FBQyxHQUFHQTtRQUNULElBQUksQ0FBQ0MsQ0FBQyxHQUFHQTtJQUNYO0lBRUEsT0FBT0MsTUFBTUMsS0FBSyxFQUFFO1FBQ2xCLElBQUlDLGVBQWV0SyxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRztRQUN2RixJQUFJLENBQUNrSyxJQUFJSSxZQUFZLEVBQUVILElBQUlHLFlBQVksQ0FBQyxHQUFHckksVUFBVW9JO1FBQ3JELE9BQU8sSUFBSUosTUFBTUMsR0FBR0M7SUFDdEI7SUFFQSxPQUFPSSxXQUFXQyxLQUFLLEVBQUU7UUFDdkIsSUFBSUYsZUFBZXRLLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3ZGLElBQUksQ0FBQ2tLLElBQUlJLFlBQVksRUFBRUgsSUFBSUQsQ0FBQyxDQUFDLEdBQUdqSSxVQUFVdUk7UUFDMUMsT0FBTyxJQUFJUCxNQUFNQyxHQUFHQztJQUN0QjtJQUVBLE9BQU9NLFVBQVVDLElBQUksRUFBRTtRQUNyQixJQUFJQyxTQUFTMUksVUFBVXlJO1FBQ3ZCLElBQUl4QixNQUFNeUIsT0FBTzFLLE1BQU07UUFDdkIsSUFBSTJLLGFBQWEsRUFBRTtRQUVuQixJQUFLLElBQUl4QixJQUFJLEdBQUdBLElBQUlGLEtBQUtFLEtBQUssRUFBRztZQUMvQndCLFdBQVdoQixJQUFJLENBQUMsSUFBSUssTUFBTVUsTUFBTSxDQUFDdkIsRUFBRSxFQUFFdUIsTUFBTSxDQUFDdkIsSUFBSSxFQUFFO1FBQ3BEO1FBRUEsT0FBT3dCO0lBQ1Q7SUFFQUMsUUFBUVIsS0FBSyxFQUFFO1FBQ2IsT0FBTy9HLEtBQUt3SCxLQUFLLENBQUNULE1BQU1GLENBQUMsR0FBRyxJQUFJLENBQUNBLENBQUMsRUFBRUUsTUFBTUgsQ0FBQyxHQUFHLElBQUksQ0FBQ0EsQ0FBQztJQUN0RDtJQUVBYSxlQUFlQyxTQUFTLEVBQUU7UUFDeEIsSUFBSSxFQUNGZCxDQUFDLEVBQ0RDLENBQUMsRUFDRixHQUFHLElBQUk7UUFDUixJQUFJYyxLQUFLZixJQUFJYyxTQUFTLENBQUMsRUFBRSxHQUFHYixJQUFJYSxTQUFTLENBQUMsRUFBRSxHQUFHQSxTQUFTLENBQUMsRUFBRTtRQUMzRCxJQUFJRSxLQUFLaEIsSUFBSWMsU0FBUyxDQUFDLEVBQUUsR0FBR2IsSUFBSWEsU0FBUyxDQUFDLEVBQUUsR0FBR0EsU0FBUyxDQUFDLEVBQUU7UUFDM0QsSUFBSSxDQUFDZCxDQUFDLEdBQUdlO1FBQ1QsSUFBSSxDQUFDZCxDQUFDLEdBQUdlO0lBQ1g7QUFFRjtBQUVBLE1BQU1DO0lBQ0oxRixZQUFZb0MsTUFBTSxDQUFFO1FBQ2xCLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ3VELE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0MsTUFBTSxHQUFHLEVBQUU7UUFDaEIsSUFBSSxDQUFDQyxhQUFhLEdBQUcsRUFBRSxFQUFFLG1FQUFtRTtRQUU1RixJQUFJLENBQUNDLE9BQU8sR0FBRyxJQUFJLENBQUNBLE9BQU8sQ0FBQ0MsSUFBSSxDQUFDLElBQUksR0FBRyxtRUFBbUU7UUFFM0csSUFBSSxDQUFDQyxXQUFXLEdBQUcsSUFBSSxDQUFDQSxXQUFXLENBQUNELElBQUksQ0FBQyxJQUFJO0lBQy9DO0lBRUFFLFlBQVk7UUFDVixPQUFPLElBQUksQ0FBQ04sT0FBTztJQUNyQjtJQUVBTyxRQUFRO1FBQ04sSUFBSSxJQUFJLENBQUNQLE9BQU8sRUFBRTtZQUNoQjtRQUNGO1FBRUEsSUFBSSxFQUNGdkQsTUFBTSxFQUNOMEQsT0FBTyxFQUNQRSxXQUFXLEVBQ1osR0FBRyxJQUFJO1FBQ1IsSUFBSW5LLFNBQVN1RyxPQUFPYSxHQUFHLENBQUNwSCxNQUFNO1FBQzlCQSxPQUFPc0ssT0FBTyxHQUFHTDtRQUNqQmpLLE9BQU91SyxXQUFXLEdBQUdKO1FBQ3JCLElBQUksQ0FBQ0wsT0FBTyxHQUFHO0lBQ2pCO0lBRUFVLE9BQU87UUFDTCxJQUFJLENBQUMsSUFBSSxDQUFDVixPQUFPLEVBQUU7WUFDakI7UUFDRjtRQUVBLElBQUk5SixTQUFTLElBQUksQ0FBQ3VHLE1BQU0sQ0FBQ2EsR0FBRyxDQUFDcEgsTUFBTTtRQUNuQyxJQUFJLENBQUM4SixPQUFPLEdBQUc7UUFDZjlKLE9BQU9zSyxPQUFPLEdBQUc7UUFDakJ0SyxPQUFPdUssV0FBVyxHQUFHO0lBQ3ZCO0lBRUFFLFlBQVk7UUFDVixPQUFPLElBQUksQ0FBQ1gsT0FBTyxJQUFJLElBQUksQ0FBQ0MsTUFBTSxDQUFDcEwsTUFBTSxHQUFHO0lBQzlDO0lBRUErTCxZQUFZO1FBQ1YsSUFBSSxDQUFDLElBQUksQ0FBQ1osT0FBTyxFQUFFO1lBQ2pCO1FBQ0Y7UUFFQSxJQUFJLEVBQ0Z2RCxRQUFRbkMsU0FBUSxFQUNoQjJGLE1BQU0sRUFDTkMsYUFBYSxFQUNkLEdBQUcsSUFBSTtRQUNSLElBQUksRUFDRlcsS0FBSyxFQUNOLEdBQUd2RyxVQUFTZ0QsR0FBRyxDQUFDcEgsTUFBTTtRQUV2QixJQUFJMkssT0FBTztZQUNUQSxNQUFNQyxNQUFNLEdBQUc7UUFDakI7UUFFQWIsT0FBT2MsT0FBTyxDQUFDLENBQUM5SyxNQUFNK0g7WUFDcEIsSUFBSSxFQUNGZ0QsR0FBRyxFQUNKLEdBQUcvSztZQUNKLElBQUlrSCxVQUFVK0MsYUFBYSxDQUFDbEMsRUFBRTtZQUU5QixNQUFPYixRQUFTO2dCQUNkNkQsSUFBSTdEO2dCQUNKQSxVQUFVQSxRQUFROEQsTUFBTTtZQUMxQjtRQUNGLElBQUksc0JBQXNCO1FBRTFCLElBQUksQ0FBQ2hCLE1BQU0sR0FBRyxFQUFFO1FBQ2hCLElBQUksQ0FBQ0MsYUFBYSxHQUFHLEVBQUU7SUFDekI7SUFFQWdCLFVBQVUvRCxPQUFPLEVBQUVHLEdBQUcsRUFBRTtRQUN0QixJQUFJLENBQUMsSUFBSSxDQUFDMEMsT0FBTyxJQUFJLENBQUMxQyxLQUFLO1lBQ3pCO1FBQ0Y7UUFFQSxJQUFJLEVBQ0YyQyxNQUFNLEVBQ05DLGFBQWEsRUFDZCxHQUFHLElBQUk7UUFDUkQsT0FBT2MsT0FBTyxDQUFDLENBQUNJLE9BQU9uRDtZQUNyQixJQUFJLEVBQ0ZjLENBQUMsRUFDREMsQ0FBQyxFQUNGLEdBQUdvQztZQUVKLElBQUksQ0FBQ2pCLGFBQWEsQ0FBQ2xDLEVBQUUsSUFBSVYsSUFBSThELGFBQWEsSUFBSTlELElBQUk4RCxhQUFhLENBQUN0QyxHQUFHQyxJQUFJO2dCQUNyRW1CLGFBQWEsQ0FBQ2xDLEVBQUUsR0FBR2I7WUFDckI7UUFDRjtJQUNGO0lBRUFrRSxpQkFBaUJsRSxPQUFPLEVBQUVtRSxXQUFXLEVBQUU7UUFDckMsSUFBSSxDQUFDLElBQUksQ0FBQ3RCLE9BQU8sSUFBSSxDQUFDc0IsYUFBYTtZQUNqQztRQUNGO1FBRUEsSUFBSSxFQUNGckIsTUFBTSxFQUNOQyxhQUFhLEVBQ2QsR0FBRyxJQUFJO1FBQ1JELE9BQU9jLE9BQU8sQ0FBQyxDQUFDUSxPQUFPdkQ7WUFDckIsSUFBSSxFQUNGYyxDQUFDLEVBQ0RDLENBQUMsRUFDRixHQUFHd0M7WUFFSixJQUFJLENBQUNyQixhQUFhLENBQUNsQyxFQUFFLElBQUlzRCxZQUFZRSxZQUFZLENBQUMxQyxHQUFHQyxJQUFJO2dCQUN2RG1CLGFBQWEsQ0FBQ2xDLEVBQUUsR0FBR2I7WUFDckI7UUFDRjtJQUNGO0lBRUFzRSxNQUFNM0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDVixJQUFJLEVBQ0YvSixRQUFBQSxPQUFNLEVBQ05zSSxHQUFHLEVBQ0osR0FBRyxJQUFJLENBQUNiLE1BQU07UUFDZixJQUFJd0MsUUFBUSxJQUFJSixNQUFNQyxHQUFHQztRQUN6QixJQUFJNUIsVUFBVUcsSUFBSXBILE1BQU07UUFFeEIsTUFBT2lILFFBQVM7WUFDZDhCLE1BQU1ILENBQUMsSUFBSTNCLFFBQVF1RSxVQUFVO1lBQzdCekMsTUFBTUYsQ0FBQyxJQUFJNUIsUUFBUXdFLFNBQVM7WUFDNUJ4RSxVQUFVQSxRQUFReUUsWUFBWTtRQUNoQztRQUVBLElBQUk1TSxRQUFPNk0sT0FBTyxFQUFFO1lBQ2xCNUMsTUFBTUgsQ0FBQyxJQUFJOUosUUFBTzZNLE9BQU87UUFDM0I7UUFFQSxJQUFJN00sUUFBTzhNLE9BQU8sRUFBRTtZQUNsQjdDLE1BQU1GLENBQUMsSUFBSS9KLFFBQU84TSxPQUFPO1FBQzNCO1FBRUEsT0FBTzdDO0lBQ1Q7SUFFQWtCLFFBQVE0QixLQUFLLEVBQUU7UUFDYixJQUFJLEVBQ0ZqRCxDQUFDLEVBQ0RDLENBQUMsRUFDRixHQUFHLElBQUksQ0FBQzBDLEtBQUssQ0FBQ00sTUFBTUMsT0FBTyxFQUFFRCxNQUFNRSxPQUFPO1FBQzNDLElBQUksQ0FBQ2hDLE1BQU0sQ0FBQ3pCLElBQUksQ0FBQztZQUNmMEQsTUFBTTtZQUNOcEQ7WUFDQUM7WUFFQWlDLEtBQUltQixXQUFXO2dCQUNiLElBQUlBLFlBQVloQyxPQUFPLEVBQUU7b0JBQ3ZCZ0MsWUFBWWhDLE9BQU87Z0JBQ3JCO1lBQ0Y7UUFFRjtJQUNGO0lBRUFFLFlBQVkwQixLQUFLLEVBQUU7UUFDakIsSUFBSSxFQUNGakQsQ0FBQyxFQUNEQyxDQUFDLEVBQ0YsR0FBRyxJQUFJLENBQUMwQyxLQUFLLENBQUNNLE1BQU1DLE9BQU8sRUFBRUQsTUFBTUUsT0FBTztRQUMzQyxJQUFJLENBQUNoQyxNQUFNLENBQUN6QixJQUFJLENBQUM7WUFDZjBELE1BQU07WUFDTnBEO1lBQ0FDO1lBRUFpQyxLQUFJbUIsV0FBVztnQkFDYixJQUFJQSxZQUFZOUIsV0FBVyxFQUFFO29CQUMzQjhCLFlBQVk5QixXQUFXO2dCQUN6QjtZQUNGO1FBRUY7SUFDRjtBQUVGO0FBRUEsSUFBSStCLGdCQUFnQixNQUFrQixHQUFjcE4sQ0FBTUEsR0FBRztBQUM3RCxJQUFJcU4saUJBQWlCLE9BQU8zTSxVQUFVLGNBQWNBLE1BQU0wSyxJQUFJLENBQUN0TCxXQUFXLHdFQUF3RTtHQUNoSjtBQUNGLE1BQU13TjtJQUNKakksWUFBWWlELEdBQUcsQ0FBRTtRQUNmLElBQUksRUFDRjVILE9BQUFBLFNBQVEyTSxjQUFjLEVBQ3RCck4sUUFBQUEsVUFBU29OLGFBQWEsRUFDdkIsR0FBR3hOLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDekUsSUFBSSxDQUFDMEksR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ2lGLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNDLGtCQUFrQixHQUFHO1FBQzFCLElBQUksQ0FBQ0MsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0MsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ2xHLFFBQVEsR0FBRyxJQUFJNEI7UUFDcEIsSUFBSSxDQUFDdUUsS0FBSyxHQUFHLElBQUk1QyxNQUFNLElBQUk7UUFDM0IsSUFBSSxDQUFDNkMsVUFBVSxHQUFHLEVBQUU7UUFDcEIsSUFBSSxDQUFDQyxLQUFLLEdBQUcsRUFBRTtRQUNmLElBQUksQ0FBQ0MsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0MsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0MsVUFBVSxHQUFHO1FBQ2xCLElBQUksQ0FBQ2pPLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNVLEtBQUssR0FBR0E7SUFDZjtJQUVBd04sS0FBS0MsT0FBTyxFQUFFO1FBQ1osSUFBSSxDQUFDTixLQUFLLENBQUNyRSxJQUFJLENBQUMyRTtJQUNsQjtJQUVBQyxRQUFRO1FBQ04sa0VBQWtFO1FBQ2xFLElBQUksQ0FBQyxJQUFJLENBQUNDLFlBQVksRUFBRTtZQUN0QixPQUFPQyxRQUFRQyxPQUFPO1FBQ3hCO1FBRUEsT0FBTyxJQUFJLENBQUNGLFlBQVk7SUFDMUI7SUFFQUcsVUFBVTtRQUNSLElBQUksSUFBSSxDQUFDVCxXQUFXLEVBQUU7WUFDcEIsT0FBTztRQUNUO1FBRUEsSUFBSUEsY0FBYyxJQUFJLENBQUNGLEtBQUssQ0FBQ1ksS0FBSyxDQUFDQyxDQUFBQSxJQUFLQTtRQUV4QyxJQUFJWCxhQUFhO1lBQ2YsSUFBSSxDQUFDRixLQUFLLEdBQUcsRUFBRTtZQUVmLElBQUksSUFBSSxDQUFDYyxZQUFZLEVBQUU7Z0JBQ3JCLElBQUksQ0FBQ0EsWUFBWTtZQUNuQjtRQUNGO1FBRUEsSUFBSSxDQUFDWixXQUFXLEdBQUdBO1FBQ25CLE9BQU9BO0lBQ1Q7SUFFQWEsWUFBWXRHLEdBQUcsRUFBRTtRQUNmLDhCQUE4QjtRQUM5QkEsSUFBSXVHLFdBQVcsR0FBRztRQUNsQnZHLElBQUl3RyxPQUFPLEdBQUc7UUFDZHhHLElBQUl5RyxRQUFRLEdBQUc7UUFDZnpHLElBQUkwRyxVQUFVLEdBQUc7SUFDbkI7SUFFQUMsV0FBV2hPLElBQUksRUFBRTtRQUNmLElBQUksRUFDRnFFLFVBQUFBLFNBQVEsRUFDUmdELEdBQUcsRUFDSDRHLFdBQVcsRUFDWDlPLEtBQUssRUFDTCtPLFlBQVksRUFDWjlPLE1BQU0sRUFDTitPLGFBQWEsRUFDYkMsT0FBTyxDQUFDLEVBQ1JDLE9BQU8sQ0FBQyxFQUNSQyxJQUFJLEVBQ0pDLElBQUksRUFDSkMsT0FBTyxLQUFLLEVBQ1pDLFFBQVEsQ0FBQyxFQUNUQyxRQUFRLENBQUMsRUFDVixHQUFHMU87UUFDSixtRkFBbUY7UUFDbkYsSUFBSTJPLG1CQUFtQnBPLGVBQWUwTixhQUFheE4sT0FBTyxDQUFDLFlBQVksS0FBSyxlQUFlO1FBRTNGLElBQUksQ0FBQ21PLGtCQUFrQkMsdUJBQXVCLEdBQUdGLGlCQUFpQmxLLEtBQUssQ0FBQztRQUN4RSxJQUFJcUssUUFBUUYsb0JBQW9CO1FBQ2hDLElBQUlHLGNBQWNGLDBCQUEwQixRQUFRLGtCQUFrQjtRQUV0RSxJQUFJRyxTQUFTN1AsUUFBUStPO1FBQ3JCLElBQUllLFNBQVM3UCxTQUFTK087UUFDdEIsSUFBSWUsV0FBV2pOLEtBQUt3RSxHQUFHLENBQUN1SSxRQUFRQztRQUNoQyxJQUFJRSxXQUFXbE4sS0FBSzBFLEdBQUcsQ0FBQ3FJLFFBQVFDO1FBQ2hDLElBQUlHLG9CQUFvQmxCO1FBQ3hCLElBQUltQixxQkFBcUJsQjtRQUV6QixJQUFJWSxnQkFBZ0IsUUFBUTtZQUMxQksscUJBQXFCRjtZQUNyQkcsc0JBQXNCSDtRQUN4QjtRQUVBLElBQUlILGdCQUFnQixTQUFTO1lBQzNCSyxxQkFBcUJEO1lBQ3JCRSxzQkFBc0JGO1FBQ3hCO1FBRUEsSUFBSUcsV0FBVyxJQUFJbkwsU0FBU0UsV0FBVSxRQUFRaUs7UUFDOUMsSUFBSWlCLFdBQVcsSUFBSXBMLFNBQVNFLFdBQVUsUUFBUWtLO1FBQzlDLElBQUlpQixVQUFVRixTQUFTekssUUFBUSxNQUFNMEssU0FBUzFLLFFBQVE7UUFFdEQsSUFBSTJLLFNBQVM7WUFDWG5JLElBQUlvSSxTQUFTLENBQUMsQ0FBQ1AsV0FBV0ksU0FBU3BKLFNBQVMsQ0FBQyxNQUFNLENBQUNnSixXQUFXSyxTQUFTckosU0FBUyxDQUFDO1FBQ3BGO1FBRUEsSUFBSXNJLE1BQU07WUFDUixJQUFJa0IsY0FBY1IsV0FBV1Q7WUFDN0IsSUFBSWtCLGNBQWNULFdBQVdSO1lBQzdCckgsSUFBSXVJLFNBQVM7WUFDYnZJLElBQUl3SSxNQUFNLENBQUNILGFBQWFDO1lBQ3hCdEksSUFBSXlJLE1BQU0sQ0FBQzNRLE9BQU93UTtZQUNsQnRJLElBQUl5SSxNQUFNLENBQUMzUSxPQUFPQztZQUNsQmlJLElBQUl5SSxNQUFNLENBQUNKLGFBQWF0UTtZQUN4QmlJLElBQUkwSSxTQUFTO1lBQ2IxSSxJQUFJbUgsSUFBSTtRQUNWO1FBRUEsSUFBSSxDQUFDZ0IsU0FBUztZQUNaLElBQUlRLGFBQWFqQixnQkFBZ0IsVUFBVUcsYUFBYUQ7WUFDeEQsSUFBSWdCLGNBQWNsQixnQkFBZ0IsV0FBV0ksYUFBYUY7WUFDMUQsSUFBSWlCLGFBQWFuQixnQkFBZ0IsVUFBVUcsYUFBYUY7WUFDeEQsSUFBSW1CLGNBQWNwQixnQkFBZ0IsV0FBV0ksYUFBYUg7WUFFMUQsSUFBSUYsTUFBTW5OLFVBQVUsQ0FBQyxXQUFZcU8sQ0FBQUEsY0FBY0MsV0FBVSxHQUFJO2dCQUMzRDVJLElBQUlvSSxTQUFTLENBQUN0USxRQUFRLE1BQU1pUSxvQkFBb0IsS0FBSztZQUN2RDtZQUVBLElBQUlOLE1BQU16SixRQUFRLENBQUMsV0FBWTZLLENBQUFBLGNBQWNDLFdBQVUsR0FBSTtnQkFDekQ5SSxJQUFJb0ksU0FBUyxDQUFDLEdBQUdyUSxTQUFTLE1BQU1pUSxxQkFBcUI7WUFDdkQ7WUFFQSxJQUFJUCxNQUFNbk4sVUFBVSxDQUFDLFdBQVlxTyxDQUFBQSxjQUFjQyxXQUFVLEdBQUk7Z0JBQzNENUksSUFBSW9JLFNBQVMsQ0FBQ3RRLFFBQVFpUSxtQkFBbUI7WUFDM0M7WUFFQSxJQUFJTixNQUFNekosUUFBUSxDQUFDLFdBQVk2SyxDQUFBQSxjQUFjQyxXQUFVLEdBQUk7Z0JBQ3pEOUksSUFBSW9JLFNBQVMsQ0FBQyxHQUFHclEsU0FBU2lRO1lBQzVCO1FBQ0YsRUFBRSxRQUFRO1FBR1YsT0FBUTtZQUNOLEtBQUtQLFVBQVU7Z0JBQ2J6SCxJQUFJOEIsS0FBSyxDQUFDNkYsUUFBUUM7Z0JBQ2xCO1lBRUYsS0FBS0YsZ0JBQWdCO2dCQUNuQjFILElBQUk4QixLQUFLLENBQUMrRixVQUFVQTtnQkFDcEI7WUFFRixLQUFLSCxnQkFBZ0I7Z0JBQ25CMUgsSUFBSThCLEtBQUssQ0FBQ2dHLFVBQVVBO2dCQUNwQjtRQUNKLEVBQUUsWUFBWTtRQUdkOUgsSUFBSW9JLFNBQVMsQ0FBQyxDQUFDckIsTUFBTSxDQUFDQztJQUN4QjtJQUVBL0QsTUFBTXBELE9BQU8sRUFBRTtRQUNiLElBQUksRUFDRmtKLGVBQWUsS0FBSyxFQUNwQm5SLGNBQWMsS0FBSyxFQUNuQkQsa0JBQWtCLEtBQUssRUFDdkJxUixtQkFBbUIsS0FBSyxFQUN4QkMsY0FBYyxLQUFLLEVBQ25CQyxXQUFXLEVBQ1hDLFVBQVUsRUFDVkMsV0FBVyxFQUNYQyxPQUFPLEVBQ1BDLE9BQU8sRUFDUixHQUFHaFMsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUtFLFlBQVlGLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUN6RSxJQUFJLEVBQ0YyTixTQUFTLEVBQ1RJLEtBQUssRUFDTixHQUFHLElBQUk7UUFDUixJQUFJRyxnQkFBZ0IsT0FBT1A7UUFDM0IsSUFBSSxDQUFDTyxhQUFhLEdBQUdBO1FBQ3JCLElBQUksQ0FBQ08sWUFBWSxHQUFHLElBQUlDLFFBQVFDLENBQUFBO1lBQzlCLElBQUksQ0FBQ0ksWUFBWSxHQUFHSjtRQUN0QjtRQUVBLElBQUksSUFBSSxDQUFDQyxPQUFPLElBQUk7WUFDbEIsSUFBSSxDQUFDcUQsTUFBTSxDQUFDMUosU0FBU21KLGtCQUFrQkMsYUFBYUUsWUFBWUMsYUFBYUMsU0FBU0M7UUFDeEY7UUFFQSxJQUFJLENBQUNQLGNBQWM7WUFDakI7UUFDRjtRQUVBLElBQUlTLE1BQU1DLEtBQUtELEdBQUc7UUFDbEIsSUFBSUUsT0FBT0Y7UUFDWCxJQUFJN04sUUFBUTtRQUVaLElBQUlnTyxPQUFPO1lBQ1RILE1BQU1DLEtBQUtELEdBQUc7WUFDZDdOLFFBQVE2TixNQUFNRTtZQUVkLElBQUkvTixTQUFTNkosZUFBZTtnQkFDMUJrRSxPQUFPRixNQUFNN04sUUFBUTZKO2dCQUVyQixJQUFJLElBQUksQ0FBQ29FLFlBQVksQ0FBQ2pTLGlCQUFpQnVSLGNBQWM7b0JBQ25ELElBQUksQ0FBQ0ssTUFBTSxDQUFDMUosU0FBU21KLGtCQUFrQkMsYUFBYUUsWUFBWUMsYUFBYUMsU0FBU0M7b0JBQ3RGakUsTUFBTS9CLFNBQVM7Z0JBQ2pCO1lBQ0Y7WUFFQSxJQUFJLENBQUNxQyxVQUFVLEdBQUc1TyxpQ0FBcUJBLENBQUM0UztRQUMxQztRQUVBLElBQUksQ0FBQy9SLGFBQWE7WUFDaEJ5TixNQUFNcEMsS0FBSztRQUNiO1FBRUEsSUFBSSxDQUFDMEMsVUFBVSxHQUFHNU8saUNBQXFCQSxDQUFDNFM7SUFDMUM7SUFFQXZHLE9BQU87UUFDTCxJQUFJLElBQUksQ0FBQ3VDLFVBQVUsRUFBRTtZQUNuQjVPLHdDQUE0QixDQUFDLElBQUksQ0FBQzRPLFVBQVU7WUFDNUMsSUFBSSxDQUFDQSxVQUFVLEdBQUc7UUFDcEI7UUFFQSxJQUFJLENBQUNOLEtBQUssQ0FBQ2pDLElBQUk7SUFDakI7SUFFQXdHLGFBQWFqUyxlQUFlLEVBQUV1UixXQUFXLEVBQUU7UUFDekMsK0JBQStCO1FBQy9CLElBQUksQ0FBQ3ZSLGlCQUFpQjtZQUNwQixJQUFJLEVBQ0Y2TixhQUFhLEVBQ2QsR0FBRyxJQUFJO1lBQ1IsSUFBSW9FLGVBQWUsSUFBSSxDQUFDdEUsVUFBVSxDQUFDd0UsTUFBTSxDQUFDLENBQUNGLGNBQWNHLFlBQWNBLFVBQVVDLE1BQU0sQ0FBQ3hFLGtCQUFrQm9FLGNBQWM7WUFFeEgsSUFBSUEsY0FBYztnQkFDaEIsT0FBTztZQUNUO1FBQ0YsRUFBRSwyQkFBMkI7UUFHN0IsSUFBSSxPQUFPVixnQkFBZ0IsY0FBY0EsZUFBZTtZQUN0RCxPQUFPO1FBQ1Q7UUFFQSxJQUFJLENBQUMsSUFBSSxDQUFDekQsV0FBVyxJQUFJLElBQUksQ0FBQ1MsT0FBTyxJQUFJO1lBQ3ZDLE9BQU87UUFDVCxFQUFFLGlDQUFpQztRQUduQyxJQUFJLElBQUksQ0FBQ2IsS0FBSyxDQUFDaEMsU0FBUyxJQUFJO1lBQzFCLE9BQU87UUFDVDtRQUVBLE9BQU87SUFDVDtJQUVBa0csT0FBTzFKLE9BQU8sRUFBRW1KLGdCQUFnQixFQUFFQyxXQUFXLEVBQUVFLFVBQVUsRUFBRUMsV0FBVyxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sRUFBRTtRQUN4RixJQUFJLEVBQ0ZuRSxZQUFZLEVBQ1pDLGFBQWEsRUFDYmxHLFFBQVEsRUFDUmMsR0FBRyxFQUNIMEYsYUFBYSxFQUNkLEdBQUcsSUFBSTtRQUNSLElBQUk5TSxTQUFTb0gsSUFBSXBILE1BQU07UUFDdkJzRyxTQUFTOEIsS0FBSztRQUVkLElBQUlwSSxPQUFPZCxLQUFLLElBQUljLE9BQU9iLE1BQU0sRUFBRTtZQUNqQ21ILFNBQVMrQixVQUFVLENBQUNySSxPQUFPZCxLQUFLLEVBQUVjLE9BQU9iLE1BQU07UUFDakQsT0FBTztZQUNMbUgsU0FBUytCLFVBQVUsQ0FBQ2tFLGNBQWNDO1FBQ3BDO1FBRUEsSUFBSTZFLGFBQWFwSyxRQUFRcUssUUFBUSxDQUFDO1FBQ2xDLElBQUlDLGNBQWN0SyxRQUFRcUssUUFBUSxDQUFDO1FBRW5DLElBQUksQ0FBQ2xCLG9CQUFxQnRELENBQUFBLGlCQUFpQixPQUFPeUQsZUFBZSxZQUFZLE9BQU9DLGdCQUFnQixRQUFPLEdBQUk7WUFDN0csa0JBQWtCO1lBQ2xCLElBQUlhLFdBQVd6TSxRQUFRLElBQUk7Z0JBQ3pCNUUsT0FBT2QsS0FBSyxHQUFHbVMsV0FBV3BMLFNBQVMsQ0FBQztnQkFFcEMsSUFBSWpHLE9BQU8ySyxLQUFLLEVBQUU7b0JBQ2hCM0ssT0FBTzJLLEtBQUssQ0FBQ3pMLEtBQUssR0FBRyxHQUFHc1MsTUFBTSxDQUFDeFIsT0FBT2QsS0FBSyxFQUFFO2dCQUMvQztZQUNGO1lBRUEsSUFBSXFTLFlBQVkzTSxRQUFRLElBQUk7Z0JBQzFCNUUsT0FBT2IsTUFBTSxHQUFHb1MsWUFBWXRMLFNBQVMsQ0FBQztnQkFFdEMsSUFBSWpHLE9BQU8ySyxLQUFLLEVBQUU7b0JBQ2hCM0ssT0FBTzJLLEtBQUssQ0FBQ3hMLE1BQU0sR0FBRyxHQUFHcVMsTUFBTSxDQUFDeFIsT0FBT2IsTUFBTSxFQUFFO2dCQUNqRDtZQUNGO1FBQ0Y7UUFFQSxJQUFJc1MsU0FBU3pSLE9BQU8wUixXQUFXLElBQUkxUixPQUFPZCxLQUFLO1FBQy9DLElBQUl5UyxVQUFVM1IsT0FBTzRSLFlBQVksSUFBSTVSLE9BQU9iLE1BQU07UUFFbEQsSUFBSWlSLG9CQUFvQmlCLFdBQVd6TSxRQUFRLE1BQU0yTSxZQUFZM00sUUFBUSxJQUFJO1lBQ3ZFNk0sU0FBU0osV0FBV3BMLFNBQVMsQ0FBQztZQUM5QjBMLFVBQVVKLFlBQVl0TCxTQUFTLENBQUM7UUFDbEM7UUFFQUssU0FBUytCLFVBQVUsQ0FBQ29KLFFBQVFFO1FBRTVCLElBQUksT0FBT2xCLFlBQVksVUFBVTtZQUMvQnhKLFFBQVFPLFlBQVksQ0FBQyxLQUFLLE1BQU1uQyxRQUFRLENBQUNvTDtRQUMzQztRQUVBLElBQUksT0FBT0MsWUFBWSxVQUFVO1lBQy9CekosUUFBUU8sWUFBWSxDQUFDLEtBQUssTUFBTW5DLFFBQVEsQ0FBQ3FMO1FBQzNDO1FBRUEsSUFBSSxPQUFPSCxlQUFlLFlBQVksT0FBT0MsZ0JBQWdCLFVBQVU7WUFDckUsSUFBSXFCLFVBQVVsUixVQUFVc0csUUFBUU8sWUFBWSxDQUFDLFdBQVc5QyxTQUFTO1lBQ2pFLElBQUlvTixTQUFTO1lBQ2IsSUFBSUMsU0FBUztZQUViLElBQUksT0FBT3hCLGVBQWUsVUFBVTtnQkFDbEMsSUFBSXlCLGNBQWMvSyxRQUFRcUssUUFBUSxDQUFDO2dCQUVuQyxJQUFJVSxZQUFZcE4sUUFBUSxJQUFJO29CQUMxQmtOLFNBQVNFLFlBQVkvTCxTQUFTLENBQUMsT0FBT3NLO2dCQUN4QyxPQUFPLElBQUksQ0FBQzBCLE1BQU1KLE9BQU8sQ0FBQyxFQUFFLEdBQUc7b0JBQzdCQyxTQUFTRCxPQUFPLENBQUMsRUFBRSxHQUFHdEI7Z0JBQ3hCO1lBQ0Y7WUFFQSxJQUFJLE9BQU9DLGdCQUFnQixVQUFVO2dCQUNuQyxJQUFJMEIsZUFBZWpMLFFBQVFxSyxRQUFRLENBQUM7Z0JBRXBDLElBQUlZLGFBQWF0TixRQUFRLElBQUk7b0JBQzNCbU4sU0FBU0csYUFBYWpNLFNBQVMsQ0FBQyxPQUFPdUs7Z0JBQ3pDLE9BQU8sSUFBSSxDQUFDeUIsTUFBTUosT0FBTyxDQUFDLEVBQUUsR0FBRztvQkFDN0JFLFNBQVNGLE9BQU8sQ0FBQyxFQUFFLEdBQUdyQjtnQkFDeEI7WUFDRjtZQUVBLElBQUksQ0FBQ3NCLFFBQVE7Z0JBQ1hBLFNBQVNDO1lBQ1g7WUFFQSxJQUFJLENBQUNBLFFBQVE7Z0JBQ1hBLFNBQVNEO1lBQ1g7WUFFQTdLLFFBQVFPLFlBQVksQ0FBQyxTQUFTLE1BQU1uQyxRQUFRLENBQUNrTDtZQUM3Q3RKLFFBQVFPLFlBQVksQ0FBQyxVQUFVLE1BQU1uQyxRQUFRLENBQUNtTDtZQUM5QyxJQUFJMkIsaUJBQWlCbEwsUUFBUXFLLFFBQVEsQ0FBQyxhQUFhLE1BQU07WUFDekRhLGVBQWU5TSxRQUFRLENBQUMsR0FBR21NLE1BQU0sQ0FBQ1csZUFBZXpOLFNBQVMsSUFBSSxXQUFXOE0sTUFBTSxDQUFDLE1BQU1NLFFBQVEsTUFBTU4sTUFBTSxDQUFDLE1BQU1PLFFBQVE7UUFDM0gsRUFBRSxtQkFBbUI7UUFHckIsSUFBSSxDQUFDMUIsYUFBYTtZQUNoQmpKLElBQUlnTCxTQUFTLENBQUMsR0FBRyxHQUFHWCxRQUFRRTtRQUM5QjtRQUVBMUssUUFBUTBKLE1BQU0sQ0FBQ3ZKO1FBRWYsSUFBSTBGLGVBQWU7WUFDakIsSUFBSSxDQUFDQSxhQUFhLEdBQUc7UUFDdkI7SUFDRjtBQUVGO0FBQ0FWLE9BQU9GLGFBQWEsR0FBR0E7QUFDdkJFLE9BQU9pRyxZQUFZLEdBQUdsRztBQUV0QixJQUFJLEVBQ0ZrRyxZQUFZLEVBQ2IsR0FBR2pHO0FBQ0osSUFBSWtHLG1CQUFtQixPQUFPOVQsY0FBYyxjQUFjQSxZQUFZO0FBQ3RFLE1BQU0rVDtJQUNKcE8sYUFBYztRQUNaLElBQUksRUFDRjNFLE9BQUFBLFNBQVE2UyxZQUFZLEVBQ3BCN1QsV0FBQUEsYUFBWThULGdCQUFnQixFQUM3QixHQUFHNVQsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUtFLFlBQVlGLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUN6RSxJQUFJLENBQUNjLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNoQixTQUFTLEdBQUdBO0lBQ25CO0lBRUFzSyxNQUFNMEosUUFBUSxFQUFFO1FBQ2QsSUFBSUMsUUFBUSxJQUFJO1FBRWhCLE9BQU94VSxvRUFBaUJBLENBQUM7WUFDdkIsSUFBSXVVLFNBQVM5USxVQUFVLENBQUMsTUFBTTtnQkFDNUIsT0FBTytRLE1BQU1DLGVBQWUsQ0FBQ0Y7WUFDL0I7WUFFQSxPQUFPQyxNQUFNRSxJQUFJLENBQUNIO1FBQ3BCO0lBQ0Y7SUFFQUUsZ0JBQWdCRSxHQUFHLEVBQUU7UUFDbkIsSUFBSUMsU0FBUyxJQUFJLElBQUksQ0FBQ3JVLFNBQVM7UUFFL0IsSUFBSTtZQUNGLE9BQU8sSUFBSSxDQUFDc1UsYUFBYSxDQUFDRCxPQUFPSCxlQUFlLENBQUNFLEtBQUs7UUFDeEQsRUFBRSxPQUFPRyxLQUFLO1lBQ1osT0FBTyxJQUFJLENBQUNELGFBQWEsQ0FBQ0QsT0FBT0gsZUFBZSxDQUFDRSxLQUFLO1FBQ3hEO0lBQ0Y7SUFFQUUsY0FBYzFPLFNBQVEsRUFBRTtRQUN0QixJQUFJNE8sY0FBYzVPLFVBQVM2TyxvQkFBb0IsQ0FBQyxjQUFjLENBQUMsRUFBRTtRQUVqRSxJQUFJRCxhQUFhO1lBQ2YsTUFBTSxJQUFJRSxNQUFNRixZQUFZRyxXQUFXO1FBQ3pDO1FBRUEsT0FBTy9PO0lBQ1Q7SUFFQXVPLEtBQUtyVCxHQUFHLEVBQUU7UUFDUixJQUFJOFQsU0FBUyxJQUFJO1FBRWpCLE9BQU9uVixvRUFBaUJBLENBQUM7WUFDdkIsSUFBSXNCLFdBQVcsTUFBTTZULE9BQU81VCxLQUFLLENBQUNGO1lBQ2xDLElBQUlzVCxNQUFNLE1BQU1yVCxTQUFTOFQsSUFBSTtZQUM3QixPQUFPRCxPQUFPVixlQUFlLENBQUNFO1FBQ2hDO0lBQ0Y7QUFFRjtBQUVBLE1BQU1VO0lBQ0puUCxZQUFZcUosQ0FBQyxFQUFFekUsS0FBSyxDQUFFO1FBQ3BCLElBQUksQ0FBQ2lELElBQUksR0FBRztRQUNaLElBQUksQ0FBQ2pELEtBQUssR0FBRztRQUNiLElBQUksQ0FBQ0EsS0FBSyxHQUFHSixNQUFNRyxLQUFLLENBQUNDO0lBQzNCO0lBRUF3SyxNQUFNbk0sR0FBRyxFQUFFO1FBQ1QsSUFBSSxFQUNGd0IsQ0FBQyxFQUNEQyxDQUFDLEVBQ0YsR0FBRyxJQUFJLENBQUNFLEtBQUs7UUFDZDNCLElBQUlvSSxTQUFTLENBQUM1RyxLQUFLLEtBQUtDLEtBQUs7SUFDL0I7SUFFQTJLLFFBQVFwTSxHQUFHLEVBQUU7UUFDWCxJQUFJLEVBQ0Z3QixDQUFDLEVBQ0RDLENBQUMsRUFDRixHQUFHLElBQUksQ0FBQ0UsS0FBSztRQUNkM0IsSUFBSW9JLFNBQVMsQ0FBQyxDQUFDLE1BQU01RyxLQUFLLEtBQUssQ0FBQyxNQUFNQyxLQUFLO0lBQzdDO0lBRUE0SyxhQUFhMUssS0FBSyxFQUFFO1FBQ2xCLElBQUksRUFDRkgsQ0FBQyxFQUNEQyxDQUFDLEVBQ0YsR0FBRyxJQUFJLENBQUNFLEtBQUs7UUFDZEEsTUFBTVUsY0FBYyxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBR2IsS0FBSztZQUFLQyxLQUFLO1NBQUk7SUFDdkQ7QUFFRjtBQUVBLE1BQU02SztJQUNKdlAsWUFBWUMsU0FBUSxFQUFFdVAsTUFBTSxFQUFFQyxlQUFlLENBQUU7UUFDN0MsSUFBSSxDQUFDNUgsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDNkgsS0FBSyxHQUFHO1FBQ2IsSUFBSSxDQUFDQyxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNDLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0MsRUFBRSxHQUFHO1FBQ1YsSUFBSSxDQUFDQyxFQUFFLEdBQUc7UUFDVixJQUFJQyxVQUFVdlQsVUFBVWdUO1FBQ3hCLElBQUksQ0FBQ0UsS0FBSyxHQUFHLElBQUkzUCxTQUFTRSxXQUFVLFNBQVM4UCxPQUFPLENBQUMsRUFBRTtRQUN2RCxJQUFJLENBQUNKLE9BQU8sR0FBR0YsZUFBZSxDQUFDLEVBQUU7UUFDakMsSUFBSSxDQUFDRyxPQUFPLEdBQUdILGVBQWUsQ0FBQyxFQUFFO1FBQ2pDLElBQUksQ0FBQ0ksRUFBRSxHQUFHRSxPQUFPLENBQUMsRUFBRSxJQUFJO1FBQ3hCLElBQUksQ0FBQ0QsRUFBRSxHQUFHQyxPQUFPLENBQUMsRUFBRSxJQUFJO0lBQzFCO0lBRUFYLE1BQU1uTSxHQUFHLEVBQUU7UUFDVCxJQUFJLEVBQ0Y0TSxFQUFFLEVBQ0ZDLEVBQUUsRUFDRkgsT0FBTyxFQUNQQyxPQUFPLEVBQ1BGLEtBQUssRUFDTixHQUFHLElBQUk7UUFDUixJQUFJTSxLQUFLSCxLQUFLRixRQUFRN04sU0FBUyxDQUFDO1FBQ2hDLElBQUltTyxLQUFLSCxLQUFLRixRQUFROU4sU0FBUyxDQUFDO1FBQ2hDbUIsSUFBSW9JLFNBQVMsQ0FBQzJFLElBQUlDO1FBQ2xCaE4sSUFBSXVNLE1BQU0sQ0FBQ0UsTUFBTWpOLFVBQVU7UUFDM0JRLElBQUlvSSxTQUFTLENBQUMsQ0FBQzJFLElBQUksQ0FBQ0M7SUFDdEI7SUFFQVosUUFBUXBNLEdBQUcsRUFBRTtRQUNYLElBQUksRUFDRjRNLEVBQUUsRUFDRkMsRUFBRSxFQUNGSCxPQUFPLEVBQ1BDLE9BQU8sRUFDUEYsS0FBSyxFQUNOLEdBQUcsSUFBSTtRQUNSLElBQUlNLEtBQUtILEtBQUtGLFFBQVE3TixTQUFTLENBQUM7UUFDaEMsSUFBSW1PLEtBQUtILEtBQUtGLFFBQVE5TixTQUFTLENBQUM7UUFDaENtQixJQUFJb0ksU0FBUyxDQUFDMkUsSUFBSUM7UUFDbEJoTixJQUFJdU0sTUFBTSxDQUFDLENBQUMsTUFBTUUsTUFBTWpOLFVBQVU7UUFDbENRLElBQUlvSSxTQUFTLENBQUMsQ0FBQzJFLElBQUksQ0FBQ0M7SUFDdEI7SUFFQVgsYUFBYTFLLEtBQUssRUFBRTtRQUNsQixJQUFJLEVBQ0ZpTCxFQUFFLEVBQ0ZDLEVBQUUsRUFDRkosS0FBSyxFQUNOLEdBQUcsSUFBSTtRQUNSLElBQUlRLE1BQU1SLE1BQU1qTixVQUFVO1FBQzFCbUMsTUFBTVUsY0FBYyxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBR3VLLE1BQU07WUFBS0MsTUFBTSxJQUFJLFdBQVc7U0FDakU7UUFDRGxMLE1BQU1VLGNBQWMsQ0FBQztZQUFDekgsS0FBS3NTLEdBQUcsQ0FBQ0Q7WUFBTXJTLEtBQUt1UyxHQUFHLENBQUNGO1lBQU0sQ0FBQ3JTLEtBQUt1UyxHQUFHLENBQUNGO1lBQU1yUyxLQUFLc1MsR0FBRyxDQUFDRDtZQUFNO1lBQUc7U0FBRTtRQUN4RnRMLE1BQU1VLGNBQWMsQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUcsQ0FBQ3VLLE1BQU07WUFBSyxDQUFDQyxNQUFNLElBQUksWUFBWTtTQUNwRTtJQUNIO0FBRUY7QUFFQSxNQUFNTztJQUNKclEsWUFBWXFKLENBQUMsRUFBRXRFLEtBQUssRUFBRTBLLGVBQWUsQ0FBRTtRQUNyQyxJQUFJLENBQUM1SCxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUM5QyxLQUFLLEdBQUc7UUFDYixJQUFJLENBQUM0SyxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNDLE9BQU8sR0FBRztRQUNmLElBQUlVLFlBQVk5TCxNQUFNTSxVQUFVLENBQUNDLFFBQVEsNkJBQTZCO1FBRXRFLElBQUl1TCxVQUFVN0wsQ0FBQyxLQUFLLEtBQUs2TCxVQUFVNUwsQ0FBQyxLQUFLLEdBQUc7WUFDMUM0TCxVQUFVN0wsQ0FBQyxHQUFHM0Y7WUFDZHdSLFVBQVU1TCxDQUFDLEdBQUc1RjtRQUNoQjtRQUVBLElBQUksQ0FBQ2lHLEtBQUssR0FBR3VMO1FBQ2IsSUFBSSxDQUFDWCxPQUFPLEdBQUdGLGVBQWUsQ0FBQyxFQUFFO1FBQ2pDLElBQUksQ0FBQ0csT0FBTyxHQUFHSCxlQUFlLENBQUMsRUFBRTtJQUNuQztJQUVBTCxNQUFNbk0sR0FBRyxFQUFFO1FBQ1QsSUFBSSxFQUNGOEIsT0FBTyxFQUNMTixDQUFDLEVBQ0RDLENBQUMsRUFDRixFQUNEaUwsT0FBTyxFQUNQQyxPQUFPLEVBQ1IsR0FBRyxJQUFJO1FBQ1IsSUFBSUksS0FBS0wsUUFBUTdOLFNBQVMsQ0FBQztRQUMzQixJQUFJbU8sS0FBS0wsUUFBUTlOLFNBQVMsQ0FBQztRQUMzQm1CLElBQUlvSSxTQUFTLENBQUMyRSxJQUFJQztRQUNsQmhOLElBQUk4QixLQUFLLENBQUNOLEdBQUdDLEtBQUtEO1FBQ2xCeEIsSUFBSW9JLFNBQVMsQ0FBQyxDQUFDMkUsSUFBSSxDQUFDQztJQUN0QjtJQUVBWixRQUFRcE0sR0FBRyxFQUFFO1FBQ1gsSUFBSSxFQUNGOEIsT0FBTyxFQUNMTixDQUFDLEVBQ0RDLENBQUMsRUFDRixFQUNEaUwsT0FBTyxFQUNQQyxPQUFPLEVBQ1IsR0FBRyxJQUFJO1FBQ1IsSUFBSUksS0FBS0wsUUFBUTdOLFNBQVMsQ0FBQztRQUMzQixJQUFJbU8sS0FBS0wsUUFBUTlOLFNBQVMsQ0FBQztRQUMzQm1CLElBQUlvSSxTQUFTLENBQUMyRSxJQUFJQztRQUNsQmhOLElBQUk4QixLQUFLLENBQUMsTUFBTU4sR0FBRyxNQUFNQyxLQUFLRDtRQUM5QnhCLElBQUlvSSxTQUFTLENBQUMsQ0FBQzJFLElBQUksQ0FBQ0M7SUFDdEI7SUFFQVgsYUFBYTFLLEtBQUssRUFBRTtRQUNsQixJQUFJLEVBQ0ZILENBQUMsRUFDREMsQ0FBQyxFQUNGLEdBQUcsSUFBSSxDQUFDSyxLQUFLO1FBQ2RILE1BQU1VLGNBQWMsQ0FBQztZQUFDYixLQUFLO1lBQUs7WUFBRztZQUFHQyxLQUFLO1lBQUs7WUFBRztTQUFFO0lBQ3ZEO0FBRUY7QUFFQSxNQUFNNkw7SUFDSnZRLFlBQVlxSixDQUFDLEVBQUVtSCxNQUFNLEVBQUVmLGVBQWUsQ0FBRTtRQUN0QyxJQUFJLENBQUM1SCxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUMySSxNQUFNLEdBQUcsRUFBRTtRQUNoQixJQUFJLENBQUNiLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0MsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDWSxNQUFNLEdBQUdoVSxVQUFVZ1U7UUFDeEIsSUFBSSxDQUFDYixPQUFPLEdBQUdGLGVBQWUsQ0FBQyxFQUFFO1FBQ2pDLElBQUksQ0FBQ0csT0FBTyxHQUFHSCxlQUFlLENBQUMsRUFBRTtJQUNuQztJQUVBTCxNQUFNbk0sR0FBRyxFQUFFO1FBQ1QsSUFBSSxFQUNGME0sT0FBTyxFQUNQQyxPQUFPLEVBQ1BZLE1BQU0sRUFDUCxHQUFHLElBQUk7UUFDUixJQUFJUixLQUFLTCxRQUFRN04sU0FBUyxDQUFDO1FBQzNCLElBQUltTyxLQUFLTCxRQUFROU4sU0FBUyxDQUFDO1FBQzNCbUIsSUFBSW9JLFNBQVMsQ0FBQzJFLElBQUlDO1FBQ2xCaE4sSUFBSXNDLFNBQVMsQ0FBQ2lMLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFO1FBQzlFdk4sSUFBSW9JLFNBQVMsQ0FBQyxDQUFDMkUsSUFBSSxDQUFDQztJQUN0QjtJQUVBWixRQUFRcE0sR0FBRyxFQUFFO1FBQ1gsSUFBSSxFQUNGME0sT0FBTyxFQUNQQyxPQUFPLEVBQ1BZLE1BQU0sRUFDUCxHQUFHLElBQUk7UUFDUixJQUFJQyxJQUFJRCxNQUFNLENBQUMsRUFBRTtRQUNqQixJQUFJRSxJQUFJRixNQUFNLENBQUMsRUFBRTtRQUNqQixJQUFJRyxJQUFJSCxNQUFNLENBQUMsRUFBRTtRQUNqQixJQUFJak0sSUFBSWlNLE1BQU0sQ0FBQyxFQUFFO1FBQ2pCLElBQUlJLElBQUlKLE1BQU0sQ0FBQyxFQUFFO1FBQ2pCLElBQUlLLElBQUlMLE1BQU0sQ0FBQyxFQUFFO1FBQ2pCLElBQUlNLElBQUk7UUFDUixJQUFJQyxJQUFJO1FBQ1IsSUFBSXBOLElBQUk7UUFDUixJQUFJcU4sTUFBTSxJQUFLUCxDQUFBQSxJQUFLRyxDQUFBQSxJQUFJak4sSUFBSWtOLElBQUlFLENBQUFBLElBQUtMLElBQUtuTSxDQUFBQSxJQUFJWixJQUFJa04sSUFBSUMsQ0FBQUEsSUFBS0gsSUFBS3BNLENBQUFBLElBQUl3TSxJQUFJSCxJQUFJRSxDQUFBQSxDQUFDO1FBQzdFLElBQUlkLEtBQUtMLFFBQVE3TixTQUFTLENBQUM7UUFDM0IsSUFBSW1PLEtBQUtMLFFBQVE5TixTQUFTLENBQUM7UUFDM0JtQixJQUFJb0ksU0FBUyxDQUFDMkUsSUFBSUM7UUFDbEJoTixJQUFJc0MsU0FBUyxDQUFDeUwsTUFBT0osQ0FBQUEsSUFBSWpOLElBQUlrTixJQUFJRSxDQUFBQSxHQUFJQyxNQUFPSCxDQUFBQSxJQUFJQyxJQUFJdk0sSUFBSVosQ0FBQUEsR0FBSXFOLE1BQU9MLENBQUFBLElBQUlJLElBQUlMLElBQUkvTSxDQUFBQSxHQUFJcU4sTUFBT1AsQ0FBQUEsSUFBSTlNLElBQUlnTixJQUFJRyxDQUFBQSxHQUFJRSxNQUFPTixDQUFBQSxJQUFJRyxJQUFJRixJQUFJQyxDQUFBQSxHQUFJSSxNQUFPTCxDQUFBQSxJQUFJcE0sSUFBSWtNLElBQUlJLENBQUFBO1FBQ3BKNU4sSUFBSW9JLFNBQVMsQ0FBQyxDQUFDMkUsSUFBSSxDQUFDQztJQUN0QjtJQUVBWCxhQUFhMUssS0FBSyxFQUFFO1FBQ2xCQSxNQUFNVSxjQUFjLENBQUMsSUFBSSxDQUFDa0wsTUFBTTtJQUNsQztBQUVGO0FBRUEsTUFBTVMsYUFBYVY7SUFDakJ2USxZQUFZQyxTQUFRLEVBQUVpUixJQUFJLEVBQUV6QixlQUFlLENBQUU7UUFDM0MsS0FBSyxDQUFDeFAsV0FBVWlSLE1BQU16QjtRQUN0QixJQUFJLENBQUM1SCxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUM2SCxLQUFLLEdBQUc7UUFDYixJQUFJLENBQUNBLEtBQUssR0FBRyxJQUFJM1AsU0FBU0UsV0FBVSxTQUFTaVI7SUFDL0M7QUFFRjtBQUVBLE1BQU1DLGNBQWNGO0lBQ2xCalIsWUFBWUMsU0FBUSxFQUFFaVIsSUFBSSxFQUFFekIsZUFBZSxDQUFFO1FBQzNDLEtBQUssQ0FBQ3hQLFdBQVVpUixNQUFNekI7UUFDdEIsSUFBSSxDQUFDNUgsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDMkksTUFBTSxHQUFHO1lBQUM7WUFBRztZQUFHM1MsS0FBS3VULEdBQUcsQ0FBQyxJQUFJLENBQUMxQixLQUFLLENBQUNqTixVQUFVO1lBQUs7WUFBRztZQUFHO1NBQUU7SUFDbEU7QUFFRjtBQUVBLE1BQU00TyxjQUFjSjtJQUNsQmpSLFlBQVlDLFNBQVEsRUFBRWlSLElBQUksRUFBRXpCLGVBQWUsQ0FBRTtRQUMzQyxLQUFLLENBQUN4UCxXQUFVaVIsTUFBTXpCO1FBQ3RCLElBQUksQ0FBQzVILElBQUksR0FBRztRQUNaLElBQUksQ0FBQzJJLE1BQU0sR0FBRztZQUFDO1lBQUczUyxLQUFLdVQsR0FBRyxDQUFDLElBQUksQ0FBQzFCLEtBQUssQ0FBQ2pOLFVBQVU7WUFBSztZQUFHO1lBQUc7WUFBRztTQUFFO0lBQ2xFO0FBRUY7QUFFQSxTQUFTNk8sZ0JBQWdCL0wsU0FBUztJQUNoQyxPQUFPcEosZUFBZW9KLFdBQVcvRSxJQUFJLEdBQUduRSxPQUFPLENBQUMsaUJBQWlCLFFBQVFBLE9BQU8sQ0FBQyxnQkFBZ0IsTUFBTWdFLEtBQUssQ0FBQztBQUMvRztBQUVBLFNBQVNrUixlQUFlaE0sU0FBUztJQUMvQixJQUFJLENBQUNzQyxNQUFNM0gsTUFBTSxHQUFHcUYsVUFBVWxGLEtBQUssQ0FBQztJQUNwQyxPQUFPO1FBQUN3SCxLQUFLckgsSUFBSTtRQUFJTixNQUFNTSxJQUFJLEdBQUduRSxPQUFPLENBQUMsS0FBSztLQUFJO0FBQ3JEO0FBRUEsTUFBTW1WO0lBQ0p4UixZQUFZQyxTQUFRLEVBQUVzRixTQUFTLEVBQUVrSyxlQUFlLENBQUU7UUFDaEQsSUFBSSxDQUFDeFAsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUN3UixVQUFVLEdBQUcsRUFBRTtRQUNwQixJQUFJQyxPQUFPSixnQkFBZ0IvTDtRQUMzQm1NLEtBQUtoTCxPQUFPLENBQUNuQixDQUFBQTtZQUNYLElBQUlBLGNBQWMsUUFBUTtnQkFDeEI7WUFDRjtZQUVBLElBQUksQ0FBQ3NDLE1BQU0zSCxNQUFNLEdBQUdxUixlQUFlaE07WUFDbkMsSUFBSW9NLGdCQUFnQkgsVUFBVUksY0FBYyxDQUFDL0osS0FBSztZQUVsRCxJQUFJLE9BQU84SixrQkFBa0IsYUFBYTtnQkFDeEMsSUFBSSxDQUFDRixVQUFVLENBQUN0TixJQUFJLENBQUMsSUFBSXdOLGNBQWMsSUFBSSxDQUFDMVIsUUFBUSxFQUFFQyxPQUFPdVA7WUFDL0Q7UUFDRjtJQUNGO0lBRUEsT0FBT29DLFlBQVk1UixTQUFRLEVBQUU2QyxPQUFPLEVBQUU7UUFDcEMsSUFBSWtMLGlCQUFpQmxMLFFBQVFxSyxRQUFRLENBQUMsYUFBYSxPQUFPO1FBQzFELElBQUksQ0FBQzJFLDBCQUEwQkMsMkJBQTJCRCx3QkFBd0IsQ0FBQyxHQUFHaFAsUUFBUXFLLFFBQVEsQ0FBQyxvQkFBb0IsT0FBTyxNQUFNOU0sS0FBSztRQUM3SSxJQUFJb1Asa0JBQWtCO1lBQUNxQztZQUEwQkM7U0FBeUI7UUFFMUUsSUFBSS9ELGVBQWV2TixRQUFRLElBQUk7WUFDN0IsT0FBTyxJQUFJK1EsVUFBVXZSLFdBQVUrTixlQUFlek4sU0FBUyxJQUFJa1A7UUFDN0Q7UUFFQSxPQUFPO0lBQ1Q7SUFFQUwsTUFBTW5NLEdBQUcsRUFBRTtRQUNULElBQUksRUFDRndPLFVBQVUsRUFDWCxHQUFHLElBQUk7UUFDUixJQUFJaE8sTUFBTWdPLFdBQVdqWCxNQUFNO1FBRTNCLElBQUssSUFBSW1KLElBQUksR0FBR0EsSUFBSUYsS0FBS0UsSUFBSztZQUM1QjhOLFVBQVUsQ0FBQzlOLEVBQUUsQ0FBQ3lMLEtBQUssQ0FBQ25NO1FBQ3RCO0lBQ0Y7SUFFQW9NLFFBQVFwTSxHQUFHLEVBQUU7UUFDWCxJQUFJLEVBQ0Z3TyxVQUFVLEVBQ1gsR0FBRyxJQUFJO1FBQ1IsSUFBSWhPLE1BQU1nTyxXQUFXalgsTUFBTTtRQUUzQixJQUFLLElBQUltSixJQUFJRixNQUFNLEdBQUdFLEtBQUssR0FBR0EsSUFBSztZQUNqQzhOLFVBQVUsQ0FBQzlOLEVBQUUsQ0FBQzBMLE9BQU8sQ0FBQ3BNO1FBQ3hCO0lBQ0Y7SUFHQXFNLGFBQWExSyxLQUFLLEVBQUU7UUFDbEIsSUFBSSxFQUNGNk0sVUFBVSxFQUNYLEdBQUcsSUFBSTtRQUNSLElBQUloTyxNQUFNZ08sV0FBV2pYLE1BQU07UUFFM0IsSUFBSyxJQUFJbUosSUFBSSxHQUFHQSxJQUFJRixLQUFLRSxJQUFLO1lBQzVCOE4sVUFBVSxDQUFDOU4sRUFBRSxDQUFDMkwsWUFBWSxDQUFDMUs7UUFDN0I7SUFDRjtBQUVGO0FBQ0E0TSxVQUFVSSxjQUFjLEdBQUc7SUFDekJ2RyxXQUFXOEQ7SUFDWEssUUFBUUQ7SUFDUnhLLE9BQU9zTDtJQUNQRyxRQUFRRDtJQUNSeUIsT0FBT2I7SUFDUGMsT0FBT1o7QUFDVDtBQUVBLE1BQU1hO0lBQ0psUyxZQUFZQyxTQUFRLEVBQUV0RSxJQUFJLENBQUU7UUFDMUIsSUFBSXdXLG1CQUFtQjVYLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHO1FBQzNGLElBQUksQ0FBQzBGLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDdEUsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ3dXLGdCQUFnQixHQUFHQTtRQUN4QixJQUFJLENBQUNDLFVBQVUsR0FBR3BXLE9BQU9xVyxNQUFNLENBQUM7UUFDaEMsSUFBSSxDQUFDQyxNQUFNLEdBQUd0VyxPQUFPcVcsTUFBTSxDQUFDO1FBQzVCLElBQUksQ0FBQ0UsaUJBQWlCLEdBQUd2VyxPQUFPcVcsTUFBTSxDQUFDO1FBQ3ZDLElBQUksQ0FBQ0csZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ0Msb0JBQW9CLEdBQUc7UUFDNUIsSUFBSSxDQUFDN0wsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDOEwsUUFBUSxHQUFHLEVBQUU7UUFFbEIsSUFBSSxDQUFDL1csUUFBUUEsS0FBS2dYLFFBQVEsS0FBSyxHQUFHO1lBQ2hDLGVBQWU7WUFDZjtRQUNGLEVBQUUsaUJBQWlCO1FBR25CQyxNQUFNQyxJQUFJLENBQUNsWCxLQUFLeVcsVUFBVSxFQUFFMUwsT0FBTyxDQUFDb00sQ0FBQUE7WUFDbEMsSUFBSUMsV0FBV2pXLHVCQUF1QmdXLFVBQVVDLFFBQVE7WUFDeEQsSUFBSSxDQUFDWCxVQUFVLENBQUNXLFNBQVMsR0FBRyxJQUFJaFQsU0FBU0UsV0FBVThTLFVBQVVELFVBQVU1UyxLQUFLO1FBQzlFO1FBQ0EsSUFBSSxDQUFDOFMsNEJBQTRCLElBQUksb0JBQW9CO1FBRXpELElBQUksSUFBSSxDQUFDM1AsWUFBWSxDQUFDLFNBQVM1QyxRQUFRLElBQUk7WUFDekMsSUFBSTZSLFNBQVMsSUFBSSxDQUFDalAsWUFBWSxDQUFDLFNBQVM5QyxTQUFTLEdBQUdGLEtBQUssQ0FBQyxLQUFLMUQsR0FBRyxDQUFDME0sQ0FBQUEsSUFBS0EsRUFBRTdJLElBQUk7WUFDOUU4UixPQUFPNUwsT0FBTyxDQUFDRixDQUFBQTtnQkFDYixJQUFJLENBQUNBLE9BQU87b0JBQ1Y7Z0JBQ0Y7Z0JBRUEsSUFBSSxDQUFDekosTUFBTW1ELE1BQU0sR0FBR3NHLE1BQU1uRyxLQUFLLENBQUMsS0FBSzFELEdBQUcsQ0FBQzBNLENBQUFBLElBQUtBLEVBQUU3SSxJQUFJO2dCQUNwRCxJQUFJLENBQUM4UixNQUFNLENBQUN2VixLQUFLLEdBQUcsSUFBSWdELFNBQVNFLFdBQVVsRCxNQUFNbUQ7WUFDbkQ7UUFDRjtRQUVBLElBQUksRUFDRjBDLFdBQVcsRUFDWixHQUFHM0M7UUFDSixJQUFJZ1QsS0FBSyxJQUFJLENBQUM1UCxZQUFZLENBQUMsT0FBTyxTQUFTO1FBRTNDLElBQUk0UCxHQUFHeFMsUUFBUSxJQUFJO1lBQ2pCLElBQUksQ0FBQ21DLFdBQVcsQ0FBQ3FRLEdBQUcxUyxTQUFTLEdBQUcsRUFBRTtnQkFDaENxQyxXQUFXLENBQUNxUSxHQUFHMVMsU0FBUyxHQUFHLEdBQUcsSUFBSTtZQUNwQztRQUNGO1FBRUFxUyxNQUFNQyxJQUFJLENBQUNsWCxLQUFLdVgsVUFBVSxFQUFFeE0sT0FBTyxDQUFDeU0sQ0FBQUE7WUFDbEMsSUFBSUEsVUFBVVIsUUFBUSxLQUFLLEdBQUc7Z0JBQzVCLElBQUksQ0FBQ1MsUUFBUSxDQUFDRCxZQUFZLGVBQWU7WUFDM0MsT0FBTyxJQUFJaEIsb0JBQXFCZ0IsQ0FBQUEsVUFBVVIsUUFBUSxLQUFLLEtBQUtRLFVBQVVSLFFBQVEsS0FBSyxJQUFJO2dCQUNyRixJQUFJVSxXQUFXcFQsVUFBU3FULGNBQWMsQ0FBQ0g7Z0JBRXZDLElBQUlFLFNBQVNFLE9BQU8sR0FBRy9ZLE1BQU0sR0FBRyxHQUFHO29CQUNqQyxJQUFJLENBQUM0WSxRQUFRLENBQUNDLFdBQVcsWUFBWTtnQkFDdkM7WUFDRjtRQUNGO0lBQ0Y7SUFFQWhRLGFBQWF0RyxJQUFJLEVBQUU7UUFDakIsSUFBSXlXLG9CQUFvQmpaLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHO1FBQzVGLElBQUlrWixPQUFPLElBQUksQ0FBQ3JCLFVBQVUsQ0FBQ3JWLEtBQUs7UUFFaEMsSUFBSSxDQUFDMFcsUUFBUUQsbUJBQW1CO1lBQzlCLElBQUlFLFFBQVEsSUFBSTNULFNBQVMsSUFBSSxDQUFDRSxRQUFRLEVBQUVsRCxNQUFNO1lBRTlDLElBQUksQ0FBQ3FWLFVBQVUsQ0FBQ3JWLEtBQUssR0FBRzJXO1lBQ3hCLE9BQU9BO1FBQ1Q7UUFFQSxPQUFPRCxRQUFRMVQsU0FBU0ssS0FBSyxDQUFDLElBQUksQ0FBQ0gsUUFBUTtJQUM3QztJQUVBa0QsbUJBQW1CO1FBQ2pCLElBQUssSUFBSXdRLE9BQU8sSUFBSSxDQUFDdkIsVUFBVSxDQUFFO1lBQy9CLElBQUl1QixRQUFRLFVBQVVBLElBQUkxUyxRQUFRLENBQUMsVUFBVTtnQkFDM0MsT0FBTyxJQUFJLENBQUNtUixVQUFVLENBQUN1QixJQUFJO1lBQzdCO1FBQ0Y7UUFFQSxPQUFPNVQsU0FBU0ssS0FBSyxDQUFDLElBQUksQ0FBQ0gsUUFBUTtJQUNyQztJQUVBa04sU0FBU3BRLElBQUksRUFBRTtRQUNiLElBQUl5VyxvQkFBb0JqWixVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRztRQUM1RixJQUFJcVosZ0JBQWdCclosVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUtFLFlBQVlGLFNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDeEYsSUFBSWlNLFFBQVEsSUFBSSxDQUFDOEwsTUFBTSxDQUFDdlYsS0FBSztRQUU3QixJQUFJeUosT0FBTztZQUNULE9BQU9BO1FBQ1Q7UUFFQSxJQUFJaU4sT0FBTyxJQUFJLENBQUNwUSxZQUFZLENBQUN0RztRQUU3QixJQUFJMFcsU0FBUyxRQUFRQSxTQUFTLEtBQUssS0FBS0EsS0FBS2hULFFBQVEsSUFBSTtZQUN2RCxJQUFJLENBQUM2UixNQUFNLENBQUN2VixLQUFLLEdBQUcwVyxNQUFNLHlCQUF5QjtZQUVuRCxPQUFPQTtRQUNUO1FBRUEsSUFBSSxDQUFDRyxlQUFlO1lBQ2xCLElBQUksRUFDRmhOLE1BQU0sRUFDUCxHQUFHLElBQUk7WUFFUixJQUFJQSxRQUFRO2dCQUNWLElBQUlpTixjQUFjak4sT0FBT3VHLFFBQVEsQ0FBQ3BRO2dCQUVsQyxJQUFJOFcsZ0JBQWdCLFFBQVFBLGdCQUFnQixLQUFLLEtBQUtBLFlBQVlwVCxRQUFRLElBQUk7b0JBQzVFLE9BQU9vVDtnQkFDVDtZQUNGO1FBQ0Y7UUFFQSxJQUFJTCxtQkFBbUI7WUFDckIsSUFBSU0sU0FBUyxJQUFJL1QsU0FBUyxJQUFJLENBQUNFLFFBQVEsRUFBRWxELE1BQU07WUFFL0MsSUFBSSxDQUFDdVYsTUFBTSxDQUFDdlYsS0FBSyxHQUFHK1c7WUFDcEIsT0FBT0E7UUFDVDtRQUVBLE9BQU90TixTQUFTekcsU0FBU0ssS0FBSyxDQUFDLElBQUksQ0FBQ0gsUUFBUTtJQUM5QztJQUVBdU0sT0FBT3ZKLEdBQUcsRUFBRTtRQUNWLDRCQUE0QjtRQUM1QixpQ0FBaUM7UUFDakMsSUFBSSxJQUFJLENBQUNrSyxRQUFRLENBQUMsV0FBVzVNLFNBQVMsT0FBTyxVQUFVLElBQUksQ0FBQzRNLFFBQVEsQ0FBQyxjQUFjNU0sU0FBUyxPQUFPLFVBQVU7WUFDM0c7UUFDRjtRQUVBMEMsSUFBSThRLElBQUk7UUFFUixJQUFJLElBQUksQ0FBQzVHLFFBQVEsQ0FBQyxRQUFRMU0sUUFBUSxJQUFJO1lBQ3BDLE9BQU87WUFDUCxJQUFJdVQsT0FBTyxJQUFJLENBQUM3RyxRQUFRLENBQUMsUUFBUXhLLGFBQWE7WUFFOUMsSUFBSXFSLE1BQU07Z0JBQ1IsSUFBSSxDQUFDQyxZQUFZLENBQUNoUjtnQkFDbEIrUSxLQUFLNUUsS0FBSyxDQUFDbk0sS0FBSyxJQUFJO1lBQ3RCO1FBQ0YsT0FBTyxJQUFJLElBQUksQ0FBQ2tLLFFBQVEsQ0FBQyxVQUFVaE0sUUFBUSxDQUFDLFlBQVksUUFBUTtZQUM5RCxTQUFTO1lBQ1QsSUFBSStTLFNBQVMsSUFBSSxDQUFDL0csUUFBUSxDQUFDLFVBQVV4SyxhQUFhO1lBRWxELElBQUl1UixRQUFRO2dCQUNWLElBQUksQ0FBQ0QsWUFBWSxDQUFDaFI7Z0JBQ2xCaVIsT0FBTzlFLEtBQUssQ0FBQ25NLEtBQUssSUFBSTtZQUN4QjtRQUNGLE9BQU87WUFDTCxJQUFJLENBQUNrUixVQUFVLENBQUNsUjtZQUNoQixJQUFJLENBQUNtUixjQUFjLENBQUNuUjtZQUNwQixJQUFJLENBQUNvUixZQUFZLENBQUNwUjtRQUNwQjtRQUVBQSxJQUFJcVIsT0FBTztJQUNiO0lBRUFILFdBQVc5SyxDQUFDLEVBQUUsQ0FDZDtJQUVBNEssYUFBYWhSLEdBQUcsRUFBRTtRQUNoQixZQUFZO1FBQ1osSUFBSXNDLFlBQVlpTSxVQUFVSyxXQUFXLENBQUMsSUFBSSxDQUFDNVIsUUFBUSxFQUFFLElBQUk7UUFFekQsSUFBSXNGLFdBQVc7WUFDYkEsVUFBVTZKLEtBQUssQ0FBQ25NO1FBQ2xCLEVBQUUsT0FBTztRQUdULElBQUlzUixvQkFBb0IsSUFBSSxDQUFDcEgsUUFBUSxDQUFDLGFBQWEsT0FBTztRQUUxRCxJQUFJb0gsa0JBQWtCOVQsUUFBUSxJQUFJO1lBQ2hDLElBQUkySixPQUFPbUssa0JBQWtCNVIsYUFBYTtZQUUxQyxJQUFJeUgsTUFBTTtnQkFDUkEsS0FBS2dGLEtBQUssQ0FBQ25NO1lBQ2I7UUFDRjtJQUNGO0lBRUFvUixhQUFhaEwsQ0FBQyxFQUFFLENBQ2hCO0lBRUErSyxlQUFlblIsR0FBRyxFQUFFO1FBQ2xCLElBQUksQ0FBQ3lQLFFBQVEsQ0FBQ2hNLE9BQU8sQ0FBQzhOLENBQUFBO1lBQ3BCQSxNQUFNaEksTUFBTSxDQUFDdko7UUFDZjtJQUNGO0lBRUFtUSxTQUFTRCxTQUFTLEVBQUU7UUFDbEIsSUFBSXFCLFFBQVFyQixxQkFBcUJqQixVQUFVaUIsWUFBWSxJQUFJLENBQUNsVCxRQUFRLENBQUN3VSxhQUFhLENBQUN0QjtRQUNuRnFCLE1BQU01TixNQUFNLEdBQUcsSUFBSTtRQUVuQixJQUFJLENBQUNzTCxRQUFRd0MsZ0JBQWdCLENBQUNDLFFBQVEsQ0FBQ0gsTUFBTTNNLElBQUksR0FBRztZQUNsRCxJQUFJLENBQUM2SyxRQUFRLENBQUN2TyxJQUFJLENBQUNxUTtRQUNyQjtJQUNGO0lBRUFJLGdCQUFnQnJXLFFBQVEsRUFBRTtRQUN4QixJQUFJc1c7UUFFSixJQUFJLEVBQ0ZsWixJQUFJLEVBQ0wsR0FBRyxJQUFJO1FBRVIsSUFBSSxPQUFPQSxLQUFLYyxPQUFPLEtBQUssWUFBWTtZQUN0QyxPQUFPZCxLQUFLYyxPQUFPLENBQUM4QjtRQUN0QjtRQUVBLElBQUl1VyxlQUFlLENBQUNELHFCQUFxQmxaLEtBQUswSCxZQUFZLE1BQU0sUUFBUXdSLHVCQUF1QixLQUFLLElBQUksS0FBSyxJQUFJQSxtQkFBbUJFLElBQUksQ0FBQ3BaLE1BQU07UUFFL0ksSUFBSSxDQUFDbVosZ0JBQWdCQSxpQkFBaUIsSUFBSTtZQUN4QyxPQUFPO1FBQ1Q7UUFFQSxPQUFPQSxhQUFhelUsS0FBSyxDQUFDLEtBQUsyVSxJQUFJLENBQUNDLENBQUFBLGFBQWMsSUFBSTVILE1BQU0sQ0FBQzRILGdCQUFnQjFXO0lBQy9FO0lBRUF5VSwrQkFBK0I7UUFDN0IsSUFBSSxFQUNGVixNQUFNLEVBQ05DLGlCQUFpQixFQUNsQixHQUFHLElBQUksQ0FBQ3RTLFFBQVE7UUFFakIsSUFBSyxJQUFJMUIsWUFBWStULE9BQVE7WUFDM0IsSUFBSSxDQUFDL1QsU0FBU2hCLFVBQVUsQ0FBQyxRQUFRLElBQUksQ0FBQ3FYLGVBQWUsQ0FBQ3JXLFdBQVc7Z0JBQy9ELElBQUlpSSxRQUFROEwsTUFBTSxDQUFDL1QsU0FBUztnQkFDNUIsSUFBSUcsY0FBYzZULGlCQUFpQixDQUFDaFUsU0FBUztnQkFFN0MsSUFBSWlJLE9BQU87b0JBQ1QsSUFBSyxJQUFJekosUUFBUXlKLE1BQU87d0JBQ3RCLElBQUkwTyxzQkFBc0IsSUFBSSxDQUFDM0MsaUJBQWlCLENBQUN4VixLQUFLO3dCQUV0RCxJQUFJLE9BQU9tWSx3QkFBd0IsYUFBYTs0QkFDOUNBLHNCQUFzQjt3QkFDeEI7d0JBRUEsSUFBSXhXLGVBQWV3VyxxQkFBcUI7NEJBQ3RDLElBQUksQ0FBQzVDLE1BQU0sQ0FBQ3ZWLEtBQUssR0FBR3lKLEtBQUssQ0FBQ3pKLEtBQUs7NEJBQy9CLElBQUksQ0FBQ3dWLGlCQUFpQixDQUFDeFYsS0FBSyxHQUFHMkI7d0JBQ2pDO29CQUNGO2dCQUNGO1lBQ0Y7UUFDRjtJQUNGO0lBRUF5VyxhQUFhclMsT0FBTyxFQUFFc1MsWUFBWSxFQUFFO1FBQ2xDLElBQUlDLFlBQVlELGFBQWFySSxNQUFNLENBQUMsQ0FBQ3NJLFdBQVd0WTtZQUM5QyxJQUFJdVksWUFBWXhTLFFBQVFxSyxRQUFRLENBQUNwUTtZQUVqQyxJQUFJLENBQUN1WSxVQUFVN1UsUUFBUSxJQUFJO2dCQUN6QixPQUFPNFU7WUFDVDtZQUVBLElBQUluVixRQUFRb1YsVUFBVS9VLFNBQVM7WUFDL0IrVSxVQUFVcFUsUUFBUSxDQUFDO1lBQ25CLE9BQU87bUJBQUltVTtnQkFBVztvQkFBQ3RZO29CQUFNbUQ7aUJBQU07YUFBQztRQUN0QyxHQUFHLEVBQUU7UUFDTCxPQUFPbVY7SUFDVDtJQUVBRSxjQUFjelMsT0FBTyxFQUFFd1AsTUFBTSxFQUFFO1FBQzdCQSxPQUFPNUwsT0FBTyxDQUFDOUssQ0FBQUE7WUFDYixJQUFJLENBQUNtQixNQUFNbUQsTUFBTSxHQUFHdEU7WUFDcEJrSCxRQUFRcUssUUFBUSxDQUFDcFEsTUFBTSxNQUFNbUUsUUFBUSxDQUFDaEI7UUFDeEM7SUFDRjtJQUVBc1YsZUFBZTtRQUNiLElBQUlDO1FBRUosT0FBTyxDQUFDLENBQUNBLGVBQWUsSUFBSSxDQUFDN08sTUFBTSxNQUFNLFFBQVE2TyxpQkFBaUIsS0FBSyxJQUFJLEtBQUssSUFBSUEsYUFBYS9DLFFBQVEsQ0FBQ2dELE9BQU8sQ0FBQyxJQUFJLE9BQU87SUFDL0g7QUFFRjtBQUNBeEQsUUFBUXdDLGdCQUFnQixHQUFHO0lBQUM7Q0FBUTtBQUVwQyxNQUFNaUIsdUJBQXVCekQ7SUFDM0JsUyxZQUFZQyxTQUFRLEVBQUV0RSxJQUFJLEVBQUV3VyxnQkFBZ0IsQ0FBRTtRQUM1QyxLQUFLLENBQUNsUyxXQUFVdEUsTUFBTXdXO0lBQ3hCO0FBRUY7QUFFQSxTQUFTeUQsZUFBZUMsVUFBVTtJQUNoQyxJQUFJQyxVQUFVRCxXQUFXclYsSUFBSTtJQUM3QixPQUFPLFNBQVN4RCxJQUFJLENBQUM4WSxXQUFXQSxVQUFVLElBQUt6SSxNQUFNLENBQUN5SSxTQUFTO0FBQ2pFO0FBRUEsU0FBU0Msa0JBQWtCRixVQUFVO0lBQ25DLE9BQU8sT0FBT0csWUFBWSxjQUFjSCxhQUFhQSxXQUFXclYsSUFBSSxHQUFHSCxLQUFLLENBQUMsS0FBSzFELEdBQUcsQ0FBQ2laLGdCQUFnQi9XLElBQUksQ0FBQztBQUM3RztBQUNBOzs7O0NBSUMsR0FHRCxTQUFTb1gsaUJBQWlCQyxTQUFTO0lBQ2pDLElBQUksQ0FBQ0EsV0FBVztRQUNkLE9BQU87SUFDVDtJQUVBLElBQUlDLGtCQUFrQkQsVUFBVTFWLElBQUksR0FBR3ZELFdBQVc7SUFFbEQsT0FBUWtaO1FBQ04sS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBT0E7UUFFVDtZQUNFLElBQUkseUJBQXlCblosSUFBSSxDQUFDbVosa0JBQWtCO2dCQUNsRCxPQUFPQTtZQUNUO1lBRUEsT0FBTztJQUNYO0FBQ0Y7QUFDQTs7OztDQUlDLEdBR0QsU0FBU0Msa0JBQWtCQyxVQUFVO0lBQ25DLElBQUksQ0FBQ0EsWUFBWTtRQUNmLE9BQU87SUFDVDtJQUVBLElBQUlDLG1CQUFtQkQsV0FBVzdWLElBQUksR0FBR3ZELFdBQVc7SUFFcEQsT0FBUXFaO1FBQ04sS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU9BO1FBRVQ7WUFDRSxJQUFJLFdBQVd0WixJQUFJLENBQUNzWixtQkFBbUI7Z0JBQ3JDLE9BQU9BO1lBQ1Q7WUFFQSxPQUFPO0lBQ1g7QUFDRjtBQUVBLE1BQU1DO0lBQ0p2VyxZQUFZa1csU0FBUyxFQUFFTSxXQUFXLEVBQUVILFVBQVUsRUFBRUksUUFBUSxFQUFFWixVQUFVLEVBQUVhLE9BQU8sQ0FBRTtRQUM3RSxJQUFJQyxjQUFjRCxVQUFVLE9BQU9BLFlBQVksV0FBV0gsS0FBSzVSLEtBQUssQ0FBQytSLFdBQVdBLFVBQVUsQ0FBQztRQUMzRixJQUFJLENBQUNiLFVBQVUsR0FBR0EsY0FBY2MsWUFBWWQsVUFBVTtRQUN0RCxJQUFJLENBQUNZLFFBQVEsR0FBR0EsWUFBWUUsWUFBWUYsUUFBUTtRQUNoRCxJQUFJLENBQUNQLFNBQVMsR0FBR0EsYUFBYVMsWUFBWVQsU0FBUztRQUNuRCxJQUFJLENBQUNHLFVBQVUsR0FBR0EsY0FBY00sWUFBWU4sVUFBVTtRQUN0RCxJQUFJLENBQUNHLFdBQVcsR0FBR0EsZUFBZUcsWUFBWUgsV0FBVztJQUMzRDtJQUVBLE9BQU83UixRQUFRO1FBQ2IsSUFBSWlTLE9BQU9yYyxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRztRQUMvRSxJQUFJbWMsVUFBVW5jLFVBQVVDLE1BQU0sR0FBRyxJQUFJRCxTQUFTLENBQUMsRUFBRSxHQUFHRTtRQUNwRCxJQUFJeWIsWUFBWTtRQUNoQixJQUFJTSxjQUFjO1FBQ2xCLElBQUlILGFBQWE7UUFDakIsSUFBSUksV0FBVztRQUNmLElBQUlaLGFBQWE7UUFDakIsSUFBSWdCLFFBQVExYSxlQUFleWEsTUFBTXBXLElBQUksR0FBR0gsS0FBSyxDQUFDO1FBQzlDLElBQUl5VyxNQUFNO1lBQ1JMLFVBQVU7WUFDVlAsV0FBVztZQUNYRyxZQUFZO1lBQ1pHLGFBQWE7UUFDZjtRQUNBSyxNQUFNblEsT0FBTyxDQUFDcVEsQ0FBQUE7WUFDWixPQUFRO2dCQUNOLEtBQUssQ0FBQ0QsSUFBSVosU0FBUyxJQUFJSyxLQUFLakUsTUFBTSxDQUFDcUMsUUFBUSxDQUFDb0M7b0JBQzFDLElBQUlBLFNBQVMsV0FBVzt3QkFDdEJiLFlBQVlhO29CQUNkO29CQUVBRCxJQUFJWixTQUFTLEdBQUc7b0JBQ2hCO2dCQUVGLEtBQUssQ0FBQ1ksSUFBSU4sV0FBVyxJQUFJRCxLQUFLUyxRQUFRLENBQUNyQyxRQUFRLENBQUNvQztvQkFDOUMsSUFBSUEsU0FBUyxXQUFXO3dCQUN0QlAsY0FBY087b0JBQ2hCO29CQUVBRCxJQUFJWixTQUFTLEdBQUc7b0JBQ2hCWSxJQUFJTixXQUFXLEdBQUc7b0JBQ2xCO2dCQUVGLEtBQUssQ0FBQ00sSUFBSVQsVUFBVSxJQUFJRSxLQUFLVSxPQUFPLENBQUN0QyxRQUFRLENBQUNvQztvQkFDNUMsSUFBSUEsU0FBUyxXQUFXO3dCQUN0QlYsYUFBYVU7b0JBQ2Y7b0JBRUFELElBQUlaLFNBQVMsR0FBRztvQkFDaEJZLElBQUlOLFdBQVcsR0FBRztvQkFDbEJNLElBQUlULFVBQVUsR0FBRztvQkFDakI7Z0JBRUYsS0FBSyxDQUFDUyxJQUFJTCxRQUFRO29CQUNoQixJQUFJTSxTQUFTLFdBQVc7d0JBQ3RCLENBQUNOLFNBQVMsR0FBR00sS0FBSzFXLEtBQUssQ0FBQztvQkFDMUI7b0JBRUF5VyxJQUFJWixTQUFTLEdBQUc7b0JBQ2hCWSxJQUFJTixXQUFXLEdBQUc7b0JBQ2xCTSxJQUFJVCxVQUFVLEdBQUc7b0JBQ2pCUyxJQUFJTCxRQUFRLEdBQUc7b0JBQ2Y7Z0JBRUY7b0JBQ0UsSUFBSU0sU0FBUyxXQUFXO3dCQUN0QmxCLGNBQWNrQjtvQkFDaEI7WUFFSjtRQUNGO1FBQ0EsT0FBTyxJQUFJUixLQUFLTCxXQUFXTSxhQUFhSCxZQUFZSSxVQUFVWixZQUFZYTtJQUM1RTtJQUVBUSxXQUFXO1FBQ1QsT0FBTztZQUFDakIsaUJBQWlCLElBQUksQ0FBQ0MsU0FBUztZQUFHLElBQUksQ0FBQ00sV0FBVztZQUFFSixrQkFBa0IsSUFBSSxDQUFDQyxVQUFVO1lBQUcsSUFBSSxDQUFDSSxRQUFRO1lBQzdHVixrQkFBa0IsSUFBSSxDQUFDRixVQUFVO1NBQUUsQ0FBQ2hYLElBQUksQ0FBQyxLQUFLMkIsSUFBSTtJQUNwRDtBQUVGO0FBQ0ErVixLQUFLakUsTUFBTSxHQUFHO0FBQ2RpRSxLQUFLUyxRQUFRLEdBQUc7QUFDaEJULEtBQUtVLE9BQU8sR0FBRztBQUVmLE1BQU1FO0lBQ0puWCxhQUFjO1FBQ1osSUFBSW9YLEtBQUs3YyxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRzhjLE9BQU9DLEdBQUc7UUFDdkYsSUFBSUMsS0FBS2hkLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHOGMsT0FBT0MsR0FBRztRQUN2RixJQUFJRSxLQUFLamQsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUtFLFlBQVlGLFNBQVMsQ0FBQyxFQUFFLEdBQUc4YyxPQUFPQyxHQUFHO1FBQ3ZGLElBQUlHLEtBQUtsZCxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRzhjLE9BQU9DLEdBQUc7UUFDdkYsSUFBSSxDQUFDRixFQUFFLEdBQUdBO1FBQ1YsSUFBSSxDQUFDRyxFQUFFLEdBQUdBO1FBQ1YsSUFBSSxDQUFDQyxFQUFFLEdBQUdBO1FBQ1YsSUFBSSxDQUFDQyxFQUFFLEdBQUdBO1FBQ1YsSUFBSSxDQUFDQyxRQUFRLENBQUNOLElBQUlHO1FBQ2xCLElBQUksQ0FBQ0csUUFBUSxDQUFDRixJQUFJQztJQUNwQjtJQUVBLElBQUloVCxJQUFJO1FBQ04sT0FBTyxJQUFJLENBQUMyUyxFQUFFO0lBQ2hCO0lBRUEsSUFBSTFTLElBQUk7UUFDTixPQUFPLElBQUksQ0FBQzZTLEVBQUU7SUFDaEI7SUFFQSxJQUFJeGMsUUFBUTtRQUNWLE9BQU8sSUFBSSxDQUFDeWMsRUFBRSxHQUFHLElBQUksQ0FBQ0osRUFBRTtJQUMxQjtJQUVBLElBQUlwYyxTQUFTO1FBQ1gsT0FBTyxJQUFJLENBQUN5YyxFQUFFLEdBQUcsSUFBSSxDQUFDRixFQUFFO0lBQzFCO0lBRUFHLFNBQVNqVCxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNiLElBQUksT0FBT0QsTUFBTSxhQUFhO1lBQzVCLElBQUlxSixNQUFNLElBQUksQ0FBQ3NKLEVBQUUsS0FBS3RKLE1BQU0sSUFBSSxDQUFDMEosRUFBRSxHQUFHO2dCQUNwQyxJQUFJLENBQUNKLEVBQUUsR0FBRzNTO2dCQUNWLElBQUksQ0FBQytTLEVBQUUsR0FBRy9TO1lBQ1o7WUFFQSxJQUFJQSxJQUFJLElBQUksQ0FBQzJTLEVBQUUsRUFBRTtnQkFDZixJQUFJLENBQUNBLEVBQUUsR0FBRzNTO1lBQ1o7WUFFQSxJQUFJQSxJQUFJLElBQUksQ0FBQytTLEVBQUUsRUFBRTtnQkFDZixJQUFJLENBQUNBLEVBQUUsR0FBRy9TO1lBQ1o7UUFDRjtRQUVBLElBQUksT0FBT0MsTUFBTSxhQUFhO1lBQzVCLElBQUlvSixNQUFNLElBQUksQ0FBQ3lKLEVBQUUsS0FBS3pKLE1BQU0sSUFBSSxDQUFDMkosRUFBRSxHQUFHO2dCQUNwQyxJQUFJLENBQUNGLEVBQUUsR0FBRzdTO2dCQUNWLElBQUksQ0FBQytTLEVBQUUsR0FBRy9TO1lBQ1o7WUFFQSxJQUFJQSxJQUFJLElBQUksQ0FBQzZTLEVBQUUsRUFBRTtnQkFDZixJQUFJLENBQUNBLEVBQUUsR0FBRzdTO1lBQ1o7WUFFQSxJQUFJQSxJQUFJLElBQUksQ0FBQytTLEVBQUUsRUFBRTtnQkFDZixJQUFJLENBQUNBLEVBQUUsR0FBRy9TO1lBQ1o7UUFDRjtJQUNGO0lBRUFpVCxLQUFLbFQsQ0FBQyxFQUFFO1FBQ04sSUFBSSxDQUFDaVQsUUFBUSxDQUFDalQsR0FBRztJQUNuQjtJQUVBbVQsS0FBS2xULENBQUMsRUFBRTtRQUNOLElBQUksQ0FBQ2dULFFBQVEsQ0FBQyxNQUFNaFQ7SUFDdEI7SUFFQW1ULGVBQWU1USxXQUFXLEVBQUU7UUFDMUIsSUFBSSxDQUFDQSxhQUFhO1lBQ2hCO1FBQ0Y7UUFFQSxJQUFJLEVBQ0ZtUSxFQUFFLEVBQ0ZHLEVBQUUsRUFDRkMsRUFBRSxFQUNGQyxFQUFFLEVBQ0gsR0FBR3hRO1FBQ0osSUFBSSxDQUFDeVEsUUFBUSxDQUFDTixJQUFJRztRQUNsQixJQUFJLENBQUNHLFFBQVEsQ0FBQ0YsSUFBSUM7SUFDcEI7SUFFQUssU0FBU3RZLENBQUMsRUFBRXVZLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRTtRQUMxQixPQUFPcmEsS0FBS3FCLEdBQUcsQ0FBQyxJQUFJTSxHQUFHLEtBQUt1WSxLQUFLLElBQUlsYSxLQUFLcUIsR0FBRyxDQUFDLElBQUlNLEdBQUcsS0FBS0EsSUFBSXdZLEtBQUssSUFBSyxLQUFJeFksQ0FBQUEsSUFBSzNCLEtBQUtxQixHQUFHLENBQUNNLEdBQUcsS0FBS3lZLEtBQUtwYSxLQUFLcUIsR0FBRyxDQUFDTSxHQUFHLEtBQUswWTtJQUMxSDtJQUVBQyxlQUFlQyxJQUFJLEVBQUVMLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRTtRQUNuQyxJQUFJeEgsSUFBSSxJQUFJcUgsS0FBSyxLQUFLQyxLQUFLLElBQUlDO1FBQy9CLElBQUl4SCxJQUFJLENBQUMsSUFBSXNILEtBQUssSUFBSUMsS0FBSyxJQUFJQyxLQUFLLElBQUlDO1FBQ3hDLElBQUl2SCxJQUFJLElBQUlxSCxLQUFLLElBQUlEO1FBRXJCLElBQUl0SCxNQUFNLEdBQUc7WUFDWCxJQUFJQyxNQUFNLEdBQUc7Z0JBQ1g7WUFDRjtZQUVBLElBQUlsUixJQUFJLENBQUNtUixJQUFJRDtZQUViLElBQUksSUFBSWxSLEtBQUtBLElBQUksR0FBRztnQkFDbEIsSUFBSTRZLE1BQU07b0JBQ1IsSUFBSSxDQUFDVCxJQUFJLENBQUMsSUFBSSxDQUFDRyxRQUFRLENBQUN0WSxHQUFHdVksSUFBSUMsSUFBSUMsSUFBSUM7Z0JBQ3pDLE9BQU87b0JBQ0wsSUFBSSxDQUFDTixJQUFJLENBQUMsSUFBSSxDQUFDRSxRQUFRLENBQUN0WSxHQUFHdVksSUFBSUMsSUFBSUMsSUFBSUM7Z0JBQ3pDO1lBQ0Y7WUFFQTtRQUNGO1FBRUEsSUFBSUcsT0FBT3hhLEtBQUtxQixHQUFHLENBQUN3UixHQUFHLEtBQUssSUFBSUMsSUFBSUY7UUFFcEMsSUFBSTRILE9BQU8sR0FBRztZQUNaO1FBQ0Y7UUFFQSxJQUFJQyxLQUFLLENBQUMsQ0FBQzVILElBQUk3UyxLQUFLb0IsSUFBSSxDQUFDb1osS0FBSSxJQUFNLEtBQUk1SCxDQUFBQTtRQUV2QyxJQUFJLElBQUk2SCxNQUFNQSxLQUFLLEdBQUc7WUFDcEIsSUFBSUYsTUFBTTtnQkFDUixJQUFJLENBQUNULElBQUksQ0FBQyxJQUFJLENBQUNHLFFBQVEsQ0FBQ1EsSUFBSVAsSUFBSUMsSUFBSUMsSUFBSUM7WUFDMUMsT0FBTztnQkFDTCxJQUFJLENBQUNOLElBQUksQ0FBQyxJQUFJLENBQUNFLFFBQVEsQ0FBQ1EsSUFBSVAsSUFBSUMsSUFBSUMsSUFBSUM7WUFDMUM7UUFDRjtRQUVBLElBQUlLLEtBQUssQ0FBQyxDQUFDN0gsSUFBSTdTLEtBQUtvQixJQUFJLENBQUNvWixLQUFJLElBQU0sS0FBSTVILENBQUFBO1FBRXZDLElBQUksSUFBSThILE1BQU1BLEtBQUssR0FBRztZQUNwQixJQUFJSCxNQUFNO2dCQUNSLElBQUksQ0FBQ1QsSUFBSSxDQUFDLElBQUksQ0FBQ0csUUFBUSxDQUFDUyxJQUFJUixJQUFJQyxJQUFJQyxJQUFJQztZQUMxQyxPQUFPO2dCQUNMLElBQUksQ0FBQ04sSUFBSSxDQUFDLElBQUksQ0FBQ0UsUUFBUSxDQUFDUyxJQUFJUixJQUFJQyxJQUFJQyxJQUFJQztZQUMxQztRQUNGO0lBQ0Y7SUFHQU0sZUFBZUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUU7UUFDckQsSUFBSSxDQUFDdEIsUUFBUSxDQUFDZSxLQUFLQztRQUNuQixJQUFJLENBQUNoQixRQUFRLENBQUNxQixLQUFLQztRQUNuQixJQUFJLENBQUNiLGNBQWMsQ0FBQyxNQUFNTSxLQUFLRSxLQUFLRSxLQUFLRTtRQUN6QyxJQUFJLENBQUNaLGNBQWMsQ0FBQyxPQUFPTyxLQUFLRSxLQUFLRSxLQUFLRTtJQUM1QztJQUVBQyxrQkFBa0JSLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUU7UUFDOUMsSUFBSUksT0FBT1QsTUFBTSxJQUFJLElBQUtFLENBQUFBLE1BQU1GLEdBQUUsR0FBSSw2QkFBNkI7UUFFbkUsSUFBSVUsT0FBT1QsTUFBTSxJQUFJLElBQUtFLENBQUFBLE1BQU1GLEdBQUUsR0FBSSw2QkFBNkI7UUFFbkUsSUFBSVUsT0FBT0YsT0FBTyxJQUFJLElBQUtMLENBQUFBLE1BQU1KLEdBQUUsR0FBSSw2QkFBNkI7UUFFcEUsSUFBSVksT0FBT0YsT0FBTyxJQUFJLElBQUtMLENBQUFBLE1BQU1KLEdBQUUsR0FBSSw2QkFBNkI7UUFFcEUsSUFBSSxDQUFDRixjQUFjLENBQUNDLEtBQUtDLEtBQUtRLE1BQU1FLE1BQU1ELE1BQU1FLE1BQU1SLEtBQUtDO0lBQzdEO0lBRUEzUixhQUFhMUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDakIsSUFBSSxFQUNGMFMsRUFBRSxFQUNGRyxFQUFFLEVBQ0ZDLEVBQUUsRUFDRkMsRUFBRSxFQUNILEdBQUcsSUFBSTtRQUNSLE9BQU9MLE1BQU0zUyxLQUFLQSxLQUFLK1MsTUFBTUQsTUFBTTdTLEtBQUtBLEtBQUsrUztJQUMvQztBQUVGO0FBRUEsTUFBTTZCLG1CQUFtQnBmLHNEQUFXQTtJQUNsQzhGLFlBQVlpRixJQUFJLENBQUU7UUFDaEIsS0FBSyxDQUFDQSxLQUFLLDBCQUEwQjtTQUNwQzVJLE9BQU8sQ0FBQyxpQkFBaUIsTUFBTSx1QkFBdUI7U0FDdERBLE9BQU8sQ0FBQyx1Q0FBdUM7UUFDaEQsSUFBSSxDQUFDa2QsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDclQsS0FBSyxHQUFHO1FBQ2IsSUFBSSxDQUFDc1QsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDQyxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNDLFFBQVEsR0FBRyxJQUFJLENBQUNBLFFBQVE7UUFDN0IsSUFBSSxDQUFDL1YsQ0FBQyxHQUFHLENBQUM7UUFDVixJQUFJLENBQUNnVyxlQUFlLEdBQUc7UUFDdkIsSUFBSSxDQUFDelUsTUFBTSxHQUFHLEVBQUU7UUFDaEIsSUFBSSxDQUFDMFUsTUFBTSxHQUFHLEVBQUU7SUFDbEI7SUFFQUMsUUFBUTtRQUNOLElBQUksQ0FBQ2xXLENBQUMsR0FBRyxDQUFDO1FBQ1YsSUFBSSxDQUFDOFYsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDRSxlQUFlLEdBQUc7UUFDdkIsSUFBSSxDQUFDelQsS0FBSyxHQUFHLElBQUkxQixNQUFNLEdBQUc7UUFDMUIsSUFBSSxDQUFDK1UsT0FBTyxHQUFHLElBQUkvVSxNQUFNLEdBQUc7UUFDNUIsSUFBSSxDQUFDZ1YsT0FBTyxHQUFHLElBQUloVixNQUFNLEdBQUc7UUFDNUIsSUFBSSxDQUFDVSxNQUFNLEdBQUcsRUFBRTtRQUNoQixJQUFJLENBQUMwVSxNQUFNLEdBQUcsRUFBRTtJQUNsQjtJQUVBRSxRQUFRO1FBQ04sSUFBSSxFQUNGblcsQ0FBQyxFQUNEK1YsUUFBUSxFQUNULEdBQUcsSUFBSTtRQUNSLE9BQU8vVixLQUFLK1YsU0FBU2xmLE1BQU0sR0FBRztJQUNoQztJQUVBdWYsT0FBTztRQUNMLElBQUlOLFVBQVUsSUFBSSxDQUFDQyxRQUFRLENBQUMsRUFBRSxJQUFJLENBQUMvVixDQUFDLENBQUM7UUFDckMsSUFBSSxDQUFDZ1csZUFBZSxHQUFHLElBQUksQ0FBQ0YsT0FBTztRQUNuQyxJQUFJLENBQUNBLE9BQU8sR0FBR0E7UUFDZixPQUFPQTtJQUNUO0lBRUFPLFdBQVc7UUFDVCxJQUFJQyxRQUFRMWYsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUtFLFlBQVlGLFNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDaEYsSUFBSTJmLFFBQVEzZixVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRztRQUNoRixJQUFJcUssUUFBUSxJQUFJSixNQUFNLElBQUksQ0FBQ2lWLE9BQU8sQ0FBQ1EsTUFBTSxFQUFFLElBQUksQ0FBQ1IsT0FBTyxDQUFDUyxNQUFNO1FBQzlELE9BQU8sSUFBSSxDQUFDQyxZQUFZLENBQUN2VjtJQUMzQjtJQUVBd1Ysa0JBQWtCSCxLQUFLLEVBQUVDLEtBQUssRUFBRTtRQUM5QixJQUFJdFYsUUFBUSxJQUFJLENBQUNvVixRQUFRLENBQUNDLE9BQU9DO1FBQ2pDLElBQUksQ0FBQ1gsT0FBTyxHQUFHM1U7UUFDZixPQUFPQTtJQUNUO0lBRUF5VixrQkFBa0JKLEtBQUssRUFBRUMsS0FBSyxFQUFFO1FBQzlCLElBQUl0VixRQUFRLElBQUksQ0FBQ29WLFFBQVEsQ0FBQ0MsT0FBT0M7UUFDakMsSUFBSSxDQUFDVixPQUFPLEdBQUc1VTtRQUNmLE9BQU9BO0lBQ1Q7SUFFQTBWLDJCQUEyQjtRQUN6QixJQUFJWCxrQkFBa0IsSUFBSSxDQUFDQSxlQUFlLENBQUM5UixJQUFJO1FBRS9DLElBQUk4UixvQkFBb0J6ZixzREFBV0EsQ0FBQ3FnQixRQUFRLElBQUlaLG9CQUFvQnpmLHNEQUFXQSxDQUFDc2dCLGVBQWUsSUFBSWIsb0JBQW9CemYsc0RBQVdBLENBQUN1Z0IsT0FBTyxJQUFJZCxvQkFBb0J6ZixzREFBV0EsQ0FBQ3dnQixjQUFjLEVBQUU7WUFDNUwsT0FBTyxJQUFJLENBQUNsQixPQUFPO1FBQ3JCLEVBQUUsZ0JBQWdCO1FBR2xCLElBQUksRUFDRkEsU0FBUyxFQUNQL1UsR0FBR29MLEVBQUUsRUFDTG5MLEdBQUdvTCxFQUFFLEVBQ04sRUFDRHlKLFNBQVMsRUFDUDlVLEdBQUdrVyxFQUFFLEVBQ0xqVyxHQUFHa1csRUFBRSxFQUNOLEVBQ0YsR0FBRyxJQUFJO1FBQ1IsSUFBSWhXLFFBQVEsSUFBSUosTUFBTSxJQUFJcUwsS0FBSzhLLElBQUksSUFBSTdLLEtBQUs4SztRQUM1QyxPQUFPaFc7SUFDVDtJQUVBdVYsYUFBYXZWLEtBQUssRUFBRTtRQUNsQixJQUFJLElBQUksQ0FBQzZVLE9BQU8sQ0FBQ29CLFFBQVEsRUFBRTtZQUN6QixJQUFJLEVBQ0ZwVyxDQUFDLEVBQ0RDLENBQUMsRUFDRixHQUFHLElBQUksQ0FBQzhVLE9BQU87WUFDaEI1VSxNQUFNSCxDQUFDLElBQUlBO1lBQ1hHLE1BQU1GLENBQUMsSUFBSUE7UUFDYjtRQUVBLE9BQU9FO0lBQ1Q7SUFFQWtXLFVBQVVsVyxLQUFLLEVBQUVpTyxJQUFJLEVBQUVrSSxPQUFPLEVBQUU7UUFDOUIsSUFBSSxFQUNGN1YsTUFBTSxFQUNOMFUsTUFBTSxFQUNQLEdBQUcsSUFBSSxFQUFFLDhFQUE4RTtRQUV4RixJQUFJbUIsV0FBV25CLE9BQU9wZixNQUFNLEdBQUcsS0FBSyxDQUFDb2YsTUFBTSxDQUFDQSxPQUFPcGYsTUFBTSxHQUFHLEVBQUUsRUFBRTtZQUM5RG9mLE1BQU0sQ0FBQ0EsT0FBT3BmLE1BQU0sR0FBRyxFQUFFLEdBQUcwSyxNQUFNLENBQUNBLE9BQU8xSyxNQUFNLEdBQUcsRUFBRSxDQUFDNEssT0FBTyxDQUFDMlY7UUFDaEU7UUFFQSxJQUFJLENBQUNDLGNBQWMsQ0FBQ3BXLE9BQU9pTyxPQUFPQSxLQUFLek4sT0FBTyxDQUFDUixTQUFTO0lBQzFEO0lBRUFvVyxlQUFlcFcsS0FBSyxFQUFFOEssS0FBSyxFQUFFO1FBQzNCLElBQUksQ0FBQ3hLLE1BQU0sQ0FBQ2YsSUFBSSxDQUFDUztRQUNqQixJQUFJLENBQUNnVixNQUFNLENBQUN6VixJQUFJLENBQUN1TDtJQUNuQjtJQUVBdUwsa0JBQWtCO1FBQ2hCLE9BQU8sSUFBSSxDQUFDL1YsTUFBTTtJQUNwQjtJQUVBZ1csa0JBQWtCO1FBQ2hCLElBQUksRUFDRnRCLE1BQU0sRUFDUCxHQUFHLElBQUk7UUFDUixJQUFJblcsTUFBTW1XLE9BQU9wZixNQUFNO1FBRXZCLElBQUssSUFBSW1KLElBQUksR0FBR0EsSUFBSUYsS0FBS0UsSUFBSztZQUM1QixJQUFJLENBQUNpVyxNQUFNLENBQUNqVyxFQUFFLEVBQUU7Z0JBQ2QsSUFBSyxJQUFJd1gsSUFBSXhYLElBQUksR0FBR3dYLElBQUkxWCxLQUFLMFgsSUFBSztvQkFDaEMsSUFBSXZCLE1BQU0sQ0FBQ3VCLEVBQUUsRUFBRTt3QkFDYnZCLE1BQU0sQ0FBQ2pXLEVBQUUsR0FBR2lXLE1BQU0sQ0FBQ3VCLEVBQUU7d0JBQ3JCO29CQUNGO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBLE9BQU92QjtJQUNUO0FBRUY7QUFFQSxNQUFNd0Isd0JBQXdCbEo7SUFDNUJsUyxhQUFjO1FBQ1osS0FBSyxJQUFJekY7UUFDVCxJQUFJLENBQUM4Z0IsbUJBQW1CLEdBQUc7SUFDN0I7SUFFQUMsbUJBQW1CO1FBQ2pCLElBQUl2WSxVQUFVLEtBQUssNkVBQTZFO1FBRWhHLElBQUlELFVBQVUsSUFBSTtRQUVsQixNQUFPQSxRQUFTO1lBQ2QsSUFBSXlZLGVBQWV6WSxRQUFRcUssUUFBUSxDQUFDLFdBQVcsT0FBTyxPQUFPLDZCQUE2QjtZQUUxRixJQUFJb08sYUFBYTlhLFFBQVEsQ0FBQyxPQUFPO2dCQUMvQnNDLFdBQVd3WSxhQUFhbGEsU0FBUztZQUNuQztZQUVBeUIsVUFBVUEsUUFBUThELE1BQU07UUFDMUI7UUFFQSxPQUFPN0Q7SUFDVDtJQUVBb1IsV0FBV2xSLEdBQUcsRUFBRTtRQUNkLElBQUl1WSxjQUFjamhCLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHO1FBRXRGLElBQUksQ0FBQ2loQixhQUFhO1lBQ2hCLDJEQUEyRDtZQUMzRCxPQUFPO1lBQ1AsSUFBSUMsZ0JBQWdCLElBQUksQ0FBQ3RPLFFBQVEsQ0FBQztZQUNsQyxJQUFJdU8sdUJBQXVCLElBQUksQ0FBQ3ZPLFFBQVEsQ0FBQztZQUN6QyxJQUFJd08sa0JBQWtCLElBQUksQ0FBQ3hPLFFBQVEsQ0FBQztZQUNwQyxJQUFJeU8sb0JBQW9CLElBQUksQ0FBQ3pPLFFBQVEsQ0FBQztZQUV0QyxJQUFJc08sY0FBYzNhLGVBQWUsSUFBSTtnQkFDbkMsSUFBSSthLFlBQVlKLGNBQWM1WSxzQkFBc0IsQ0FBQyxJQUFJLEVBQUU2WTtnQkFFM0QsSUFBSUcsV0FBVztvQkFDYjVZLElBQUk0WSxTQUFTLEdBQUdBO2dCQUNsQjtZQUNGLE9BQU8sSUFBSUosY0FBY2hiLFFBQVEsSUFBSTtnQkFDbkMsSUFBSWdiLGNBQWNsYixTQUFTLE9BQU8sZ0JBQWdCO29CQUNoRGtiLGNBQWN2YSxRQUFRLENBQUMsSUFBSSxDQUFDaU0sUUFBUSxDQUFDLFNBQVM1TCxRQUFRO2dCQUN4RDtnQkFFQSxJQUFJdWEsYUFBYUwsY0FBY2xhLFFBQVE7Z0JBRXZDLElBQUl1YSxlQUFlLFdBQVc7b0JBQzVCN1ksSUFBSTRZLFNBQVMsR0FBR0MsZUFBZSxTQUFTLGtCQUFrQkE7Z0JBQzVEO1lBQ0Y7WUFFQSxJQUFJSixxQkFBcUJqYixRQUFRLElBQUk7Z0JBQ25DLElBQUlzYixjQUFjLElBQUloYyxTQUFTLElBQUksQ0FBQ0UsUUFBUSxFQUFFLFFBQVFnRCxJQUFJNFksU0FBUyxFQUFFclksVUFBVSxDQUFDa1ksc0JBQXNCbmEsUUFBUTtnQkFFOUcwQixJQUFJNFksU0FBUyxHQUFHRTtZQUNsQixFQUFFLFNBQVM7WUFHWCxJQUFJSixnQkFBZ0I3YSxlQUFlLElBQUk7Z0JBQ3JDLElBQUkwSSxjQUFjbVMsZ0JBQWdCOVksc0JBQXNCLENBQUMsSUFBSSxFQUFFK1k7Z0JBRS9ELElBQUlwUyxhQUFhO29CQUNmdkcsSUFBSXVHLFdBQVcsR0FBR0E7Z0JBQ3BCO1lBQ0YsT0FBTyxJQUFJbVMsZ0JBQWdCbGIsUUFBUSxJQUFJO2dCQUNyQyxJQUFJa2IsZ0JBQWdCcGIsU0FBUyxPQUFPLGdCQUFnQjtvQkFDbERvYixnQkFBZ0J6YSxRQUFRLENBQUMsSUFBSSxDQUFDaU0sUUFBUSxDQUFDLFNBQVM1TCxRQUFRO2dCQUMxRDtnQkFFQSxJQUFJeWEsZUFBZUwsZ0JBQWdCcGIsU0FBUztnQkFFNUMsSUFBSXliLGlCQUFpQixXQUFXO29CQUM5Qi9ZLElBQUl1RyxXQUFXLEdBQUd3UyxpQkFBaUIsU0FBUyxrQkFBa0JBO2dCQUNoRTtZQUNGO1lBRUEsSUFBSUosa0JBQWtCbmIsUUFBUSxJQUFJO2dCQUNoQyxJQUFJd2IsZ0JBQWdCLElBQUlsYyxTQUFTLElBQUksQ0FBQ0UsUUFBUSxFQUFFLFVBQVVnRCxJQUFJdUcsV0FBVyxFQUFFaEcsVUFBVSxDQUFDb1ksbUJBQW1CcmIsU0FBUztnQkFFbEgwQyxJQUFJdUcsV0FBVyxHQUFHeVM7WUFDcEI7WUFFQSxJQUFJQyx1QkFBdUIsSUFBSSxDQUFDL08sUUFBUSxDQUFDO1lBRXpDLElBQUkrTyxxQkFBcUJ6YixRQUFRLElBQUk7Z0JBQ25DLElBQUkwYixlQUFlRCxxQkFBcUJwYSxTQUFTO2dCQUNqRG1CLElBQUltWixTQUFTLEdBQUcsQ0FBQ0QsZUFBZXJkLFlBQVksZ0RBQWdEO21CQUMxRnFkO1lBQ0o7WUFFQSxJQUFJRSx5QkFBeUIsSUFBSSxDQUFDbFAsUUFBUSxDQUFDO1lBQzNDLElBQUltUCwwQkFBMEIsSUFBSSxDQUFDblAsUUFBUSxDQUFDO1lBQzVDLElBQUlvUCx1QkFBdUIsSUFBSSxDQUFDcFAsUUFBUSxDQUFDLHNCQUFzQixZQUFZO1lBQzNFLDREQUE0RDtZQUU1RCxJQUFJcVAsMkJBQTJCLElBQUksQ0FBQ3JQLFFBQVEsQ0FBQztZQUM3QyxJQUFJc1AsdUJBQXVCLElBQUksQ0FBQ3RQLFFBQVEsQ0FBQztZQUV6QyxJQUFJa1AsdUJBQXVCNWIsUUFBUSxJQUFJO2dCQUNyQ3dDLElBQUl3RyxPQUFPLEdBQUc0Uyx1QkFBdUI5YixTQUFTO1lBQ2hEO1lBRUEsSUFBSStiLHdCQUF3QjdiLFFBQVEsSUFBSTtnQkFDdEN3QyxJQUFJeUcsUUFBUSxHQUFHNFMsd0JBQXdCL2IsU0FBUztZQUNsRDtZQUVBLElBQUlnYyxxQkFBcUI5YixRQUFRLElBQUk7Z0JBQ25Dd0MsSUFBSTBHLFVBQVUsR0FBRzRTLHFCQUFxQmxiLFNBQVM7WUFDakQsRUFBRSxZQUFZO1lBQ2Qsd0NBQXdDO1lBQ3hDLFFBQVE7WUFDUixvREFBb0Q7WUFDcEQsSUFBSTtZQUdKLElBQUltYix5QkFBeUIvYixRQUFRLE1BQU0rYix5QkFBeUJqYyxTQUFTLE9BQU8sUUFBUTtnQkFDMUYsSUFBSW1jLE9BQU9sZ0IsVUFBVWdnQix5QkFBeUJqYyxTQUFTO2dCQUV2RCxJQUFJLE9BQU8wQyxJQUFJMFosV0FBVyxLQUFLLGFBQWE7b0JBQzFDMVosSUFBSTBaLFdBQVcsQ0FBQ0Q7Z0JBQ2xCLE9BQ0UsSUFBSSxPQUFPelosSUFBSTJaLGNBQWMsS0FBSyxhQUFhO29CQUM3QywwQ0FBMEM7b0JBQzFDM1osSUFBSTJaLGNBQWMsR0FBR0Y7Z0JBQ3ZCLE9BQ0UsSUFBSSxPQUFPelosSUFBSTRaLE9BQU8sS0FBSyxlQUFlLENBQUVILENBQUFBLEtBQUtsaUIsTUFBTSxLQUFLLEtBQUtraUIsSUFBSSxDQUFDLEVBQUUsS0FBSyxJQUFJO29CQUMvRSwwQ0FBMEM7b0JBQzFDelosSUFBSTRaLE9BQU8sR0FBR0g7Z0JBQ2hCO2dCQUVKLElBQUlJLFNBQVNMLHFCQUFxQjNhLFNBQVM7Z0JBRTNDLElBQUksT0FBT21CLElBQUk4WixjQUFjLEtBQUssYUFBYTtvQkFDN0M5WixJQUFJOFosY0FBYyxHQUFHRDtnQkFDdkIsT0FDRSxJQUFJLE9BQU83WixJQUFJK1osb0JBQW9CLEtBQUssYUFBYTtvQkFDbkQsMENBQTBDO29CQUMxQy9aLElBQUkrWixvQkFBb0IsR0FBR0Y7Z0JBQzdCLE9BQ0UsSUFBSSxPQUFPN1osSUFBSWdhLGFBQWEsS0FBSyxhQUFhO29CQUM1QywwQ0FBMEM7b0JBQzFDaGEsSUFBSWdhLGFBQWEsR0FBR0g7Z0JBQ3RCO1lBQ047UUFDRixFQUFFLE9BQU87UUFHVCxJQUFJLENBQUN6QixtQkFBbUIsR0FBRztRQUUzQixJQUFJLE9BQU9wWSxJQUFJMlQsSUFBSSxLQUFLLGFBQWE7WUFDbkMsSUFBSXNHLGdCQUFnQixJQUFJLENBQUMvUCxRQUFRLENBQUM7WUFDbEMsSUFBSWdRLHFCQUFxQixJQUFJLENBQUNoUSxRQUFRLENBQUM7WUFDdkMsSUFBSWlRLHVCQUF1QixJQUFJLENBQUNqUSxRQUFRLENBQUM7WUFDekMsSUFBSWtRLHNCQUFzQixJQUFJLENBQUNsUSxRQUFRLENBQUM7WUFDeEMsSUFBSW1RLG9CQUFvQixJQUFJLENBQUNuUSxRQUFRLENBQUM7WUFDdEMsSUFBSW9RLHNCQUFzQixJQUFJLENBQUNwUSxRQUFRLENBQUM7WUFDeEMsSUFBSXlKLE9BQU8sSUFBSUwsS0FBSzRHLG1CQUFtQjVjLFNBQVMsSUFBSTZjLHFCQUFxQjdjLFNBQVMsSUFBSThjLG9CQUFvQjljLFNBQVMsSUFBSStjLGtCQUFrQjdjLFFBQVEsS0FBSyxHQUFHNE0sTUFBTSxDQUFDaVEsa0JBQWtCeGIsU0FBUyxDQUFDLE9BQU8sUUFBUSxJQUFJeWIsb0JBQW9CaGQsU0FBUyxJQUFJZ1csS0FBSzVSLEtBQUssQ0FBQ3VZLGNBQWMzYyxTQUFTLElBQUkwQyxJQUFJMlQsSUFBSTtZQUM5UnVHLG1CQUFtQmpjLFFBQVEsQ0FBQzBWLEtBQUtWLFNBQVM7WUFDMUNrSCxxQkFBcUJsYyxRQUFRLENBQUMwVixLQUFLSixXQUFXO1lBQzlDNkcsb0JBQW9CbmMsUUFBUSxDQUFDMFYsS0FBS1AsVUFBVTtZQUM1Q2lILGtCQUFrQnBjLFFBQVEsQ0FBQzBWLEtBQUtILFFBQVE7WUFDeEM4RyxvQkFBb0JyYyxRQUFRLENBQUMwVixLQUFLZixVQUFVO1lBQzVDNVMsSUFBSTJULElBQUksR0FBR0EsS0FBS00sUUFBUTtZQUV4QixJQUFJb0csa0JBQWtCdmMsUUFBUSxJQUFJO2dCQUNoQyxJQUFJLENBQUNkLFFBQVEsQ0FBQzJCLE1BQU0sR0FBRzBiLGtCQUFrQnhiLFNBQVM7Z0JBQ2xELElBQUksQ0FBQ3VaLG1CQUFtQixHQUFHO1lBQzdCO1FBQ0Y7UUFFQSxJQUFJLENBQUNHLGFBQWE7WUFDaEIsVUFBVTtZQUNWLElBQUksQ0FBQ3ZILFlBQVksQ0FBQ2hSLE1BQU0sVUFBVTtZQUVsQ0EsSUFBSXVhLFdBQVcsR0FBRyxJQUFJLENBQUNsQyxnQkFBZ0I7UUFDekM7SUFDRjtJQUVBakgsYUFBYXBSLEdBQUcsRUFBRTtRQUNoQixLQUFLLENBQUNvUixhQUFhcFI7UUFFbkIsSUFBSSxJQUFJLENBQUNvWSxtQkFBbUIsRUFBRTtZQUM1QixJQUFJLENBQUNwYixRQUFRLENBQUN3ZCxTQUFTO1FBQ3pCO0lBQ0Y7QUFFRjtBQUVBLE1BQU1DLG9CQUFvQnRDO0lBQ3hCcGIsWUFBWUMsU0FBUSxFQUFFdEUsSUFBSSxFQUFFd1csZ0JBQWdCLENBQUU7UUFDNUMsS0FBSyxDQUFDbFMsV0FBVXRFLE1BQU13VztRQUN0QixJQUFJLENBQUN0SyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUM4VixVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDQSxVQUFVLEdBQUcsSUFBSXJFLFdBQVcsSUFBSSxDQUFDalcsWUFBWSxDQUFDLEtBQUs5QyxTQUFTO0lBQ25FO0lBRUEwRSxLQUFLaEMsR0FBRyxFQUFFO1FBQ1IsSUFBSSxFQUNGMGEsVUFBVSxFQUNYLEdBQUcsSUFBSTtRQUNSLElBQUkxVyxjQUFjLElBQUlrUTtRQUN0QndHLFdBQVc5RCxLQUFLO1FBRWhCLElBQUk1VyxLQUFLO1lBQ1BBLElBQUl1SSxTQUFTO1FBQ2Y7UUFFQSxNQUFPLENBQUNtUyxXQUFXN0QsS0FBSyxHQUFJO1lBQzFCLE9BQVE2RCxXQUFXNUQsSUFBSSxHQUFHbFMsSUFBSTtnQkFDNUIsS0FBS3lSLFdBQVdzRSxPQUFPO29CQUNyQixJQUFJLENBQUNDLEtBQUssQ0FBQzVhLEtBQUtnRTtvQkFDaEI7Z0JBRUYsS0FBS3FTLFdBQVd3RSxPQUFPO29CQUNyQixJQUFJLENBQUNDLEtBQUssQ0FBQzlhLEtBQUtnRTtvQkFDaEI7Z0JBRUYsS0FBS3FTLFdBQVcwRSxhQUFhO29CQUMzQixJQUFJLENBQUNDLEtBQUssQ0FBQ2hiLEtBQUtnRTtvQkFDaEI7Z0JBRUYsS0FBS3FTLFdBQVc0RSxZQUFZO29CQUMxQixJQUFJLENBQUNDLEtBQUssQ0FBQ2xiLEtBQUtnRTtvQkFDaEI7Z0JBRUYsS0FBS3FTLFdBQVdpQixRQUFRO29CQUN0QixJQUFJLENBQUM2RCxLQUFLLENBQUNuYixLQUFLZ0U7b0JBQ2hCO2dCQUVGLEtBQUtxUyxXQUFXa0IsZUFBZTtvQkFDN0IsSUFBSSxDQUFDNkQsS0FBSyxDQUFDcGIsS0FBS2dFO29CQUNoQjtnQkFFRixLQUFLcVMsV0FBV21CLE9BQU87b0JBQ3JCLElBQUksQ0FBQzZELEtBQUssQ0FBQ3JiLEtBQUtnRTtvQkFDaEI7Z0JBRUYsS0FBS3FTLFdBQVdvQixjQUFjO29CQUM1QixJQUFJLENBQUM2RCxLQUFLLENBQUN0YixLQUFLZ0U7b0JBQ2hCO2dCQUVGLEtBQUtxUyxXQUFXa0YsR0FBRztvQkFDakIsSUFBSSxDQUFDQyxLQUFLLENBQUN4YixLQUFLZ0U7b0JBQ2hCO2dCQUVGLEtBQUtxUyxXQUFXb0YsVUFBVTtvQkFDeEIsSUFBSSxDQUFDQyxLQUFLLENBQUMxYixLQUFLZ0U7b0JBQ2hCO1lBQ0o7UUFDRjtRQUVBLE9BQU9BO0lBQ1Q7SUFFQTJYLGVBQWV2VixDQUFDLEVBQUU7UUFDaEIsT0FBTyxJQUFJLENBQUNwRSxJQUFJO0lBQ2xCO0lBRUE0WixhQUFhO1FBQ1gsSUFBSSxFQUNGbEIsVUFBVSxFQUNYLEdBQUcsSUFBSTtRQUNSLElBQUl6WSxTQUFTeVksV0FBVzFDLGVBQWU7UUFDdkMsSUFBSXJCLFNBQVMrRCxXQUFXekMsZUFBZTtRQUN2QyxJQUFJNEQsVUFBVTVaLE9BQU92SSxHQUFHLENBQUMsQ0FBQ2lJLE9BQU9qQixJQUFNO2dCQUFDaUI7Z0JBQU9nVixNQUFNLENBQUNqVyxFQUFFO2FBQUM7UUFDekQsT0FBT21iO0lBQ1Q7SUFFQTFLLGVBQWVuUixHQUFHLEVBQUU7UUFDbEIsSUFBSSxDQUFDZ0MsSUFBSSxDQUFDaEM7UUFDVixJQUFJLENBQUNoRCxRQUFRLENBQUNtQyxNQUFNLENBQUNrRyxLQUFLLENBQUN6QixTQUFTLENBQUMsSUFBSSxFQUFFNUQ7UUFDM0MsSUFBSThiLG9CQUFvQixJQUFJLENBQUM1UixRQUFRLENBQUM7UUFFdEMsSUFBSWxLLElBQUk0WSxTQUFTLEtBQUssSUFBSTtZQUN4QixJQUFJa0Qsa0JBQWtCeGUsU0FBUyxDQUFDLGVBQWUsV0FBVztnQkFDeEQwQyxJQUFJK2IsSUFBSSxDQUFDRCxrQkFBa0J4ZSxTQUFTO1lBQ3RDLE9BQU87Z0JBQ0wwQyxJQUFJK2IsSUFBSTtZQUNWO1FBQ0Y7UUFFQSxJQUFJL2IsSUFBSXVHLFdBQVcsS0FBSyxJQUFJO1lBQzFCLElBQUksSUFBSSxDQUFDbkcsWUFBWSxDQUFDLGlCQUFpQjlDLFNBQVMsT0FBTyxzQkFBc0I7Z0JBQzNFMEMsSUFBSThRLElBQUk7Z0JBQ1I5USxJQUFJZ2MsWUFBWSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDaENoYyxJQUFJaWMsTUFBTTtnQkFDVmpjLElBQUlxUixPQUFPO1lBQ2IsT0FBTztnQkFDTHJSLElBQUlpYyxNQUFNO1lBQ1o7UUFDRjtRQUVBLElBQUlKLFVBQVUsSUFBSSxDQUFDRCxVQUFVO1FBRTdCLElBQUlDLFNBQVM7WUFDWCxJQUFJSyxtQkFBbUJMLFFBQVF0a0IsTUFBTSxHQUFHO1lBQ3hDLElBQUk0a0IsdUJBQXVCLElBQUksQ0FBQ2pTLFFBQVEsQ0FBQztZQUN6QyxJQUFJa1MscUJBQXFCLElBQUksQ0FBQ2xTLFFBQVEsQ0FBQztZQUN2QyxJQUFJbVMscUJBQXFCLElBQUksQ0FBQ25TLFFBQVEsQ0FBQztZQUV2QyxJQUFJaVMscUJBQXFCdGUsZUFBZSxJQUFJO2dCQUMxQyxJQUFJeWUsU0FBU0gscUJBQXFCemMsYUFBYTtnQkFDL0MsSUFBSSxDQUFDaUMsT0FBTzhLLE1BQU0sR0FBR29QLE9BQU8sQ0FBQyxFQUFFO2dCQUMvQlMsT0FBTy9TLE1BQU0sQ0FBQ3ZKLEtBQUsyQixPQUFPOEs7WUFDNUI7WUFFQSxJQUFJMlAsbUJBQW1CdmUsZUFBZSxJQUFJO2dCQUN4QyxJQUFJMGUsVUFBVUgsbUJBQW1CMWMsYUFBYTtnQkFFOUMsSUFBSyxJQUFJZ0IsSUFBSSxHQUFHQSxJQUFJd2Isa0JBQWtCeGIsSUFBSztvQkFDekMsSUFBSSxDQUFDOGIsUUFBUUMsT0FBTyxHQUFHWixPQUFPLENBQUNuYixFQUFFO29CQUVqQzZiLFFBQVFoVCxNQUFNLENBQUN2SixLQUFLd2MsUUFBUUM7Z0JBQzlCO1lBQ0Y7WUFFQSxJQUFJSixtQkFBbUJ4ZSxlQUFlLElBQUk7Z0JBQ3hDLElBQUk2ZSxXQUFXTCxtQkFBbUIzYyxhQUFhO2dCQUUvQyxJQUFJLENBQUNpZCxTQUFTQyxRQUFRLEdBQUdmLE9BQU8sQ0FBQ0ssaUJBQWlCO2dCQUVsRFEsU0FBU25ULE1BQU0sQ0FBQ3ZKLEtBQUsyYyxTQUFTQztZQUNoQztRQUNGO0lBQ0Y7SUFFQSxPQUFPaEMsTUFBTUYsVUFBVSxFQUFFO1FBQ3ZCLElBQUkvWSxRQUFRK1ksV0FBV3RELGlCQUFpQjtRQUN4Q3NELFdBQVd6WCxLQUFLLEdBQUd5WCxXQUFXbkUsT0FBTztRQUNyQyxPQUFPO1lBQ0w1VTtRQUNGO0lBQ0Y7SUFFQWlaLE1BQU01YSxHQUFHLEVBQUVnRSxXQUFXLEVBQUU7UUFDdEIsSUFBSSxFQUNGMFcsVUFBVSxFQUNYLEdBQUcsSUFBSTtRQUNSLElBQUksRUFDRi9ZLEtBQUssRUFDTixHQUFHOFksWUFBWUcsS0FBSyxDQUFDRjtRQUN0QixJQUFJLEVBQ0ZsWixDQUFDLEVBQ0RDLENBQUMsRUFDRixHQUFHRTtRQUNKK1ksV0FBVzdDLFNBQVMsQ0FBQ2xXO1FBQ3JCcUMsWUFBWXlRLFFBQVEsQ0FBQ2pULEdBQUdDO1FBRXhCLElBQUl6QixLQUFLO1lBQ1BBLElBQUl3SSxNQUFNLENBQUNoSCxHQUFHQztRQUNoQjtJQUNGO0lBRUEsT0FBT3FaLE1BQU1KLFVBQVUsRUFBRTtRQUN2QixJQUFJLEVBQ0ZuRSxPQUFPLEVBQ1IsR0FBR21FO1FBQ0osSUFBSS9ZLFFBQVErWSxXQUFXdEQsaUJBQWlCO1FBQ3hDLE9BQU87WUFDTGI7WUFDQTVVO1FBQ0Y7SUFDRjtJQUVBbVosTUFBTTlhLEdBQUcsRUFBRWdFLFdBQVcsRUFBRTtRQUN0QixJQUFJLEVBQ0YwVyxVQUFVLEVBQ1gsR0FBRyxJQUFJO1FBQ1IsSUFBSSxFQUNGbkUsT0FBTyxFQUNQNVUsS0FBSyxFQUNOLEdBQUc4WSxZQUFZSyxLQUFLLENBQUNKO1FBQ3RCLElBQUksRUFDRmxaLENBQUMsRUFDREMsQ0FBQyxFQUNGLEdBQUdFO1FBQ0orWSxXQUFXN0MsU0FBUyxDQUFDbFcsT0FBTzRVO1FBQzVCdlMsWUFBWXlRLFFBQVEsQ0FBQ2pULEdBQUdDO1FBRXhCLElBQUl6QixLQUFLO1lBQ1BBLElBQUl5SSxNQUFNLENBQUNqSCxHQUFHQztRQUNoQjtJQUNGO0lBRUEsT0FBT3VaLE1BQU1OLFVBQVUsRUFBRTtRQUN2QixJQUFJLEVBQ0ZuRSxPQUFPLEVBQ1BDLE9BQU8sRUFDUixHQUFHa0U7UUFDSixJQUFJL1ksUUFBUSxJQUFJSixNQUFNLENBQUNpVixRQUFRb0IsUUFBUSxHQUFHckIsUUFBUS9VLENBQUMsR0FBRyxLQUFLZ1YsUUFBUWhWLENBQUMsRUFBRStVLFFBQVE5VSxDQUFDO1FBQy9FaVosV0FBV25FLE9BQU8sR0FBRzVVO1FBQ3JCLE9BQU87WUFDTDRVO1lBQ0E1VTtRQUNGO0lBQ0Y7SUFFQXFaLE1BQU1oYixHQUFHLEVBQUVnRSxXQUFXLEVBQUU7UUFDdEIsSUFBSSxFQUNGMFcsVUFBVSxFQUNYLEdBQUcsSUFBSTtRQUNSLElBQUksRUFDRm5FLE9BQU8sRUFDUDVVLEtBQUssRUFDTixHQUFHOFksWUFBWU8sS0FBSyxDQUFDTjtRQUN0QixJQUFJLEVBQ0ZsWixDQUFDLEVBQ0RDLENBQUMsRUFDRixHQUFHRTtRQUNKK1ksV0FBVzdDLFNBQVMsQ0FBQ2xXLE9BQU80VTtRQUM1QnZTLFlBQVl5USxRQUFRLENBQUNqVCxHQUFHQztRQUV4QixJQUFJekIsS0FBSztZQUNQQSxJQUFJeUksTUFBTSxDQUFDakgsR0FBR0M7UUFDaEI7SUFDRjtJQUVBLE9BQU95WixNQUFNUixVQUFVLEVBQUU7UUFDdkIsSUFBSSxFQUNGbkUsT0FBTyxFQUNQQyxPQUFPLEVBQ1IsR0FBR2tFO1FBQ0osSUFBSS9ZLFFBQVEsSUFBSUosTUFBTWdWLFFBQVEvVSxDQUFDLEVBQUUsQ0FBQ2dWLFFBQVFvQixRQUFRLEdBQUdyQixRQUFROVUsQ0FBQyxHQUFHLEtBQUsrVSxRQUFRL1UsQ0FBQztRQUMvRWlaLFdBQVduRSxPQUFPLEdBQUc1VTtRQUNyQixPQUFPO1lBQ0w0VTtZQUNBNVU7UUFDRjtJQUNGO0lBRUF1WixNQUFNbGIsR0FBRyxFQUFFZ0UsV0FBVyxFQUFFO1FBQ3RCLElBQUksRUFDRjBXLFVBQVUsRUFDWCxHQUFHLElBQUk7UUFDUixJQUFJLEVBQ0ZuRSxPQUFPLEVBQ1A1VSxLQUFLLEVBQ04sR0FBRzhZLFlBQVlTLEtBQUssQ0FBQ1I7UUFDdEIsSUFBSSxFQUNGbFosQ0FBQyxFQUNEQyxDQUFDLEVBQ0YsR0FBR0U7UUFDSitZLFdBQVc3QyxTQUFTLENBQUNsVyxPQUFPNFU7UUFDNUJ2UyxZQUFZeVEsUUFBUSxDQUFDalQsR0FBR0M7UUFFeEIsSUFBSXpCLEtBQUs7WUFDUEEsSUFBSXlJLE1BQU0sQ0FBQ2pILEdBQUdDO1FBQ2hCO0lBQ0Y7SUFFQSxPQUFPMFosTUFBTVQsVUFBVSxFQUFFO1FBQ3ZCLElBQUksRUFDRm5FLE9BQU8sRUFDUixHQUFHbUU7UUFDSixJQUFJL1ksUUFBUStZLFdBQVczRCxRQUFRLENBQUMsTUFBTTtRQUN0QyxJQUFJOEYsZUFBZW5DLFdBQVd2RCxpQkFBaUIsQ0FBQyxNQUFNO1FBQ3RELElBQUkyRixlQUFlcEMsV0FBV3RELGlCQUFpQjtRQUMvQyxPQUFPO1lBQ0xiO1lBQ0E1VTtZQUNBa2I7WUFDQUM7UUFDRjtJQUNGO0lBRUEzQixNQUFNbmIsR0FBRyxFQUFFZ0UsV0FBVyxFQUFFO1FBQ3RCLElBQUksRUFDRjBXLFVBQVUsRUFDWCxHQUFHLElBQUk7UUFDUixJQUFJLEVBQ0ZuRSxPQUFPLEVBQ1A1VSxLQUFLLEVBQ0xrYixZQUFZLEVBQ1pDLFlBQVksRUFDYixHQUFHckMsWUFBWVUsS0FBSyxDQUFDVDtRQUN0QkEsV0FBVzdDLFNBQVMsQ0FBQ2lGLGNBQWNELGNBQWNsYjtRQUNqRHFDLFlBQVl1UixjQUFjLENBQUNnQixRQUFRL1UsQ0FBQyxFQUFFK1UsUUFBUTlVLENBQUMsRUFBRUUsTUFBTUgsQ0FBQyxFQUFFRyxNQUFNRixDQUFDLEVBQUVvYixhQUFhcmIsQ0FBQyxFQUFFcWIsYUFBYXBiLENBQUMsRUFBRXFiLGFBQWF0YixDQUFDLEVBQUVzYixhQUFhcmIsQ0FBQztRQUVqSSxJQUFJekIsS0FBSztZQUNQQSxJQUFJK2MsYUFBYSxDQUFDcGIsTUFBTUgsQ0FBQyxFQUFFRyxNQUFNRixDQUFDLEVBQUVvYixhQUFhcmIsQ0FBQyxFQUFFcWIsYUFBYXBiLENBQUMsRUFBRXFiLGFBQWF0YixDQUFDLEVBQUVzYixhQUFhcmIsQ0FBQztRQUNwRztJQUNGO0lBRUEsT0FBTzJaLE1BQU1WLFVBQVUsRUFBRTtRQUN2QixJQUFJLEVBQ0ZuRSxPQUFPLEVBQ1IsR0FBR21FO1FBQ0osSUFBSS9ZLFFBQVErWSxXQUFXckQsd0JBQXdCO1FBQy9DLElBQUl3RixlQUFlbkMsV0FBV3ZELGlCQUFpQixDQUFDLE1BQU07UUFDdEQsSUFBSTJGLGVBQWVwQyxXQUFXdEQsaUJBQWlCO1FBQy9DLE9BQU87WUFDTGI7WUFDQTVVO1lBQ0FrYjtZQUNBQztRQUNGO0lBQ0Y7SUFFQTFCLE1BQU1wYixHQUFHLEVBQUVnRSxXQUFXLEVBQUU7UUFDdEIsSUFBSSxFQUNGMFcsVUFBVSxFQUNYLEdBQUcsSUFBSTtRQUNSLElBQUksRUFDRm5FLE9BQU8sRUFDUDVVLEtBQUssRUFDTGtiLFlBQVksRUFDWkMsWUFBWSxFQUNiLEdBQUdyQyxZQUFZVyxLQUFLLENBQUNWO1FBQ3RCQSxXQUFXN0MsU0FBUyxDQUFDaUYsY0FBY0QsY0FBY2xiO1FBQ2pEcUMsWUFBWXVSLGNBQWMsQ0FBQ2dCLFFBQVEvVSxDQUFDLEVBQUUrVSxRQUFROVUsQ0FBQyxFQUFFRSxNQUFNSCxDQUFDLEVBQUVHLE1BQU1GLENBQUMsRUFBRW9iLGFBQWFyYixDQUFDLEVBQUVxYixhQUFhcGIsQ0FBQyxFQUFFcWIsYUFBYXRiLENBQUMsRUFBRXNiLGFBQWFyYixDQUFDO1FBRWpJLElBQUl6QixLQUFLO1lBQ1BBLElBQUkrYyxhQUFhLENBQUNwYixNQUFNSCxDQUFDLEVBQUVHLE1BQU1GLENBQUMsRUFBRW9iLGFBQWFyYixDQUFDLEVBQUVxYixhQUFhcGIsQ0FBQyxFQUFFcWIsYUFBYXRiLENBQUMsRUFBRXNiLGFBQWFyYixDQUFDO1FBQ3BHO0lBQ0Y7SUFFQSxPQUFPNFosTUFBTVgsVUFBVSxFQUFFO1FBQ3ZCLElBQUksRUFDRm5FLE9BQU8sRUFDUixHQUFHbUU7UUFDSixJQUFJbUMsZUFBZW5DLFdBQVd2RCxpQkFBaUIsQ0FBQyxNQUFNO1FBQ3RELElBQUkyRixlQUFlcEMsV0FBV3RELGlCQUFpQjtRQUMvQyxPQUFPO1lBQ0xiO1lBQ0FzRztZQUNBQztRQUNGO0lBQ0Y7SUFFQXpCLE1BQU1yYixHQUFHLEVBQUVnRSxXQUFXLEVBQUU7UUFDdEIsSUFBSSxFQUNGMFcsVUFBVSxFQUNYLEdBQUcsSUFBSTtRQUNSLElBQUksRUFDRm5FLE9BQU8sRUFDUHNHLFlBQVksRUFDWkMsWUFBWSxFQUNiLEdBQUdyQyxZQUFZWSxLQUFLLENBQUNYO1FBQ3RCQSxXQUFXN0MsU0FBUyxDQUFDaUYsY0FBY0QsY0FBY0E7UUFDakQ3WSxZQUFZZ1MsaUJBQWlCLENBQUNPLFFBQVEvVSxDQUFDLEVBQUUrVSxRQUFROVUsQ0FBQyxFQUFFb2IsYUFBYXJiLENBQUMsRUFBRXFiLGFBQWFwYixDQUFDLEVBQUVxYixhQUFhdGIsQ0FBQyxFQUFFc2IsYUFBYXJiLENBQUM7UUFFbEgsSUFBSXpCLEtBQUs7WUFDUEEsSUFBSWdkLGdCQUFnQixDQUFDSCxhQUFhcmIsQ0FBQyxFQUFFcWIsYUFBYXBiLENBQUMsRUFBRXFiLGFBQWF0YixDQUFDLEVBQUVzYixhQUFhcmIsQ0FBQztRQUNyRjtJQUNGO0lBRUEsT0FBTzZaLE1BQU1aLFVBQVUsRUFBRTtRQUN2QixJQUFJLEVBQ0ZuRSxPQUFPLEVBQ1IsR0FBR21FO1FBQ0osSUFBSW1DLGVBQWVuQyxXQUFXckQsd0JBQXdCO1FBQ3REcUQsV0FBV3BFLE9BQU8sR0FBR3VHO1FBQ3JCLElBQUlDLGVBQWVwQyxXQUFXdEQsaUJBQWlCO1FBQy9DLE9BQU87WUFDTGI7WUFDQXNHO1lBQ0FDO1FBQ0Y7SUFDRjtJQUVBeEIsTUFBTXRiLEdBQUcsRUFBRWdFLFdBQVcsRUFBRTtRQUN0QixJQUFJLEVBQ0YwVyxVQUFVLEVBQ1gsR0FBRyxJQUFJO1FBQ1IsSUFBSSxFQUNGbkUsT0FBTyxFQUNQc0csWUFBWSxFQUNaQyxZQUFZLEVBQ2IsR0FBR3JDLFlBQVlhLEtBQUssQ0FBQ1o7UUFDdEJBLFdBQVc3QyxTQUFTLENBQUNpRixjQUFjRCxjQUFjQTtRQUNqRDdZLFlBQVlnUyxpQkFBaUIsQ0FBQ08sUUFBUS9VLENBQUMsRUFBRStVLFFBQVE5VSxDQUFDLEVBQUVvYixhQUFhcmIsQ0FBQyxFQUFFcWIsYUFBYXBiLENBQUMsRUFBRXFiLGFBQWF0YixDQUFDLEVBQUVzYixhQUFhcmIsQ0FBQztRQUVsSCxJQUFJekIsS0FBSztZQUNQQSxJQUFJZ2QsZ0JBQWdCLENBQUNILGFBQWFyYixDQUFDLEVBQUVxYixhQUFhcGIsQ0FBQyxFQUFFcWIsYUFBYXRiLENBQUMsRUFBRXNiLGFBQWFyYixDQUFDO1FBQ3JGO0lBQ0Y7SUFFQSxPQUFPK1osTUFBTWQsVUFBVSxFQUFFO1FBQ3ZCLElBQUksRUFDRm5FLE9BQU8sRUFDUEMsT0FBTyxFQUNSLEdBQUdrRTtRQUNKLElBQUksRUFDRnVDLEVBQUUsRUFDRkMsRUFBRSxFQUNGQyxJQUFJLEVBQ0pDLFFBQVEsRUFDUkMsU0FBUyxFQUNWLEdBQUc3RztRQUNKLElBQUk4RyxnQkFBZ0JILE9BQVF2aUIsQ0FBQUEsS0FBSzZFLEVBQUUsR0FBRyxLQUFJO1FBQzFDLElBQUlxZCxlQUFlcEMsV0FBV3RELGlCQUFpQixJQUFJLHNEQUFzRDtRQUN6RyxrRUFBa0U7UUFDbEUsV0FBVztRQUVYLElBQUltRyxRQUFRLElBQUloYyxNQUFNM0csS0FBS3NTLEdBQUcsQ0FBQ29RLGlCQUFrQi9HLENBQUFBLFFBQVEvVSxDQUFDLEdBQUdzYixhQUFhdGIsQ0FBQyxJQUFJLE1BQU01RyxLQUFLdVMsR0FBRyxDQUFDbVEsaUJBQWtCL0csQ0FBQUEsUUFBUTlVLENBQUMsR0FBR3FiLGFBQWFyYixDQUFDLElBQUksS0FBSyxDQUFDN0csS0FBS3VTLEdBQUcsQ0FBQ21RLGlCQUFrQi9HLENBQUFBLFFBQVEvVSxDQUFDLEdBQUdzYixhQUFhdGIsQ0FBQyxJQUFJLE1BQU01RyxLQUFLc1MsR0FBRyxDQUFDb1EsaUJBQWtCL0csQ0FBQUEsUUFBUTlVLENBQUMsR0FBR3FiLGFBQWFyYixDQUFDLElBQUksTUFBTSxlQUFlO1FBRWpTLElBQUkrYixJQUFJNWlCLEtBQUtxQixHQUFHLENBQUNzaEIsTUFBTS9iLENBQUMsRUFBRSxLQUFLNUcsS0FBS3FCLEdBQUcsQ0FBQ2doQixJQUFJLEtBQUtyaUIsS0FBS3FCLEdBQUcsQ0FBQ3NoQixNQUFNOWIsQ0FBQyxFQUFFLEtBQUs3RyxLQUFLcUIsR0FBRyxDQUFDaWhCLElBQUk7UUFFckYsSUFBSU0sSUFBSSxHQUFHO1lBQ1RQLE1BQU1yaUIsS0FBS29CLElBQUksQ0FBQ3doQjtZQUNoQk4sTUFBTXRpQixLQUFLb0IsSUFBSSxDQUFDd2hCO1FBQ2xCLEVBQUUsV0FBVztRQUdiLElBQUlDLElBQUksQ0FBQ0wsYUFBYUMsWUFBWSxDQUFDLElBQUksS0FBS3ppQixLQUFLb0IsSUFBSSxDQUFDLENBQUNwQixLQUFLcUIsR0FBRyxDQUFDZ2hCLElBQUksS0FBS3JpQixLQUFLcUIsR0FBRyxDQUFDaWhCLElBQUksS0FBS3RpQixLQUFLcUIsR0FBRyxDQUFDZ2hCLElBQUksS0FBS3JpQixLQUFLcUIsR0FBRyxDQUFDc2hCLE1BQU05YixDQUFDLEVBQUUsS0FBSzdHLEtBQUtxQixHQUFHLENBQUNpaEIsSUFBSSxLQUFLdGlCLEtBQUtxQixHQUFHLENBQUNzaEIsTUFBTS9iLENBQUMsRUFBRSxFQUFDLElBQU01RyxDQUFBQSxLQUFLcUIsR0FBRyxDQUFDZ2hCLElBQUksS0FBS3JpQixLQUFLcUIsR0FBRyxDQUFDc2hCLE1BQU05YixDQUFDLEVBQUUsS0FBSzdHLEtBQUtxQixHQUFHLENBQUNpaEIsSUFBSSxLQUFLdGlCLEtBQUtxQixHQUFHLENBQUNzaEIsTUFBTS9iLENBQUMsRUFBRSxFQUFDO1FBRTdQLElBQUlxSixNQUFNNFMsSUFBSTtZQUNaQSxJQUFJO1FBQ047UUFFQSxJQUFJQyxNQUFNLElBQUluYyxNQUFNa2MsSUFBSVIsS0FBS00sTUFBTTliLENBQUMsR0FBR3liLElBQUlPLElBQUksQ0FBQ1AsS0FBS0ssTUFBTS9iLENBQUMsR0FBR3liLEtBQUssU0FBUztRQUU3RSxJQUFJVSxRQUFRLElBQUlwYyxNQUFNLENBQUNnVixRQUFRL1UsQ0FBQyxHQUFHc2IsYUFBYXRiLENBQUMsSUFBSSxNQUFNNUcsS0FBS3NTLEdBQUcsQ0FBQ29RLGlCQUFpQkksSUFBSWxjLENBQUMsR0FBRzVHLEtBQUt1UyxHQUFHLENBQUNtUSxpQkFBaUJJLElBQUlqYyxDQUFDLEVBQUUsQ0FBQzhVLFFBQVE5VSxDQUFDLEdBQUdxYixhQUFhcmIsQ0FBQyxJQUFJLE1BQU03RyxLQUFLdVMsR0FBRyxDQUFDbVEsaUJBQWlCSSxJQUFJbGMsQ0FBQyxHQUFHNUcsS0FBS3NTLEdBQUcsQ0FBQ29RLGlCQUFpQkksSUFBSWpjLENBQUMsR0FBRyxnQkFBZ0I7UUFFdlAsSUFBSW1jLEtBQUt4aEIsYUFBYTtZQUFDO1lBQUc7U0FBRSxFQUFFO1lBQUVtaEIsQ0FBQUEsTUFBTS9iLENBQUMsR0FBR2tjLElBQUlsYyxDQUFDLElBQUl5YjtZQUFLTSxDQUFBQSxNQUFNOWIsQ0FBQyxHQUFHaWMsSUFBSWpjLENBQUMsSUFBSXliO1NBQUcsR0FBRyxLQUFLO1FBQ3RGLGNBQWM7UUFFZCxJQUFJL2dCLElBQUk7WUFBRW9oQixDQUFBQSxNQUFNL2IsQ0FBQyxHQUFHa2MsSUFBSWxjLENBQUMsSUFBSXliO1lBQUtNLENBQUFBLE1BQU05YixDQUFDLEdBQUdpYyxJQUFJamMsQ0FBQyxJQUFJeWI7U0FBRztRQUN4RCxJQUFJbmhCLElBQUk7WUFBRSxFQUFDd2hCLE1BQU0vYixDQUFDLEdBQUdrYyxJQUFJbGMsQ0FBQyxJQUFJeWI7WUFBSyxFQUFDTSxNQUFNOWIsQ0FBQyxHQUFHaWMsSUFBSWpjLENBQUMsSUFBSXliO1NBQUc7UUFDMUQsSUFBSVcsS0FBS3poQixhQUFhRCxHQUFHSixJQUFJLEtBQUs7UUFFbEMsSUFBSUcsYUFBYUMsR0FBR0osTUFBTSxDQUFDLEdBQUc7WUFDNUI4aEIsS0FBS2pqQixLQUFLNkUsRUFBRTtRQUNkO1FBRUEsSUFBSXZELGFBQWFDLEdBQUdKLE1BQU0sR0FBRztZQUMzQjhoQixLQUFLO1FBQ1A7UUFFQSxPQUFPO1lBQ0xmO1lBQ0FHO1lBQ0FDO1lBQ0FHO1lBQ0FDO1lBQ0FLO1lBQ0FDO1lBQ0FDO1FBQ0Y7SUFDRjtJQUVBckMsTUFBTXhiLEdBQUcsRUFBRWdFLFdBQVcsRUFBRTtRQUN0QixJQUFJLEVBQ0YwVyxVQUFVLEVBQ1gsR0FBRyxJQUFJO1FBQ1IsSUFBSSxFQUNGb0MsWUFBWSxFQUNaRyxFQUFFLEVBQ0ZDLEVBQUUsRUFDRkcsU0FBUyxFQUNUQyxhQUFhLEVBQ2JLLEtBQUssRUFDTEMsRUFBRSxFQUNGQyxFQUFFLEVBQ0gsR0FBR3BELFlBQVllLEtBQUssQ0FBQ2QsYUFBYSxjQUFjO1FBRWpELElBQUlvRCxNQUFNLElBQUlULFlBQVksTUFBTSxDQUFDO1FBQ2pDLElBQUlVLEtBQUtILEtBQUtFLE1BQU9ELENBQUFBLEtBQUssR0FBRTtRQUM1QixJQUFJRyxVQUFVLElBQUl6YyxNQUFNb2MsTUFBTW5jLENBQUMsR0FBR3liLEtBQUtyaUIsS0FBS3NTLEdBQUcsQ0FBQzZRLEtBQUtKLE1BQU1sYyxDQUFDLEdBQUd5YixLQUFLdGlCLEtBQUt1UyxHQUFHLENBQUM0UTtRQUM3RXJELFdBQVczQyxjQUFjLENBQUNpRyxTQUFTRCxLQUFLRCxNQUFNbGpCLEtBQUs2RSxFQUFFLEdBQUc7UUFDeERpYixXQUFXM0MsY0FBYyxDQUFDK0UsY0FBY2lCLEtBQUtELE1BQU1sakIsS0FBSzZFLEVBQUU7UUFDMUR1RSxZQUFZeVEsUUFBUSxDQUFDcUksYUFBYXRiLENBQUMsRUFBRXNiLGFBQWFyYixDQUFDLEdBQUcsMENBQTBDO1FBRWhHLElBQUl6QixPQUFPLENBQUM2SyxNQUFNK1MsT0FBTyxDQUFDL1MsTUFBTWdULEtBQUs7WUFDbkMsSUFBSUksSUFBSWhCLEtBQUtDLEtBQUtELEtBQUtDO1lBQ3ZCLElBQUlnQixLQUFLakIsS0FBS0MsS0FBSyxJQUFJRCxLQUFLQztZQUM1QixJQUFJaUIsS0FBS2xCLEtBQUtDLEtBQUtBLEtBQUtELEtBQUs7WUFDN0JqZCxJQUFJb0ksU0FBUyxDQUFDdVYsTUFBTW5jLENBQUMsRUFBRW1jLE1BQU1sYyxDQUFDO1lBQzlCekIsSUFBSXVNLE1BQU0sQ0FBQytRO1lBQ1h0ZCxJQUFJOEIsS0FBSyxDQUFDb2MsSUFBSUM7WUFDZG5lLElBQUlvZSxHQUFHLENBQUMsR0FBRyxHQUFHSCxHQUFHTCxJQUFJQSxLQUFLQyxJQUFJUSxRQUFRLElBQUloQjtZQUMxQ3JkLElBQUk4QixLQUFLLENBQUMsSUFBSW9jLElBQUksSUFBSUM7WUFDdEJuZSxJQUFJdU0sTUFBTSxDQUFDLENBQUMrUTtZQUNadGQsSUFBSW9JLFNBQVMsQ0FBQyxDQUFDdVYsTUFBTW5jLENBQUMsRUFBRSxDQUFDbWMsTUFBTWxjLENBQUM7UUFDbEM7SUFDRjtJQUVBLE9BQU9pYSxNQUFNaEIsVUFBVSxFQUFFO1FBQ3ZCQSxXQUFXbkUsT0FBTyxHQUFHbUUsV0FBV3pYLEtBQUs7SUFDdkM7SUFFQXlZLE1BQU0xYixHQUFHLEVBQUVnRSxXQUFXLEVBQUU7UUFDdEJ5VyxZQUFZaUIsS0FBSyxDQUFDLElBQUksQ0FBQ2hCLFVBQVU7UUFFakMsSUFBSTFhLEtBQUs7WUFDUCwrQ0FBK0M7WUFDL0MsSUFBSWdFLFlBQVltUSxFQUFFLEtBQUtuUSxZQUFZdVEsRUFBRSxJQUFJdlEsWUFBWXNRLEVBQUUsS0FBS3RRLFlBQVl3USxFQUFFLEVBQUU7Z0JBQzFFeFUsSUFBSTBJLFNBQVM7WUFDZjtRQUNGO0lBQ0Y7QUFFRjtBQUVBLE1BQU00VixxQkFBcUI3RDtJQUN6QjFkLFlBQVlDLFNBQVEsRUFBRXRFLElBQUksRUFBRXdXLGdCQUFnQixDQUFFO1FBQzVDLEtBQUssQ0FBQ2xTLFdBQVV0RSxNQUFNd1c7UUFDdEIsSUFBSSxDQUFDdEssSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDMlosU0FBUyxHQUFHLElBQUksQ0FBQ25lLFlBQVksQ0FBQyxlQUFlaEMsU0FBUztRQUMzRCxJQUFJLENBQUNvZ0IsT0FBTyxHQUFHLElBQUksQ0FBQ3BlLFlBQVksQ0FBQyxXQUFXOUMsU0FBUztRQUNyRCxJQUFJLENBQUNtaEIsVUFBVSxHQUFHLElBQUksQ0FBQ3JlLFlBQVksQ0FBQyxlQUFlOUMsU0FBUztJQUM5RDtBQUVGO0FBRUEsTUFBTW9oQixvQkFBb0J2RztJQUN4QnBiLFlBQVlDLFNBQVEsRUFBRXRFLElBQUksRUFBRXdXLGdCQUFnQixDQUFFO1FBQzVDLEtBQUssQ0FBQ2xTLFdBQVV0RSxNQUFNLGVBQWVnbUIsY0FBYyxPQUFPeFA7UUFDMUQsSUFBSSxDQUFDdEssSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDcEQsQ0FBQyxHQUFHO1FBQ1QsSUFBSSxDQUFDQyxDQUFDLEdBQUc7UUFDVCxJQUFJLENBQUNrZCxZQUFZLEdBQUcsQ0FBQztJQUN2QjtJQUVBek4sV0FBV2xSLEdBQUcsRUFBRTtRQUNkLElBQUl1WSxjQUFjamhCLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3RGLEtBQUssQ0FBQzRaLFdBQVdsUixLQUFLdVk7UUFDdEIsSUFBSXFHLGVBQWUsSUFBSSxDQUFDMVUsUUFBUSxDQUFDLHFCQUFxQjdKLGVBQWUsTUFBTSxJQUFJLENBQUM2SixRQUFRLENBQUMsc0JBQXNCN0osZUFBZTtRQUU5SCxJQUFJdWUsY0FBYztZQUNoQjVlLElBQUk0ZSxZQUFZLEdBQUdBO1FBQ3JCO0lBQ0Y7SUFFQUMsd0JBQXdCO1FBQ3RCLElBQUksQ0FBQ3JkLENBQUMsR0FBRztRQUNULElBQUksQ0FBQ0MsQ0FBQyxHQUFHO1FBQ1QsSUFBSSxDQUFDcWQsU0FBUyxHQUFHLEVBQUU7UUFDbkIsSUFBSSxDQUFDQyxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDaFksSUFBSSxHQUFHcU4sT0FBTzRLLGlCQUFpQjtRQUNwQyxJQUFJLENBQUNDLElBQUksR0FBRzdLLE9BQU84SyxpQkFBaUI7SUFDdEM7SUFFQXZELGVBQWUzYixHQUFHLEVBQUU7UUFDbEIsSUFBSSxJQUFJLENBQUM0RSxJQUFJLEtBQUssUUFBUTtZQUN4QixPQUFPLElBQUksQ0FBQ3VhLHNCQUFzQixDQUFDbmY7UUFDckMsRUFBRSxtQ0FBbUM7UUFHckMsSUFBSSxDQUFDNmUscUJBQXFCO1FBQzFCLElBQUksQ0FBQ08sK0JBQStCLENBQUNwZjtRQUNyQyxJQUFJZ0UsY0FBYyxNQUFNLDhCQUE4QjtRQUV0RCxJQUFJLENBQUN5TCxRQUFRLENBQUNoTSxPQUFPLENBQUMsQ0FBQzJDLEdBQUcxRjtZQUN4QixJQUFJMmUsbUJBQW1CLElBQUksQ0FBQ0MsbUJBQW1CLENBQUN0ZixLQUFLLElBQUksRUFBRSxJQUFJLEVBQUVVO1lBRWpFLElBQUksQ0FBQ3NELGFBQWE7Z0JBQ2hCQSxjQUFjcWI7WUFDaEIsT0FBTztnQkFDTHJiLFlBQVk0USxjQUFjLENBQUN5SztZQUM3QjtRQUNGO1FBQ0EsT0FBT3JiO0lBQ1Q7SUFFQXViLGNBQWM7UUFDWixJQUFJLEVBQ0Z2aUIsVUFBQUEsU0FBUSxFQUNSMkcsTUFBTSxFQUNQLEdBQUcsSUFBSTtRQUNSLElBQUk2YixrQkFBa0JsTSxLQUFLNVIsS0FBSyxDQUFDMUUsVUFBU2dELEdBQUcsQ0FBQzJULElBQUksRUFBRUgsUUFBUTtRQUM1RCxJQUFJQSxXQUFXN1AsT0FBT3VHLFFBQVEsQ0FBQyxhQUFhOUwsU0FBUyxDQUFDb2hCO1FBQ3RELE9BQU9oTTtJQUNUO0lBRUEyTCx1QkFBdUJuZixHQUFHLEVBQUU7UUFDMUIsSUFBSXdULFdBQVcsSUFBSSxDQUFDK0wsV0FBVztRQUMvQixPQUFPLElBQUlyTCxZQUFZLElBQUksQ0FBQzFTLENBQUMsRUFBRSxJQUFJLENBQUNDLENBQUMsR0FBRytSLFVBQVUsSUFBSSxDQUFDaFMsQ0FBQyxHQUFHLElBQUksQ0FBQ2llLFdBQVcsQ0FBQ3pmLE1BQU0sSUFBSSxDQUFDeUIsQ0FBQztJQUMxRjtJQUVBaWUsU0FBUy9MLElBQUksRUFBRTFILElBQUksRUFBRXZMLENBQUMsRUFBRTtRQUN0QixJQUFJaWYsT0FBTzFULElBQUksQ0FBQ3ZMLEVBQUU7UUFDbEIsSUFBSWtmLFFBQVE7UUFFWixJQUFJak0sS0FBS2tNLFFBQVEsRUFBRTtZQUNqQixJQUFJcmYsTUFBTXlMLEtBQUsxVSxNQUFNO1lBQ3JCLElBQUl1b0IsV0FBVzdULElBQUksQ0FBQ3ZMLElBQUksRUFBRTtZQUMxQixJQUFJcWYsV0FBVzlULElBQUksQ0FBQ3ZMLElBQUksRUFBRTtZQUMxQixJQUFJK2QsYUFBYTtZQUVqQixJQUFJLENBQUMvZCxNQUFNLEtBQUtvZixhQUFhLEdBQUUsS0FBTXBmLElBQUlGLE1BQU0sS0FBS3VmLGFBQWEsS0FBSztnQkFDcEV0QixhQUFhO1lBQ2Y7WUFFQSxJQUFJL2QsSUFBSSxLQUFLb2YsYUFBYSxPQUFPcGYsSUFBSUYsTUFBTSxLQUFLdWYsYUFBYSxLQUFLO2dCQUNoRXRCLGFBQWE7WUFDZjtZQUVBLElBQUkvZCxJQUFJLEtBQUtvZixhQUFhLE9BQVFwZixDQUFBQSxNQUFNRixNQUFNLEtBQUt1ZixhQUFhLEdBQUUsR0FBSTtnQkFDcEV0QixhQUFhO1lBQ2Y7WUFFQSxJQUFJLE9BQU85SyxLQUFLcU0sTUFBTSxDQUFDTCxLQUFLLEtBQUssYUFBYTtnQkFDNUMsWUFBWTtnQkFDWixJQUFJTSxhQUFhdE0sS0FBS3FNLE1BQU0sQ0FBQ0wsS0FBSztnQkFDbENDLFFBQVFLLHNCQUFzQjNCLGVBQWUyQixhQUFhQSxVQUFVLENBQUN4QixXQUFXO1lBQ2xGO1FBQ0YsT0FBTztZQUNMbUIsUUFBUWpNLEtBQUtxTSxNQUFNLENBQUNMLEtBQUs7UUFDM0I7UUFFQSxJQUFJLENBQUNDLE9BQU87WUFDVkEsUUFBUWpNLEtBQUt1TSxZQUFZO1FBQzNCO1FBRUEsT0FBT047SUFDVDtJQUVBdFAsVUFBVTtRQUNSLE9BQU87SUFDVDtJQUVBNlAsZ0JBQWdCem5CLElBQUksRUFBRTtRQUNwQixJQUFJMFgsV0FBVzFYLFFBQVEsSUFBSSxDQUFDQSxJQUFJO1FBQ2hDLElBQUl1WCxhQUFhTixNQUFNQyxJQUFJLENBQUNRLFNBQVNnUSxVQUFVLENBQUNuUSxVQUFVO1FBQzFELElBQUluWCxRQUFRbVgsV0FBV3dDLE9BQU8sQ0FBQ3JDO1FBQy9CLElBQUlpUSxZQUFZcFEsV0FBVzFZLE1BQU0sR0FBRztRQUNwQyxJQUFJMFUsT0FBTy9TLGVBQ1gsbUJBQW1CO1FBQ25Ca1gsU0FBU3JFLFdBQVcsSUFBSTtRQUV4QixJQUFJalQsVUFBVSxHQUFHO1lBQ2ZtVCxPQUFPNVMsU0FBUzRTO1FBQ2xCO1FBRUEsSUFBSW5ULFVBQVV1bkIsV0FBVztZQUN2QnBVLE9BQU8zUyxVQUFVMlM7UUFDbkI7UUFFQSxPQUFPQTtJQUNUO0lBRUFrRixlQUFlblIsR0FBRyxFQUFFO1FBQ2xCLElBQUksSUFBSSxDQUFDNEUsSUFBSSxLQUFLLFFBQVE7WUFDeEIsSUFBSSxDQUFDMGIsc0JBQXNCLENBQUN0Z0I7WUFDNUI7UUFDRixFQUFFLG1DQUFtQztRQUdyQyxJQUFJLENBQUM2ZSxxQkFBcUI7UUFDMUIsSUFBSSxDQUFDTywrQkFBK0IsQ0FBQ3BmLE1BQU0sY0FBYztRQUV6RCxJQUFJLENBQUN5UCxRQUFRLENBQUNoTSxPQUFPLENBQUMsQ0FBQzJDLEdBQUcxRjtZQUN4QixJQUFJLENBQUM2ZixXQUFXLENBQUN2Z0IsS0FBSyxJQUFJLEVBQUUsSUFBSSxFQUFFVTtRQUNwQztRQUNBLElBQUksRUFDRjJFLEtBQUssRUFDTixHQUFHLElBQUksQ0FBQ3JJLFFBQVEsQ0FBQ21DLE1BQU0sRUFBRSxvREFBb0Q7UUFFOUUsSUFBSWtHLE1BQU1yQyxTQUFTLElBQUk7WUFDckJxQyxNQUFNdEIsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQzRYLGNBQWMsQ0FBQzNiO1FBQ25EO0lBQ0Y7SUFFQXNnQix1QkFBdUJ0Z0IsR0FBRyxFQUFFO1FBQzFCLElBQUksRUFDRmhELFVBQUFBLFNBQVEsRUFDUjJHLE1BQU0sRUFDUCxHQUFHLElBQUk7UUFDUixJQUFJNmMsYUFBYSxJQUFJLENBQUNsUSxPQUFPO1FBQzdCLElBQUltUSxhQUFhOWMsT0FBT3VHLFFBQVEsQ0FBQyxlQUFleEssYUFBYTtRQUU3RCxJQUFJK2dCLFlBQVk7WUFDZCxJQUFJLEVBQ0ZDLFVBQVUsRUFDWCxHQUFHRCxXQUFXRSxRQUFRO1lBQ3ZCLElBQUlDLFVBQVV0TixLQUFLNVIsS0FBSyxDQUFDMUUsVUFBU2dELEdBQUcsQ0FBQzJULElBQUk7WUFDMUMsSUFBSUgsV0FBVzdQLE9BQU91RyxRQUFRLENBQUMsYUFBYTlMLFNBQVMsQ0FBQ3dpQixRQUFRcE4sUUFBUTtZQUN0RSxJQUFJUCxZQUFZdFAsT0FBT3VHLFFBQVEsQ0FBQyxjQUFjNU0sU0FBUyxDQUFDc2pCLFFBQVEzTixTQUFTO1lBQ3pFLElBQUluUixRQUFRMFIsV0FBV2tOO1lBQ3ZCLElBQUl6VSxPQUFPd1UsV0FBV0ksS0FBSyxHQUFHTCxXQUFXcGpCLEtBQUssQ0FBQyxJQUFJMGpCLE9BQU8sR0FBR2xsQixJQUFJLENBQUMsTUFBTTRrQjtZQUN4RSxJQUFJTyxLQUFLeG5CLFVBQVVvSyxPQUFPdkQsWUFBWSxDQUFDLE1BQU05QyxTQUFTO1lBQ3RELElBQUlrRCxNQUFNeUwsS0FBSzFVLE1BQU07WUFFckIsSUFBSyxJQUFJbUosSUFBSSxHQUFHQSxJQUFJRixLQUFLRSxJQUFLO2dCQUM1QixJQUFJa2YsUUFBUSxJQUFJLENBQUNGLFFBQVEsQ0FBQ2UsWUFBWXhVLE1BQU12TDtnQkFDNUNWLElBQUlvSSxTQUFTLENBQUMsSUFBSSxDQUFDNUcsQ0FBQyxFQUFFLElBQUksQ0FBQ0MsQ0FBQztnQkFDNUJ6QixJQUFJOEIsS0FBSyxDQUFDQSxPQUFPLENBQUNBO2dCQUNsQixJQUFJa2YsS0FBS2hoQixJQUFJbVosU0FBUztnQkFDdEJuWixJQUFJbVosU0FBUyxHQUFHblosSUFBSW1aLFNBQVMsR0FBR3VILGFBQWFsTjtnQkFFN0MsSUFBSVAsY0FBYyxVQUFVO29CQUMxQmpULElBQUlzQyxTQUFTLENBQUMsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHO2dCQUNoQztnQkFFQXNkLE1BQU1yVyxNQUFNLENBQUN2SjtnQkFFYixJQUFJaVQsY0FBYyxVQUFVO29CQUMxQmpULElBQUlzQyxTQUFTLENBQUMsR0FBRyxHQUFHLENBQUMsSUFBSSxHQUFHLEdBQUc7Z0JBQ2pDO2dCQUVBdEMsSUFBSW1aLFNBQVMsR0FBRzZIO2dCQUNoQmhoQixJQUFJOEIsS0FBSyxDQUFDLElBQUlBLE9BQU8sQ0FBQyxJQUFJQTtnQkFDMUI5QixJQUFJb0ksU0FBUyxDQUFDLENBQUMsSUFBSSxDQUFDNUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDQyxDQUFDO2dCQUM5QixJQUFJLENBQUNELENBQUMsSUFBSWdTLFdBQVlvTSxDQUFBQSxNQUFNckIsU0FBUyxJQUFJa0MsV0FBV2xDLFNBQVMsSUFBSW1DO2dCQUVqRSxJQUFJLE9BQU9LLEVBQUUsQ0FBQ3JnQixFQUFFLEtBQUssZUFBZSxDQUFDbUssTUFBTWtXLEVBQUUsQ0FBQ3JnQixFQUFFLEdBQUc7b0JBQ2pELElBQUksQ0FBQ2MsQ0FBQyxJQUFJdWYsRUFBRSxDQUFDcmdCLEVBQUU7Z0JBQ2pCO1lBQ0Y7WUFFQTtRQUNGO1FBRUEsSUFBSSxFQUNGYyxDQUFDLEVBQ0RDLENBQUMsRUFDRixHQUFHLElBQUksRUFBRSxZQUFZO1FBQ3RCLHFDQUFxQztRQUNyQywwQkFBMEI7UUFDMUIsc0NBQXNDO1FBQ3RDLEtBQUs7UUFDTCx3QkFBd0I7UUFDeEIsb0NBQW9DO1FBQ3BDLEtBQUs7UUFDTCxXQUFXO1FBRVgsSUFBSXpCLElBQUk0WSxTQUFTLEVBQUU7WUFDakI1WSxJQUFJaWhCLFFBQVEsQ0FBQ1QsWUFBWWhmLEdBQUdDO1FBQzlCO1FBRUEsSUFBSXpCLElBQUl1RyxXQUFXLEVBQUU7WUFDbkJ2RyxJQUFJa2hCLFVBQVUsQ0FBQ1YsWUFBWWhmLEdBQUdDO1FBQ2hDLEVBQUUsSUFBSTtJQUVSO0lBRUEwZixpQkFBaUI7UUFDZixJQUFJLElBQUksQ0FBQ3BDLGNBQWMsSUFBSSxJQUFJLENBQUNELFNBQVMsQ0FBQ3ZuQixNQUFNLEVBQUU7WUFDaEQ7UUFDRixFQUFFLDRHQUE0RztRQUM5RywrR0FBK0c7UUFDL0csa0NBQWtDO1FBR2xDLElBQUk2cEIsZUFBZSxJQUFJLENBQUN0QyxTQUFTLENBQUMsSUFBSSxDQUFDQyxjQUFjLENBQUM7UUFDdEQsSUFBSXNDLGFBQWFELGFBQWFsWCxRQUFRLENBQUMsZUFBZTVNLFNBQVMsQ0FBQztRQUNoRSxJQUFJdWpCLFFBQVEsT0FBTyx3QkFBd0I7UUFFM0MsSUFBSVMsUUFBUTtRQUVaLElBQUlELGVBQWUsV0FBVyxDQUFDUixTQUFTUSxlQUFlLFNBQVNSLE9BQU87WUFDckVTLFFBQVFGLGFBQWE1ZixDQUFDLEdBQUcsSUFBSSxDQUFDdUYsSUFBSTtRQUNwQyxPQUFPLElBQUlzYSxlQUFlLFNBQVMsQ0FBQ1IsU0FBU1EsZUFBZSxXQUFXUixPQUFPO1lBQzVFUyxRQUFRRixhQUFhNWYsQ0FBQyxHQUFHLElBQUksQ0FBQ3lkLElBQUk7UUFDcEMsT0FBTztZQUNMcUMsUUFBUUYsYUFBYTVmLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQ3VGLElBQUksR0FBRyxJQUFJLENBQUNrWSxJQUFJLElBQUk7UUFDckQ7UUFFQSxJQUFLLElBQUl2ZSxJQUFJLElBQUksQ0FBQ3FlLGNBQWMsRUFBRXJlLElBQUksSUFBSSxDQUFDb2UsU0FBUyxDQUFDdm5CLE1BQU0sRUFBRW1KLElBQUs7WUFDaEUsSUFBSSxDQUFDb2UsU0FBUyxDQUFDcGUsRUFBRSxDQUFDYyxDQUFDLElBQUk4ZjtRQUN6QixFQUFFLGtCQUFrQjtRQUdwQixJQUFJLENBQUN2YSxJQUFJLEdBQUdxTixPQUFPNEssaUJBQWlCO1FBQ3BDLElBQUksQ0FBQ0MsSUFBSSxHQUFHN0ssT0FBTzhLLGlCQUFpQjtRQUNwQyxJQUFJLENBQUNILGNBQWMsR0FBRyxJQUFJLENBQUNELFNBQVMsQ0FBQ3ZuQixNQUFNO0lBQzdDO0lBRUE2bkIsZ0NBQWdDcGYsR0FBRyxFQUFFO1FBQ25DLElBQUksQ0FBQ3lQLFFBQVEsQ0FBQ2hNLE9BQU8sQ0FBQyxDQUFDMkMsR0FBRzFGO1lBQ3hCLElBQUksQ0FBQzZnQixtQ0FBbUMsQ0FBQ3ZoQixLQUFLLElBQUksRUFBRSxJQUFJLEVBQUVVO1FBQzVEO1FBQ0EsSUFBSSxDQUFDeWdCLGNBQWM7SUFDckI7SUFFQUksb0NBQW9DdmhCLEdBQUcsRUFBRXdoQixVQUFVLEVBQUU3ZCxNQUFNLEVBQUVqRCxDQUFDLEVBQUU7UUFDOUQsSUFBSTZRLFFBQVE1TixPQUFPOEwsUUFBUSxDQUFDL08sRUFBRTtRQUU5QixJQUFJNlEsTUFBTTlCLFFBQVEsQ0FBQ2xZLE1BQU0sR0FBRyxHQUFHO1lBQzdCZ2EsTUFBTTlCLFFBQVEsQ0FBQ2hNLE9BQU8sQ0FBQyxDQUFDMkMsR0FBRzFGO2dCQUN6QjhnQixXQUFXRCxtQ0FBbUMsQ0FBQ3ZoQixLQUFLd2hCLFlBQVlqUSxPQUFPN1E7WUFDekU7UUFDRixPQUFPO1lBQ0wsMEJBQTBCO1lBQzFCLElBQUksQ0FBQytnQixzQkFBc0IsQ0FBQ3poQixLQUFLd2hCLFlBQVk3ZCxRQUFRakQ7UUFDdkQ7SUFDRjtJQUVBK2dCLHVCQUF1QnpoQixHQUFHLEVBQUV3aEIsVUFBVSxFQUFFN2QsTUFBTSxFQUFFakQsQ0FBQyxFQUFFO1FBQ2pELElBQUk2USxRQUFRNU4sT0FBTzhMLFFBQVEsQ0FBQy9PLEVBQUU7UUFFOUIsSUFBSSxPQUFPNlEsTUFBTWtPLFdBQVcsS0FBSyxZQUFZO1lBQzNDLE9BQU9sTztRQUNUO1FBRUF2UixJQUFJOFEsSUFBSTtRQUNSUyxNQUFNTCxVQUFVLENBQUNsUixLQUFLO1FBQ3RCLElBQUkwaEIsUUFBUW5RLE1BQU1uUixZQUFZLENBQUM7UUFDL0IsSUFBSXVoQixRQUFRcFEsTUFBTW5SLFlBQVksQ0FBQztRQUMvQixJQUFJd2hCLFNBQVNyUSxNQUFNblIsWUFBWSxDQUFDO1FBQ2hDLElBQUl5aEIsU0FBU3RRLE1BQU1uUixZQUFZLENBQUM7UUFDaEMsSUFBSXFnQixhQUFhbFAsTUFBTXJILFFBQVEsQ0FBQyxlQUFleEssYUFBYTtRQUM1RCxJQUFJbWhCLFFBQVF4QyxRQUFRb0MsZUFBZUEsV0FBV0ksS0FBSztRQUVuRCxJQUFJbmdCLE1BQU0sR0FBRztZQUNYLDBFQUEwRTtZQUMxRSx3REFBd0Q7WUFDeEQsSUFBSSxDQUFDZ2hCLE1BQU1sa0IsUUFBUSxJQUFJO2dCQUNyQmtrQixNQUFNempCLFFBQVEsQ0FBQ3NULE1BQU11USxxQkFBcUIsQ0FBQztZQUM3QztZQUVBLElBQUksQ0FBQ0gsTUFBTW5rQixRQUFRLElBQUk7Z0JBQ3JCbWtCLE1BQU0xakIsUUFBUSxDQUFDc1QsTUFBTXVRLHFCQUFxQixDQUFDO1lBQzdDO1lBRUEsSUFBSSxDQUFDRixPQUFPcGtCLFFBQVEsSUFBSTtnQkFDdEJva0IsT0FBTzNqQixRQUFRLENBQUNzVCxNQUFNdVEscUJBQXFCLENBQUM7WUFDOUM7WUFFQSxJQUFJLENBQUNELE9BQU9ya0IsUUFBUSxJQUFJO2dCQUN0QnFrQixPQUFPNWpCLFFBQVEsQ0FBQ3NULE1BQU11USxxQkFBcUIsQ0FBQztZQUM5QztRQUNGO1FBRUEsSUFBSWhxQixRQUFReVosTUFBTWtPLFdBQVcsQ0FBQ3pmO1FBRTlCLElBQUk2Z0IsT0FBTztZQUNUVyxXQUFXaGdCLENBQUMsSUFBSTFKO1FBQ2xCO1FBRUEsSUFBSTRwQixNQUFNbGtCLFFBQVEsSUFBSTtZQUNwQixrREFBa0Q7WUFDbERna0IsV0FBV0wsY0FBYztZQUN6QjVQLE1BQU0vUCxDQUFDLEdBQUdrZ0IsTUFBTTdpQixTQUFTLENBQUM7WUFFMUIsSUFBSStpQixPQUFPcGtCLFFBQVEsSUFBSTtnQkFDckIrVCxNQUFNL1AsQ0FBQyxJQUFJb2dCLE9BQU8vaUIsU0FBUyxDQUFDO1lBQzlCO1FBQ0YsT0FBTztZQUNMLElBQUkraUIsT0FBT3BrQixRQUFRLElBQUk7Z0JBQ3JCZ2tCLFdBQVdoZ0IsQ0FBQyxJQUFJb2dCLE9BQU8vaUIsU0FBUyxDQUFDO1lBQ25DO1lBRUEwUyxNQUFNL1AsQ0FBQyxHQUFHZ2dCLFdBQVdoZ0IsQ0FBQztRQUN4QjtRQUVBZ2dCLFdBQVdoZ0IsQ0FBQyxHQUFHK1AsTUFBTS9QLENBQUM7UUFFdEIsSUFBSSxDQUFDcWYsT0FBTztZQUNWVyxXQUFXaGdCLENBQUMsSUFBSTFKO1FBQ2xCO1FBRUEsSUFBSTZwQixNQUFNbmtCLFFBQVEsSUFBSTtZQUNwQitULE1BQU05UCxDQUFDLEdBQUdrZ0IsTUFBTTlpQixTQUFTLENBQUM7WUFFMUIsSUFBSWdqQixPQUFPcmtCLFFBQVEsSUFBSTtnQkFDckIrVCxNQUFNOVAsQ0FBQyxJQUFJb2dCLE9BQU9oakIsU0FBUyxDQUFDO1lBQzlCO1FBQ0YsT0FBTztZQUNMLElBQUlnakIsT0FBT3JrQixRQUFRLElBQUk7Z0JBQ3JCZ2tCLFdBQVcvZixDQUFDLElBQUlvZ0IsT0FBT2hqQixTQUFTLENBQUM7WUFDbkM7WUFFQTBTLE1BQU05UCxDQUFDLEdBQUcrZixXQUFXL2YsQ0FBQztRQUN4QjtRQUVBK2YsV0FBVy9mLENBQUMsR0FBRzhQLE1BQU05UCxDQUFDLEVBQUUsMkNBQTJDO1FBRW5FK2YsV0FBVzFDLFNBQVMsQ0FBQzVkLElBQUksQ0FBQ3FRO1FBQzFCaVEsV0FBV3phLElBQUksR0FBR25NLEtBQUt3RSxHQUFHLENBQUNvaUIsV0FBV3phLElBQUksRUFBRXdLLE1BQU0vUCxDQUFDLEVBQUUrUCxNQUFNL1AsQ0FBQyxHQUFHMUo7UUFDL0QwcEIsV0FBV3ZDLElBQUksR0FBR3JrQixLQUFLMEUsR0FBRyxDQUFDa2lCLFdBQVd2QyxJQUFJLEVBQUUxTixNQUFNL1AsQ0FBQyxFQUFFK1AsTUFBTS9QLENBQUMsR0FBRzFKO1FBQy9EeVosTUFBTUgsWUFBWSxDQUFDcFI7UUFDbkJBLElBQUlxUixPQUFPO1FBQ1gsT0FBT0U7SUFDVDtJQUVBK04sb0JBQW9CdGYsR0FBRyxFQUFFd2hCLFVBQVUsRUFBRTdkLE1BQU0sRUFBRWpELENBQUMsRUFBRTtRQUM5QyxJQUFJNlEsUUFBUTVOLE9BQU84TCxRQUFRLENBQUMvTyxFQUFFLEVBQUUsbUJBQW1CO1FBRW5ELElBQUksT0FBTzZRLE1BQU1vSyxjQUFjLEtBQUssWUFBWTtZQUM5QyxPQUFPO1FBQ1Q7UUFFQSxJQUFJM1gsY0FBY3VOLE1BQU1vSyxjQUFjLENBQUMzYjtRQUV2QyxJQUFJLENBQUNnRSxhQUFhO1lBQ2hCLE9BQU87UUFDVDtRQUVBdU4sTUFBTTlCLFFBQVEsQ0FBQ2hNLE9BQU8sQ0FBQyxDQUFDMkMsR0FBRzFGO1lBQ3pCLElBQUkyZSxtQkFBbUJtQyxXQUFXbEMsbUJBQW1CLENBQUN0ZixLQUFLd2hCLFlBQVlqUSxPQUFPN1E7WUFDOUVzRCxZQUFZNFEsY0FBYyxDQUFDeUs7UUFDN0I7UUFDQSxPQUFPcmI7SUFDVDtJQUVBdWMsWUFBWXZnQixHQUFHLEVBQUV3aEIsVUFBVSxFQUFFN2QsTUFBTSxFQUFFakQsQ0FBQyxFQUFFO1FBQ3RDLElBQUk2USxRQUFRNU4sT0FBTzhMLFFBQVEsQ0FBQy9PLEVBQUU7UUFDOUI2USxNQUFNaEksTUFBTSxDQUFDdko7UUFDYnVSLE1BQU05QixRQUFRLENBQUNoTSxPQUFPLENBQUMsQ0FBQzJDLEdBQUcxRjtZQUN6QjhnQixXQUFXakIsV0FBVyxDQUFDdmdCLEtBQUt3aEIsWUFBWWpRLE9BQU83UTtRQUNqRDtJQUNGO0lBRUErZSxZQUFZemYsR0FBRyxFQUFFO1FBQ2YsSUFBSSxFQUNGMmUsWUFBWSxFQUNiLEdBQUcsSUFBSTtRQUVSLElBQUksQ0FBQ0EsY0FBYztZQUNqQixPQUFPQTtRQUNUO1FBRUEsSUFBSTZCLGFBQWEsSUFBSSxDQUFDbFEsT0FBTztRQUM3QixJQUFJeVIsVUFBVSxJQUFJLENBQUNDLGlCQUFpQixDQUFDaGlCLEtBQUt3Z0I7UUFDMUMsSUFBSSxDQUFDN0IsWUFBWSxHQUFHb0Q7UUFDcEIsT0FBT0E7SUFDVDtJQUVBQyxrQkFBa0JoaUIsR0FBRyxFQUFFaWlCLFVBQVUsRUFBRTtRQUNqQyxJQUFJLENBQUNBLFdBQVcxcUIsTUFBTSxFQUFFO1lBQ3RCLE9BQU87UUFDVDtRQUVBLElBQUksRUFDRm9NLE1BQU0sRUFDUCxHQUFHLElBQUk7UUFDUixJQUFJOGMsYUFBYTljLE9BQU91RyxRQUFRLENBQUMsZUFBZXhLLGFBQWE7UUFFN0QsSUFBSStnQixZQUFZO1lBQ2QsSUFBSWpOLFdBQVcsSUFBSSxDQUFDK0wsV0FBVztZQUMvQixJQUFJdFQsT0FBT3dVLFdBQVdJLEtBQUssR0FBR29CLFdBQVc3a0IsS0FBSyxDQUFDLElBQUkwakIsT0FBTyxHQUFHbGxCLElBQUksQ0FBQyxNQUFNcW1CO1lBQ3hFLElBQUlsQixLQUFLeG5CLFVBQVVvSyxPQUFPdkQsWUFBWSxDQUFDLE1BQU05QyxTQUFTO1lBQ3RELElBQUlrRCxNQUFNeUwsS0FBSzFVLE1BQU07WUFDckIsSUFBSTJxQixXQUFXO1lBRWYsSUFBSyxJQUFJeGhCLElBQUksR0FBR0EsSUFBSUYsS0FBS0UsSUFBSztnQkFDNUIsSUFBSWtmLFFBQVEsSUFBSSxDQUFDRixRQUFRLENBQUNlLFlBQVl4VSxNQUFNdkw7Z0JBQzVDd2hCLFlBQVksQ0FBQ3RDLE1BQU1yQixTQUFTLElBQUlrQyxXQUFXbEMsU0FBUyxJQUFJL0ssV0FBV2lOLFdBQVdFLFFBQVEsQ0FBQ0QsVUFBVTtnQkFFakcsSUFBSSxPQUFPSyxFQUFFLENBQUNyZ0IsRUFBRSxLQUFLLGVBQWUsQ0FBQ21LLE1BQU1rVyxFQUFFLENBQUNyZ0IsRUFBRSxHQUFHO29CQUNqRHdoQixZQUFZbkIsRUFBRSxDQUFDcmdCLEVBQUU7Z0JBQ25CO1lBQ0Y7WUFFQSxPQUFPd2hCO1FBQ1Q7UUFFQSxJQUFJLENBQUNsaUIsSUFBSXlmLFdBQVcsRUFBRTtZQUNwQixPQUFPd0MsV0FBVzFxQixNQUFNLEdBQUc7UUFDN0I7UUFFQXlJLElBQUk4USxJQUFJO1FBQ1IsSUFBSSxDQUFDSSxVQUFVLENBQUNsUixLQUFLO1FBQ3JCLElBQUksRUFDRmxJLE9BQU9pcUIsT0FBTyxFQUNmLEdBQUcvaEIsSUFBSXlmLFdBQVcsQ0FBQ3dDO1FBQ3BCLElBQUksQ0FBQzdRLFlBQVksQ0FBQ3BSO1FBQ2xCQSxJQUFJcVIsT0FBTztRQUNYLE9BQU8wUTtJQUNUO0lBQ0E7Ozs7O0dBS0MsR0FHREQsc0JBQXNCaG9CLElBQUksRUFBRTtRQUMxQiw0RUFBNEU7UUFDNUUsSUFBSXljLFVBQVUsSUFBSTtRQUVsQixNQUFPQSxtQkFBbUJtSSxlQUFlbkksUUFBUWhFLFlBQVksR0FBSTtZQUMvRCxJQUFJNFAsYUFBYTVMLFFBQVE1UyxNQUFNLENBQUN2RCxZQUFZLENBQUN0RztZQUU3QyxJQUFJcW9CLFdBQVcza0IsUUFBUSxDQUFDLE9BQU87Z0JBQzdCLE9BQU8ya0IsV0FBV2prQixRQUFRLENBQUM7WUFDN0I7WUFFQXFZLFVBQVVBLFFBQVE1UyxNQUFNO1FBQzFCO1FBRUEsT0FBTztJQUNUO0FBRUY7QUFFQSxNQUFNeWUscUJBQXFCMUQ7SUFDekIzaEIsWUFBWUMsU0FBUSxFQUFFdEUsSUFBSSxFQUFFd1csZ0JBQWdCLENBQUU7UUFDNUMsS0FBSyxDQUFDbFMsV0FBVXRFLE1BQU0sZUFBZTBwQixlQUFlLE9BQU9sVDtRQUMzRCxJQUFJLENBQUN0SyxJQUFJLEdBQUcsU0FBUyxvREFBb0Q7UUFFekUsSUFBSSxDQUFDcUgsSUFBSSxHQUFHLElBQUksQ0FBQ3dELFFBQVEsQ0FBQ2xZLE1BQU0sR0FBRyxJQUFJLEtBQUssSUFBSSxDQUFDNG9CLGVBQWU7SUFDbEU7SUFFQTdQLFVBQVU7UUFDUixPQUFPLElBQUksQ0FBQ3JFLElBQUk7SUFDbEI7QUFFRjtBQUVBLE1BQU1vVyxpQkFBaUJEO0lBQ3JCcmxCLGFBQWM7UUFDWixLQUFLLElBQUl6RjtRQUNULElBQUksQ0FBQ3NOLElBQUksR0FBRztJQUNkO0FBRUY7QUFFQSxNQUFNMGQsbUJBQW1Cbks7SUFDdkJwYixhQUFjO1FBQ1osS0FBSyxJQUFJekY7UUFDVCxJQUFJLENBQUNzTixJQUFJLEdBQUc7UUFDWixJQUFJLENBQUMyZCxJQUFJLEdBQUc7SUFDZDtJQUVBclIsV0FBV2xSLEdBQUcsRUFBRTtRQUNkLElBQUl3aUI7UUFFSixJQUFJLEVBQ0Z4bEIsVUFBQUEsU0FBUSxFQUNULEdBQUcsSUFBSTtRQUNSLElBQUksRUFDRm1DLE1BQU0sRUFDTnpILFFBQUFBLE9BQU0sRUFDUCxHQUFHc0Y7UUFDSixJQUFJcEUsU0FBU29ILElBQUlwSCxNQUFNO1FBQ3ZCdUcsT0FBT21ILFdBQVcsQ0FBQ3RHO1FBRW5CLElBQUlwSCxPQUFPMkssS0FBSyxJQUFJLE9BQU92RCxJQUFJMlQsSUFBSSxLQUFLLGVBQWVqYyxXQUFVLE9BQU9BLFFBQU8rcUIsZ0JBQWdCLEtBQUssYUFBYTtZQUMvR3ppQixJQUFJMlQsSUFBSSxHQUFHamMsUUFBTytxQixnQkFBZ0IsQ0FBQzdwQixRQUFROHBCLGdCQUFnQixDQUFDO1lBQzVELElBQUlDLGVBQWUsSUFBSTdsQixTQUFTRSxXQUFVLFlBQVlzVyxLQUFLNVIsS0FBSyxDQUFDMUIsSUFBSTJULElBQUksRUFBRUgsUUFBUTtZQUVuRixJQUFJbVAsYUFBYW5sQixRQUFRLElBQUk7Z0JBQzNCUixVQUFTeUIsVUFBVSxHQUFHa2tCLGFBQWE5akIsU0FBUyxDQUFDO2dCQUM3QzdCLFVBQVMyQixNQUFNLEdBQUczQixVQUFTeUIsVUFBVTtZQUN2QztRQUNGLEVBQUUsdUJBQXVCO1FBR3pCLElBQUksQ0FBQyxJQUFJLENBQUMyQixZQUFZLENBQUMsS0FBSzVDLFFBQVEsSUFBSTtZQUN0QyxJQUFJLENBQUM0QyxZQUFZLENBQUMsS0FBSyxNQUFNbkMsUUFBUSxDQUFDO1FBQ3hDO1FBRUEsSUFBSSxDQUFDLElBQUksQ0FBQ21DLFlBQVksQ0FBQyxLQUFLNUMsUUFBUSxJQUFJO1lBQ3RDLElBQUksQ0FBQzRDLFlBQVksQ0FBQyxLQUFLLE1BQU1uQyxRQUFRLENBQUM7UUFDeEM7UUFFQSxJQUFJLEVBQ0ZuRyxLQUFLLEVBQ0xDLE1BQU0sRUFDUCxHQUFHb0gsT0FBT0QsUUFBUTtRQUVuQixJQUFJLENBQUMsSUFBSSxDQUFDZ0wsUUFBUSxDQUFDLFNBQVMxTSxRQUFRLElBQUk7WUFDdEMsSUFBSSxDQUFDME0sUUFBUSxDQUFDLFNBQVMsTUFBTWpNLFFBQVEsQ0FBQztRQUN4QztRQUVBLElBQUksQ0FBQyxJQUFJLENBQUNpTSxRQUFRLENBQUMsVUFBVTFNLFFBQVEsSUFBSTtZQUN2QyxJQUFJLENBQUMwTSxRQUFRLENBQUMsVUFBVSxNQUFNak0sUUFBUSxDQUFDO1FBQ3pDO1FBRUEsSUFBSSxDQUFDLElBQUksQ0FBQ2lNLFFBQVEsQ0FBQyxTQUFTMU0sUUFBUSxJQUFJO1lBQ3RDLElBQUksQ0FBQzBNLFFBQVEsQ0FBQyxTQUFTLE1BQU1qTSxRQUFRLENBQUM7UUFDeEM7UUFFQSxJQUFJMmtCLFdBQVcsSUFBSSxDQUFDeGlCLFlBQVksQ0FBQztRQUNqQyxJQUFJeWlCLFdBQVcsSUFBSSxDQUFDemlCLFlBQVksQ0FBQztRQUNqQyxJQUFJMGlCLGNBQWMsSUFBSSxDQUFDMWlCLFlBQVksQ0FBQztRQUNwQyxJQUFJcUssVUFBVXFZLFlBQVl0bEIsUUFBUSxLQUFLakUsVUFBVXVwQixZQUFZeGxCLFNBQVMsTUFBTTtRQUM1RSxJQUFJNkosT0FBTyxDQUFDLElBQUksQ0FBQ29iLElBQUksSUFBSSxJQUFJLENBQUNyWSxRQUFRLENBQUMsWUFBWWhNLFFBQVEsQ0FBQyxjQUFjO1FBQzFFLElBQUk2SSxPQUFPO1FBQ1gsSUFBSUMsT0FBTztRQUNYLElBQUlJLFFBQVE7UUFDWixJQUFJQyxRQUFRO1FBRVosSUFBSW9ELFNBQVM7WUFDWDFELE9BQU8wRCxPQUFPLENBQUMsRUFBRTtZQUNqQnpELE9BQU95RCxPQUFPLENBQUMsRUFBRTtRQUNuQjtRQUVBLElBQUksQ0FBQyxJQUFJLENBQUM4WCxJQUFJLEVBQUU7WUFDZHpxQixRQUFRLElBQUksQ0FBQ29TLFFBQVEsQ0FBQyxTQUFTckwsU0FBUyxDQUFDO1lBQ3pDOUcsU0FBUyxJQUFJLENBQUNtUyxRQUFRLENBQUMsVUFBVXJMLFNBQVMsQ0FBQztZQUUzQyxJQUFJLElBQUksQ0FBQytGLElBQUksS0FBSyxVQUFVO2dCQUMxQndDLFFBQVFMO2dCQUNSTSxRQUFRTDtnQkFDUkQsT0FBTztnQkFDUEMsT0FBTztZQUNUO1FBQ0Y7UUFFQTdILE9BQU9ELFFBQVEsQ0FBQytCLFVBQVUsQ0FBQ25KLE9BQU9DLFNBQVMseUVBQXlFO1FBQ3BILDhFQUE4RTtRQUU5RSxJQUFJLElBQUksQ0FBQ1csSUFBSSxDQUFDLDhCQUE4QjtZQUN4QyxFQUFDLElBQUksQ0FBQ2lMLE1BQU0sSUFBSSxDQUFDLENBQUM2ZSx3QkFBd0IsSUFBSSxDQUFDOXBCLElBQUksQ0FBQzBuQixVQUFVLE1BQU0sUUFBUW9DLDBCQUEwQixLQUFLLElBQUksS0FBSyxJQUFJQSxzQkFBc0IxUyxRQUFRLE1BQU0sZUFBYyxLQUFNLElBQUksQ0FBQzVGLFFBQVEsQ0FBQyxhQUFhLE9BQU8sTUFBTTFNLFFBQVEsTUFBTSxDQUFDLElBQUksQ0FBQzBNLFFBQVEsQ0FBQyxvQkFBb0IsT0FBTyxNQUFNMU0sUUFBUSxJQUFJO1lBQ3BTLElBQUksQ0FBQzBNLFFBQVEsQ0FBQyxvQkFBb0IsTUFBTSxNQUFNak0sUUFBUSxDQUFDO1FBQ3pEO1FBRUEsS0FBSyxDQUFDaVQsV0FBV2xSO1FBQ2pCQSxJQUFJb0ksU0FBUyxDQUFDLElBQUksQ0FBQ2hJLFlBQVksQ0FBQyxLQUFLdkIsU0FBUyxDQUFDLE1BQU0sSUFBSSxDQUFDdUIsWUFBWSxDQUFDLEtBQUt2QixTQUFTLENBQUM7UUFFdEYsSUFBSTRMLFNBQVM7WUFDWDNTLFFBQVEyUyxPQUFPLENBQUMsRUFBRTtZQUNsQjFTLFNBQVMwUyxPQUFPLENBQUMsRUFBRTtRQUNyQjtRQUVBek4sVUFBUzJKLFVBQVUsQ0FBQztZQUNsQjNHO1lBQ0E0RyxhQUFhLElBQUksQ0FBQ3hHLFlBQVksQ0FBQyx1QkFBdUI5QyxTQUFTO1lBQy9EeEYsT0FBT3FILE9BQU9ELFFBQVEsQ0FBQ3BILEtBQUs7WUFDNUIrTyxjQUFjL087WUFDZEMsUUFBUW9ILE9BQU9ELFFBQVEsQ0FBQ25ILE1BQU07WUFDOUIrTyxlQUFlL087WUFDZmdQO1lBQ0FDO1lBQ0FDLE1BQU0yYixTQUFTMWtCLFFBQVE7WUFDdkJnSixNQUFNMmIsU0FBUzNrQixRQUFRO1lBQ3ZCaUo7WUFDQUM7WUFDQUM7UUFDRjtRQUVBLElBQUlvRCxTQUFTO1lBQ1h0TCxPQUFPRCxRQUFRLENBQUNpQyxhQUFhO1lBQzdCaEMsT0FBT0QsUUFBUSxDQUFDK0IsVUFBVSxDQUFDbkosT0FBT0M7UUFDcEM7SUFDRjtJQUVBcVosYUFBYXBSLEdBQUcsRUFBRTtRQUNoQixLQUFLLENBQUNvUixhQUFhcFI7UUFDbkIsSUFBSSxDQUFDaEQsUUFBUSxDQUFDbUMsTUFBTSxDQUFDRCxRQUFRLENBQUNpQyxhQUFhO0lBQzdDO0lBQ0E7Ozs7O0dBS0MsR0FHRDRoQixPQUFPanJCLEtBQUssRUFBRTtRQUNaLElBQUlDLFNBQVNULFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHUTtRQUNqRixJQUFJa3JCLHNCQUFzQjFyQixVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRztRQUM5RixJQUFJMnJCLFlBQVksSUFBSSxDQUFDN2lCLFlBQVksQ0FBQyxTQUFTO1FBQzNDLElBQUk4aUIsYUFBYSxJQUFJLENBQUM5aUIsWUFBWSxDQUFDLFVBQVU7UUFDN0MsSUFBSTBpQixjQUFjLElBQUksQ0FBQzFpQixZQUFZLENBQUM7UUFDcEMsSUFBSStpQixZQUFZLElBQUksQ0FBQy9pQixZQUFZLENBQUM7UUFDbEMsSUFBSWdqQixjQUFjSCxVQUFVN2tCLFNBQVMsQ0FBQztRQUN0QyxJQUFJaWxCLGVBQWVILFdBQVc5a0IsU0FBUyxDQUFDO1FBRXhDLElBQUk0a0IscUJBQXFCO1lBQ3ZCLElBQUksT0FBT0Esd0JBQXdCLFVBQVU7Z0JBQzNDLElBQUksQ0FBQzVpQixZQUFZLENBQUMsdUJBQXVCLE1BQU1uQyxRQUFRLENBQUMra0I7WUFDMUQsT0FBTztnQkFDTCxJQUFJTSwwQkFBMEIsSUFBSSxDQUFDbGpCLFlBQVksQ0FBQztnQkFFaEQsSUFBSWtqQix3QkFBd0I5bEIsUUFBUSxJQUFJO29CQUN0QzhsQix3QkFBd0JybEIsUUFBUSxDQUFDcWxCLHdCQUF3QmhtQixTQUFTLEdBQUdsRSxPQUFPLENBQUMsb0JBQW9CO2dCQUNuRztZQUNGO1FBQ0Y7UUFFQTZwQixVQUFVaGxCLFFBQVEsQ0FBQ25HO1FBQ25Cb3JCLFdBQVdqbEIsUUFBUSxDQUFDbEc7UUFFcEIsSUFBSSxDQUFDK3FCLFlBQVl0bEIsUUFBUSxJQUFJO1lBQzNCc2xCLFlBQVk3a0IsUUFBUSxDQUFDLE9BQU9tTSxNQUFNLENBQUNnWixlQUFldHJCLE9BQU8sS0FBS3NTLE1BQU0sQ0FBQ2laLGdCQUFnQnRyQjtRQUN2RjtRQUVBLElBQUlvckIsVUFBVTNsQixRQUFRLElBQUk7WUFDeEIsSUFBSXlNLGFBQWEsSUFBSSxDQUFDQyxRQUFRLENBQUM7WUFDL0IsSUFBSUMsY0FBYyxJQUFJLENBQUNELFFBQVEsQ0FBQztZQUVoQyxJQUFJRCxXQUFXek0sUUFBUSxJQUFJO2dCQUN6QnlNLFdBQVdoTSxRQUFRLENBQUMsR0FBR21NLE1BQU0sQ0FBQ3RTLE9BQU87WUFDdkM7WUFFQSxJQUFJcVMsWUFBWTNNLFFBQVEsSUFBSTtnQkFDMUIyTSxZQUFZbE0sUUFBUSxDQUFDLEdBQUdtTSxNQUFNLENBQUNyUyxRQUFRO1lBQ3pDO1FBQ0Y7SUFDRjtBQUVGO0FBRUEsTUFBTXdyQixvQkFBb0I5STtJQUN4QjFkLGFBQWM7UUFDWixLQUFLLElBQUl6RjtRQUNULElBQUksQ0FBQ3NOLElBQUksR0FBRztJQUNkO0lBRUE1QyxLQUFLaEMsR0FBRyxFQUFFO1FBQ1IsSUFBSXdCLElBQUksSUFBSSxDQUFDcEIsWUFBWSxDQUFDLEtBQUt2QixTQUFTLENBQUM7UUFDekMsSUFBSTRDLElBQUksSUFBSSxDQUFDckIsWUFBWSxDQUFDLEtBQUt2QixTQUFTLENBQUM7UUFDekMsSUFBSS9HLFFBQVEsSUFBSSxDQUFDb1MsUUFBUSxDQUFDLFNBQVMsT0FBTyxNQUFNckwsU0FBUyxDQUFDO1FBQzFELElBQUk5RyxTQUFTLElBQUksQ0FBQ21TLFFBQVEsQ0FBQyxVQUFVLE9BQU8sTUFBTXJMLFNBQVMsQ0FBQztRQUM1RCxJQUFJMmtCLFNBQVMsSUFBSSxDQUFDcGpCLFlBQVksQ0FBQztRQUMvQixJQUFJcWpCLFNBQVMsSUFBSSxDQUFDcmpCLFlBQVksQ0FBQztRQUMvQixJQUFJc2pCLEtBQUtGLE9BQU8za0IsU0FBUyxDQUFDO1FBQzFCLElBQUk4a0IsS0FBS0YsT0FBTzVrQixTQUFTLENBQUM7UUFFMUIsSUFBSTJrQixPQUFPaG1CLFFBQVEsTUFBTSxDQUFDaW1CLE9BQU9qbUIsUUFBUSxJQUFJO1lBQzNDbW1CLEtBQUtEO1FBQ1A7UUFFQSxJQUFJRCxPQUFPam1CLFFBQVEsTUFBTSxDQUFDZ21CLE9BQU9obUIsUUFBUSxJQUFJO1lBQzNDa21CLEtBQUtDO1FBQ1A7UUFFQUQsS0FBSzlvQixLQUFLd0UsR0FBRyxDQUFDc2tCLElBQUk1ckIsUUFBUTtRQUMxQjZyQixLQUFLL29CLEtBQUt3RSxHQUFHLENBQUN1a0IsSUFBSTVyQixTQUFTO1FBRTNCLElBQUlpSSxLQUFLO1lBQ1AsSUFBSTRqQixRQUFRLElBQUssRUFBQ2hwQixLQUFLb0IsSUFBSSxDQUFDLEtBQUssS0FBSztZQUN0Q2dFLElBQUl1SSxTQUFTLElBQUkscURBQXFEO1lBRXRFLElBQUl4USxTQUFTLEtBQUtELFFBQVEsR0FBRztnQkFDM0JrSSxJQUFJd0ksTUFBTSxDQUFDaEgsSUFBSWtpQixJQUFJamlCO2dCQUNuQnpCLElBQUl5SSxNQUFNLENBQUNqSCxJQUFJMUosUUFBUTRyQixJQUFJamlCO2dCQUMzQnpCLElBQUkrYyxhQUFhLENBQUN2YixJQUFJMUosUUFBUTRyQixLQUFLRSxRQUFRRixJQUFJamlCLEdBQUdELElBQUkxSixPQUFPMkosSUFBSWtpQixLQUFLQyxRQUFRRCxJQUFJbmlCLElBQUkxSixPQUFPMkosSUFBSWtpQjtnQkFDakczakIsSUFBSXlJLE1BQU0sQ0FBQ2pILElBQUkxSixPQUFPMkosSUFBSTFKLFNBQVM0ckI7Z0JBQ25DM2pCLElBQUkrYyxhQUFhLENBQUN2YixJQUFJMUosT0FBTzJKLElBQUkxSixTQUFTNHJCLEtBQUtDLFFBQVFELElBQUluaUIsSUFBSTFKLFFBQVE0ckIsS0FBS0UsUUFBUUYsSUFBSWppQixJQUFJMUosUUFBUXlKLElBQUkxSixRQUFRNHJCLElBQUlqaUIsSUFBSTFKO2dCQUN4SGlJLElBQUl5SSxNQUFNLENBQUNqSCxJQUFJa2lCLElBQUlqaUIsSUFBSTFKO2dCQUN2QmlJLElBQUkrYyxhQUFhLENBQUN2YixJQUFJa2lCLEtBQUtFLFFBQVFGLElBQUlqaUIsSUFBSTFKLFFBQVF5SixHQUFHQyxJQUFJMUosU0FBUzRyQixLQUFLQyxRQUFRRCxJQUFJbmlCLEdBQUdDLElBQUkxSixTQUFTNHJCO2dCQUNwRzNqQixJQUFJeUksTUFBTSxDQUFDakgsR0FBR0MsSUFBSWtpQjtnQkFDbEIzakIsSUFBSStjLGFBQWEsQ0FBQ3ZiLEdBQUdDLElBQUlraUIsS0FBS0MsUUFBUUQsSUFBSW5pQixJQUFJa2lCLEtBQUtFLFFBQVFGLElBQUlqaUIsR0FBR0QsSUFBSWtpQixJQUFJamlCO2dCQUMxRXpCLElBQUkwSSxTQUFTO1lBQ2Y7UUFDRjtRQUVBLE9BQU8sSUFBSXdMLFlBQVkxUyxHQUFHQyxHQUFHRCxJQUFJMUosT0FBTzJKLElBQUkxSjtJQUM5QztJQUVBNmpCLGFBQWE7UUFDWCxPQUFPO0lBQ1Q7QUFFRjtBQUVBLE1BQU1pSSxzQkFBc0JwSjtJQUMxQjFkLGFBQWM7UUFDWixLQUFLLElBQUl6RjtRQUNULElBQUksQ0FBQ3NOLElBQUksR0FBRztJQUNkO0lBRUE1QyxLQUFLaEMsR0FBRyxFQUFFO1FBQ1IsSUFBSTRNLEtBQUssSUFBSSxDQUFDeE0sWUFBWSxDQUFDLE1BQU12QixTQUFTLENBQUM7UUFDM0MsSUFBSWdPLEtBQUssSUFBSSxDQUFDek0sWUFBWSxDQUFDLE1BQU12QixTQUFTLENBQUM7UUFDM0MsSUFBSW9mLElBQUksSUFBSSxDQUFDN2QsWUFBWSxDQUFDLEtBQUt2QixTQUFTO1FBRXhDLElBQUltQixPQUFPaWUsSUFBSSxHQUFHO1lBQ2hCamUsSUFBSXVJLFNBQVM7WUFDYnZJLElBQUlvZSxHQUFHLENBQUN4UixJQUFJQyxJQUFJb1IsR0FBRyxHQUFHcmpCLEtBQUs2RSxFQUFFLEdBQUcsR0FBRztZQUNuQ08sSUFBSTBJLFNBQVM7UUFDZjtRQUVBLE9BQU8sSUFBSXdMLFlBQVl0SCxLQUFLcVIsR0FBR3BSLEtBQUtvUixHQUFHclIsS0FBS3FSLEdBQUdwUixLQUFLb1I7SUFDdEQ7SUFFQXJDLGFBQWE7UUFDWCxPQUFPO0lBQ1Q7QUFFRjtBQUVBLE1BQU1rSSx1QkFBdUJySjtJQUMzQjFkLGFBQWM7UUFDWixLQUFLLElBQUl6RjtRQUNULElBQUksQ0FBQ3NOLElBQUksR0FBRztJQUNkO0lBRUE1QyxLQUFLaEMsR0FBRyxFQUFFO1FBQ1IsSUFBSTRqQixRQUFRLElBQUssRUFBQ2hwQixLQUFLb0IsSUFBSSxDQUFDLEtBQUssS0FBSztRQUN0QyxJQUFJMG5CLEtBQUssSUFBSSxDQUFDdGpCLFlBQVksQ0FBQyxNQUFNdkIsU0FBUyxDQUFDO1FBQzNDLElBQUk4a0IsS0FBSyxJQUFJLENBQUN2akIsWUFBWSxDQUFDLE1BQU12QixTQUFTLENBQUM7UUFDM0MsSUFBSStOLEtBQUssSUFBSSxDQUFDeE0sWUFBWSxDQUFDLE1BQU12QixTQUFTLENBQUM7UUFDM0MsSUFBSWdPLEtBQUssSUFBSSxDQUFDek0sWUFBWSxDQUFDLE1BQU12QixTQUFTLENBQUM7UUFFM0MsSUFBSW1CLE9BQU8wakIsS0FBSyxLQUFLQyxLQUFLLEdBQUc7WUFDM0IzakIsSUFBSXVJLFNBQVM7WUFDYnZJLElBQUl3SSxNQUFNLENBQUNvRSxLQUFLOFcsSUFBSTdXO1lBQ3BCN00sSUFBSStjLGFBQWEsQ0FBQ25RLEtBQUs4VyxJQUFJN1csS0FBSytXLFFBQVFELElBQUkvVyxLQUFLZ1gsUUFBUUYsSUFBSTdXLEtBQUs4VyxJQUFJL1csSUFBSUMsS0FBSzhXO1lBQy9FM2pCLElBQUkrYyxhQUFhLENBQUNuUSxLQUFLZ1gsUUFBUUYsSUFBSTdXLEtBQUs4VyxJQUFJL1csS0FBSzhXLElBQUk3VyxLQUFLK1csUUFBUUQsSUFBSS9XLEtBQUs4VyxJQUFJN1c7WUFDL0U3TSxJQUFJK2MsYUFBYSxDQUFDblEsS0FBSzhXLElBQUk3VyxLQUFLK1csUUFBUUQsSUFBSS9XLEtBQUtnWCxRQUFRRixJQUFJN1csS0FBSzhXLElBQUkvVyxJQUFJQyxLQUFLOFc7WUFDL0UzakIsSUFBSStjLGFBQWEsQ0FBQ25RLEtBQUtnWCxRQUFRRixJQUFJN1csS0FBSzhXLElBQUkvVyxLQUFLOFcsSUFBSTdXLEtBQUsrVyxRQUFRRCxJQUFJL1csS0FBSzhXLElBQUk3VztZQUMvRTdNLElBQUkwSSxTQUFTO1FBQ2Y7UUFFQSxPQUFPLElBQUl3TCxZQUFZdEgsS0FBSzhXLElBQUk3VyxLQUFLOFcsSUFBSS9XLEtBQUs4VyxJQUFJN1csS0FBSzhXO0lBQ3pEO0lBRUEvSCxhQUFhO1FBQ1gsT0FBTztJQUNUO0FBRUY7QUFFQSxNQUFNbUksb0JBQW9CdEo7SUFDeEIxZCxhQUFjO1FBQ1osS0FBSyxJQUFJekY7UUFDVCxJQUFJLENBQUNzTixJQUFJLEdBQUc7SUFDZDtJQUVBb2YsWUFBWTtRQUNWLE9BQU87WUFBQyxJQUFJemlCLE1BQU0sSUFBSSxDQUFDbkIsWUFBWSxDQUFDLE1BQU12QixTQUFTLENBQUMsTUFBTSxJQUFJLENBQUN1QixZQUFZLENBQUMsTUFBTXZCLFNBQVMsQ0FBQztZQUFPLElBQUkwQyxNQUFNLElBQUksQ0FBQ25CLFlBQVksQ0FBQyxNQUFNdkIsU0FBUyxDQUFDLE1BQU0sSUFBSSxDQUFDdUIsWUFBWSxDQUFDLE1BQU12QixTQUFTLENBQUM7U0FBTTtJQUMvTDtJQUVBbUQsS0FBS2hDLEdBQUcsRUFBRTtRQUNSLElBQUksQ0FBQyxFQUNId0IsR0FBR3lpQixFQUFFLEVBQ0x4aUIsR0FBR3lpQixFQUFFLEVBQ04sRUFBRSxFQUNEMWlCLEdBQUcyUyxFQUFFLEVBQ0wxUyxHQUFHNlMsRUFBRSxFQUNOLENBQUMsR0FBRyxJQUFJLENBQUMwUCxTQUFTO1FBRW5CLElBQUloa0IsS0FBSztZQUNQQSxJQUFJdUksU0FBUztZQUNidkksSUFBSXdJLE1BQU0sQ0FBQ3liLElBQUlDO1lBQ2Zsa0IsSUFBSXlJLE1BQU0sQ0FBQzBMLElBQUlHO1FBQ2pCO1FBRUEsT0FBTyxJQUFJSixZQUFZK1AsSUFBSUMsSUFBSS9QLElBQUlHO0lBQ3JDO0lBRUFzSCxhQUFhO1FBQ1gsSUFBSSxDQUFDOUcsSUFBSUMsR0FBRyxHQUFHLElBQUksQ0FBQ2lQLFNBQVM7UUFDN0IsSUFBSXhXLElBQUlzSCxHQUFHM1MsT0FBTyxDQUFDNFM7UUFDbkIsT0FBTztZQUFDO2dCQUFDRDtnQkFBSXRIO2FBQUU7WUFBRTtnQkFBQ3VIO2dCQUFJdkg7YUFBRTtTQUFDO0lBQzNCO0FBRUY7QUFFQSxNQUFNMlcsd0JBQXdCMUo7SUFDNUIxZCxZQUFZQyxTQUFRLEVBQUV0RSxJQUFJLEVBQUV3VyxnQkFBZ0IsQ0FBRTtRQUM1QyxLQUFLLENBQUNsUyxXQUFVdEUsTUFBTXdXO1FBQ3RCLElBQUksQ0FBQ3RLLElBQUksR0FBRztRQUNaLElBQUksQ0FBQzNDLE1BQU0sR0FBRyxFQUFFO1FBQ2hCLElBQUksQ0FBQ0EsTUFBTSxHQUFHVixNQUFNUSxTQUFTLENBQUMsSUFBSSxDQUFDM0IsWUFBWSxDQUFDLFVBQVU5QyxTQUFTO0lBQ3JFO0lBRUEwRSxLQUFLaEMsR0FBRyxFQUFFO1FBQ1IsSUFBSSxFQUNGaUMsTUFBTSxFQUNQLEdBQUcsSUFBSTtRQUNSLElBQUksQ0FBQyxFQUNIVCxHQUFHeWlCLEVBQUUsRUFDTHhpQixHQUFHeWlCLEVBQUUsRUFDTixDQUFDLEdBQUdqaUI7UUFDTCxJQUFJK0IsY0FBYyxJQUFJa1EsWUFBWStQLElBQUlDO1FBRXRDLElBQUlsa0IsS0FBSztZQUNQQSxJQUFJdUksU0FBUztZQUNidkksSUFBSXdJLE1BQU0sQ0FBQ3liLElBQUlDO1FBQ2pCO1FBRUFqaUIsT0FBT3dCLE9BQU8sQ0FBQzlLLENBQUFBO1lBQ2IsSUFBSSxFQUNGNkksQ0FBQyxFQUNEQyxDQUFDLEVBQ0YsR0FBRzlJO1lBQ0pxTCxZQUFZeVEsUUFBUSxDQUFDalQsR0FBR0M7WUFFeEIsSUFBSXpCLEtBQUs7Z0JBQ1BBLElBQUl5SSxNQUFNLENBQUNqSCxHQUFHQztZQUNoQjtRQUNGO1FBQ0EsT0FBT3VDO0lBQ1Q7SUFFQTRYLGFBQWE7UUFDWCxJQUFJLEVBQ0YzWixNQUFNLEVBQ1AsR0FBRyxJQUFJO1FBQ1IsSUFBSW9lLFlBQVlwZSxPQUFPMUssTUFBTSxHQUFHO1FBQ2hDLElBQUlza0IsVUFBVSxFQUFFO1FBQ2hCNVosT0FBT3dCLE9BQU8sQ0FBQyxDQUFDOUIsT0FBT2pCO1lBQ3JCLElBQUlBLE1BQU0yZixXQUFXO2dCQUNuQjtZQUNGO1lBRUF4RSxRQUFRM2EsSUFBSSxDQUFDO2dCQUFDUztnQkFBT0EsTUFBTVEsT0FBTyxDQUFDRixNQUFNLENBQUN2QixJQUFJLEVBQUU7YUFBRTtRQUNwRDtRQUVBLElBQUltYixRQUFRdGtCLE1BQU0sR0FBRyxHQUFHO1lBQ3RCc2tCLFFBQVEzYSxJQUFJLENBQUM7Z0JBQUNlLE1BQU0sQ0FBQ0EsT0FBTzFLLE1BQU0sR0FBRyxFQUFFO2dCQUFFc2tCLE9BQU8sQ0FBQ0EsUUFBUXRrQixNQUFNLEdBQUcsRUFBRSxDQUFDLEVBQUU7YUFBQztRQUMxRTtRQUVBLE9BQU9za0I7SUFDVDtBQUVGO0FBRUEsTUFBTXVJLHVCQUF1QkQ7SUFDM0JwbkIsYUFBYztRQUNaLEtBQUssSUFBSXpGO1FBQ1QsSUFBSSxDQUFDc04sSUFBSSxHQUFHO0lBQ2Q7SUFFQTVDLEtBQUtoQyxHQUFHLEVBQUU7UUFDUixJQUFJZ0UsY0FBYyxLQUFLLENBQUNoQyxLQUFLaEM7UUFDN0IsSUFBSSxDQUFDLEVBQ0h3QixDQUFDLEVBQ0RDLENBQUMsRUFDRixDQUFDLEdBQUcsSUFBSSxDQUFDUSxNQUFNO1FBRWhCLElBQUlqQyxLQUFLO1lBQ1BBLElBQUl5SSxNQUFNLENBQUNqSCxHQUFHQztZQUNkekIsSUFBSTBJLFNBQVM7UUFDZjtRQUVBLE9BQU8xRTtJQUNUO0FBRUY7QUFFQSxNQUFNcWdCLHVCQUF1QnBWO0lBQzNCbFMsYUFBYztRQUNaLEtBQUssSUFBSXpGO1FBQ1QsSUFBSSxDQUFDc04sSUFBSSxHQUFHO0lBQ2Q7SUFFQTNFLGNBQWNELEdBQUcsRUFBRW9HLENBQUMsRUFBRWtlLGlCQUFpQixFQUFFO1FBQ3ZDLElBQUl4c0IsUUFBUSxJQUFJLENBQUNvUyxRQUFRLENBQUMsU0FBU3JMLFNBQVMsQ0FBQyxLQUFLO1FBQ2xELElBQUk5RyxTQUFTLElBQUksQ0FBQ21TLFFBQVEsQ0FBQyxVQUFVckwsU0FBUyxDQUFDLEtBQUssT0FBTywwQ0FBMEM7UUFFckcsSUFBSTBsQixhQUFhLElBQUlqQyxXQUFXLElBQUksQ0FBQ3RsQixRQUFRLEVBQUU7UUFDL0N1bkIsV0FBV3BWLFVBQVUsQ0FBQzFFLE9BQU8sR0FBRyxJQUFJM04sU0FBUyxJQUFJLENBQUNFLFFBQVEsRUFBRSxXQUFXLElBQUksQ0FBQ29ELFlBQVksQ0FBQyxXQUFXbEMsUUFBUTtRQUM1R3FtQixXQUFXcFYsVUFBVSxDQUFDclgsS0FBSyxHQUFHLElBQUlnRixTQUFTLElBQUksQ0FBQ0UsUUFBUSxFQUFFLFNBQVMsR0FBR29OLE1BQU0sQ0FBQ3RTLE9BQU87UUFDcEZ5c0IsV0FBV3BWLFVBQVUsQ0FBQ3BYLE1BQU0sR0FBRyxJQUFJK0UsU0FBUyxJQUFJLENBQUNFLFFBQVEsRUFBRSxVQUFVLEdBQUdvTixNQUFNLENBQUNyUyxRQUFRO1FBQ3ZGd3NCLFdBQVdwVixVQUFVLENBQUM3TSxTQUFTLEdBQUcsSUFBSXhGLFNBQVMsSUFBSSxDQUFDRSxRQUFRLEVBQUUsYUFBYSxJQUFJLENBQUNvRCxZQUFZLENBQUMsb0JBQW9CbEMsUUFBUTtRQUN6SHFtQixXQUFXOVUsUUFBUSxHQUFHLElBQUksQ0FBQ0EsUUFBUTtRQUNuQyxJQUFJK1UsZ0JBQWdCLElBQUksQ0FBQ3huQixRQUFRLENBQUNuRixZQUFZLENBQUNDLE9BQU9DO1FBQ3RELElBQUkwc0IsYUFBYUQsY0FBY0UsVUFBVSxDQUFDO1FBQzFDLElBQUloRCxRQUFRLElBQUksQ0FBQ3RoQixZQUFZLENBQUM7UUFDOUIsSUFBSXVoQixRQUFRLElBQUksQ0FBQ3ZoQixZQUFZLENBQUM7UUFFOUIsSUFBSXNoQixNQUFNbGtCLFFBQVEsTUFBTW1rQixNQUFNbmtCLFFBQVEsSUFBSTtZQUN4Q2luQixXQUFXcmMsU0FBUyxDQUFDc1osTUFBTTdpQixTQUFTLENBQUMsS0FBSyxPQUFPOGlCLE1BQU05aUIsU0FBUyxDQUFDLEtBQUs7UUFDeEU7UUFFQSxJQUFJeWxCLGtCQUFrQjltQixRQUFRLElBQUk7WUFDaEMsSUFBSSxDQUFDNlIsTUFBTSxDQUFDLGVBQWUsR0FBR2lWO1FBQ2hDLE9BQU87WUFDTDlyQixRQUFRQyxjQUFjLENBQUMsSUFBSSxDQUFDNFcsTUFBTSxFQUFFO1FBQ3RDLEVBQUUsdUVBQXVFO1FBR3pFLElBQUssSUFBSTdOLElBQUksQ0FBQyxHQUFHQSxLQUFLLEdBQUdBLElBQUs7WUFDNUIsSUFBSyxJQUFJQyxJQUFJLENBQUMsR0FBR0EsS0FBSyxHQUFHQSxJQUFLO2dCQUM1QmdqQixXQUFXM1QsSUFBSTtnQkFDZnlULFdBQVdwVixVQUFVLENBQUMzTixDQUFDLEdBQUcsSUFBSTFFLFNBQVMsSUFBSSxDQUFDRSxRQUFRLEVBQUUsS0FBS3dFLElBQUlnakIsY0FBYzFzQixLQUFLO2dCQUNsRnlzQixXQUFXcFYsVUFBVSxDQUFDMU4sQ0FBQyxHQUFHLElBQUkzRSxTQUFTLElBQUksQ0FBQ0UsUUFBUSxFQUFFLEtBQUt5RSxJQUFJK2lCLGNBQWN6c0IsTUFBTTtnQkFDbkZ3c0IsV0FBV2hiLE1BQU0sQ0FBQ2tiO2dCQUNsQkEsV0FBV3BULE9BQU87WUFDcEI7UUFDRjtRQUVBLElBQUlzVCxVQUFVM2tCLElBQUlDLGFBQWEsQ0FBQ3VrQixlQUFlO1FBQy9DLE9BQU9HO0lBQ1Q7QUFFRjtBQUVBLE1BQU1DLHNCQUFzQjNWO0lBQzFCbFMsYUFBYztRQUNaLEtBQUssSUFBSXpGO1FBQ1QsSUFBSSxDQUFDc04sSUFBSSxHQUFHO0lBQ2Q7SUFFQTJFLE9BQU92SixHQUFHLEVBQUUyQixLQUFLLEVBQUU4SyxLQUFLLEVBQUU7UUFDeEIsSUFBSSxDQUFDOUssT0FBTztZQUNWO1FBQ0Y7UUFFQSxJQUFJLEVBQ0ZILENBQUMsRUFDREMsQ0FBQyxFQUNGLEdBQUdFO1FBQ0osSUFBSWtqQixTQUFTLElBQUksQ0FBQ3prQixZQUFZLENBQUMsVUFBVTlDLFNBQVMsQ0FBQztRQUNuRCxJQUFJd25CLGNBQWMsSUFBSSxDQUFDMWtCLFlBQVksQ0FBQyxlQUFlOUMsU0FBUyxDQUFDO1FBQzdEMEMsSUFBSW9JLFNBQVMsQ0FBQzVHLEdBQUdDO1FBRWpCLElBQUlvakIsV0FBVyxRQUFRO1lBQ3JCN2tCLElBQUl1TSxNQUFNLENBQUNFO1FBQ2I7UUFFQSxJQUFJcVksZ0JBQWdCLGVBQWU7WUFDakM5a0IsSUFBSThCLEtBQUssQ0FBQzlCLElBQUltWixTQUFTLEVBQUVuWixJQUFJbVosU0FBUztRQUN4QztRQUVBblosSUFBSThRLElBQUksSUFBSSwwQ0FBMEM7UUFFdEQsSUFBSWlVLFlBQVksSUFBSXpDLFdBQVcsSUFBSSxDQUFDdGxCLFFBQVEsRUFBRTtRQUM5QytuQixVQUFVbmdCLElBQUksR0FBRyxJQUFJLENBQUNBLElBQUk7UUFDMUJtZ0IsVUFBVTVWLFVBQVUsQ0FBQzFFLE9BQU8sR0FBRyxJQUFJM04sU0FBUyxJQUFJLENBQUNFLFFBQVEsRUFBRSxXQUFXLElBQUksQ0FBQ29ELFlBQVksQ0FBQyxXQUFXbEMsUUFBUTtRQUMzRzZtQixVQUFVNVYsVUFBVSxDQUFDbEksSUFBSSxHQUFHLElBQUluSyxTQUFTLElBQUksQ0FBQ0UsUUFBUSxFQUFFLFFBQVEsSUFBSSxDQUFDb0QsWUFBWSxDQUFDLFFBQVFsQyxRQUFRO1FBQ2xHNm1CLFVBQVU1VixVQUFVLENBQUNqSSxJQUFJLEdBQUcsSUFBSXBLLFNBQVMsSUFBSSxDQUFDRSxRQUFRLEVBQUUsUUFBUSxJQUFJLENBQUNvRCxZQUFZLENBQUMsUUFBUWxDLFFBQVE7UUFDbEc2bUIsVUFBVTVWLFVBQVUsQ0FBQ3JYLEtBQUssR0FBRyxJQUFJZ0YsU0FBUyxJQUFJLENBQUNFLFFBQVEsRUFBRSxTQUFTLElBQUksQ0FBQ29ELFlBQVksQ0FBQyxlQUFlbEMsUUFBUTtRQUMzRzZtQixVQUFVNVYsVUFBVSxDQUFDcFgsTUFBTSxHQUFHLElBQUkrRSxTQUFTLElBQUksQ0FBQ0UsUUFBUSxFQUFFLFVBQVUsSUFBSSxDQUFDb0QsWUFBWSxDQUFDLGdCQUFnQmxDLFFBQVE7UUFDOUc2bUIsVUFBVTVWLFVBQVUsQ0FBQzZWLFFBQVEsR0FBRyxJQUFJbG9CLFNBQVMsSUFBSSxDQUFDRSxRQUFRLEVBQUUsWUFBWSxJQUFJLENBQUNvRCxZQUFZLENBQUMsWUFBWWxDLFFBQVE7UUFDOUc2bUIsVUFBVTVWLFVBQVUsQ0FBQzRNLElBQUksR0FBRyxJQUFJamYsU0FBUyxJQUFJLENBQUNFLFFBQVEsRUFBRSxRQUFRLElBQUksQ0FBQ29ELFlBQVksQ0FBQyxRQUFROUIsUUFBUSxDQUFDO1FBQ25HeW1CLFVBQVU1VixVQUFVLENBQUM4TSxNQUFNLEdBQUcsSUFBSW5mLFNBQVMsSUFBSSxDQUFDRSxRQUFRLEVBQUUsVUFBVSxJQUFJLENBQUNvRCxZQUFZLENBQUMsVUFBVWxDLFFBQVEsQ0FBQztRQUN6RzZtQixVQUFVdFYsUUFBUSxHQUFHLElBQUksQ0FBQ0EsUUFBUTtRQUNsQ3NWLFVBQVV4YixNQUFNLENBQUN2SjtRQUNqQkEsSUFBSXFSLE9BQU87UUFFWCxJQUFJeVQsZ0JBQWdCLGVBQWU7WUFDakM5a0IsSUFBSThCLEtBQUssQ0FBQyxJQUFJOUIsSUFBSW1aLFNBQVMsRUFBRSxJQUFJblosSUFBSW1aLFNBQVM7UUFDaEQ7UUFFQSxJQUFJMEwsV0FBVyxRQUFRO1lBQ3JCN2tCLElBQUl1TSxNQUFNLENBQUMsQ0FBQ0U7UUFDZDtRQUVBek0sSUFBSW9JLFNBQVMsQ0FBQyxDQUFDNUcsR0FBRyxDQUFDQztJQUNyQjtBQUVGO0FBRUEsTUFBTXdqQixvQkFBb0JoVztJQUN4QmxTLGFBQWM7UUFDWixLQUFLLElBQUl6RjtRQUNULElBQUksQ0FBQ3NOLElBQUksR0FBRztJQUNkO0lBRUEyRSxTQUFTLENBQ1Q7QUFFRjtBQUVBLE1BQU0yYixpQkFBaUIvTTtJQUNyQnBiLGFBQWM7UUFDWixLQUFLLElBQUl6RjtRQUNULElBQUksQ0FBQ3NOLElBQUksR0FBRztJQUNkO0lBRUErVyxlQUFlM2IsR0FBRyxFQUFFO1FBQ2xCLElBQUlnRSxjQUFjLElBQUlrUTtRQUN0QixJQUFJLENBQUN6RSxRQUFRLENBQUNoTSxPQUFPLENBQUM4TixDQUFBQTtZQUNwQnZOLFlBQVk0USxjQUFjLENBQUNyRCxNQUFNb0ssY0FBYyxDQUFDM2I7UUFDbEQ7UUFDQSxPQUFPZ0U7SUFDVDtBQUVGO0FBRUEsTUFBTW1oQix3QkFBd0JsVztJQUM1QmxTLFlBQVlDLFNBQVEsRUFBRXRFLElBQUksRUFBRXdXLGdCQUFnQixDQUFFO1FBQzVDLEtBQUssQ0FBQ2xTLFdBQVV0RSxNQUFNd1c7UUFDdEIsSUFBSSxDQUFDa1csbUJBQW1CLEdBQUc7WUFBQztTQUFnQjtRQUM1QyxJQUFJLENBQUNDLEtBQUssR0FBRyxFQUFFO1FBQ2YsSUFBSSxFQUNGQSxLQUFLLEVBQ0w1VixRQUFRLEVBQ1QsR0FBRyxJQUFJO1FBQ1JBLFNBQVNoTSxPQUFPLENBQUM4TixDQUFBQTtZQUNmLElBQUlBLE1BQU0zTSxJQUFJLEtBQUssUUFBUTtnQkFDekJ5Z0IsTUFBTW5rQixJQUFJLENBQUNxUTtZQUNiO1FBQ0Y7SUFDRjtJQUVBK1QsbUJBQW1CO1FBQ2pCLE9BQU8sSUFBSSxDQUFDbGxCLFlBQVksQ0FBQyxpQkFBaUI5QyxTQUFTLENBQUM7SUFDdEQ7SUFFQXlDLGVBQWVDLEdBQUcsRUFBRUgsT0FBTyxFQUFFeWtCLGlCQUFpQixFQUFFO1FBQzlDLDZFQUE2RTtRQUM3RSxJQUFJaUIsaUJBQWlCLElBQUk7UUFFekIsSUFBSSxJQUFJLENBQUNybEIsZ0JBQWdCLEdBQUcxQyxRQUFRLElBQUk7WUFDdEMrbkIsaUJBQWlCLElBQUksQ0FBQ3JsQixnQkFBZ0IsR0FBR1IsYUFBYTtZQUN0RCxJQUFJLENBQUM4bEIsb0JBQW9CLENBQUNEO1FBQzVCO1FBRUEsSUFBSSxFQUNGRixLQUFLLEVBQ04sR0FBR0U7UUFDSixJQUFJRSxXQUFXLElBQUksQ0FBQ0MsV0FBVyxDQUFDMWxCLEtBQUtIO1FBRXJDLElBQUksQ0FBQzRsQixVQUFVO1lBQ2IsT0FBTyxJQUFJLENBQUNFLGdCQUFnQixDQUFDckIsbUJBQW1CZSxLQUFLLENBQUNBLE1BQU05dEIsTUFBTSxHQUFHLEVBQUUsQ0FBQzhDLEtBQUs7UUFDL0U7UUFFQWdyQixNQUFNNWhCLE9BQU8sQ0FBQ0wsQ0FBQUE7WUFDWnFpQixTQUFTRyxZQUFZLENBQUN4aUIsS0FBS3lXLE1BQU0sRUFBRSxJQUFJLENBQUM4TCxnQkFBZ0IsQ0FBQ3JCLG1CQUFtQmxoQixLQUFLL0ksS0FBSztRQUN4RjtRQUVBLElBQUksSUFBSSxDQUFDK0YsWUFBWSxDQUFDLHFCQUFxQjVDLFFBQVEsSUFBSTtZQUNyRCxvREFBb0Q7WUFDcEQsSUFBSSxFQUNGUixVQUFBQSxTQUFRLEVBQ1QsR0FBRyxJQUFJO1lBQ1IsSUFBSSxFQUNGa0ksa0JBQWtCLEVBQ2xCaEcsUUFBUSxFQUNULEdBQUdsQyxVQUFTbUMsTUFBTTtZQUNuQixJQUFJLENBQUMwbUIsU0FBUyxHQUFHM21CLFNBQVM2QixTQUFTO1lBQ25DLElBQUkra0IsT0FBTyxJQUFJdkMsWUFBWXZtQixXQUFVO1lBQ3JDOG9CLEtBQUszVyxVQUFVLENBQUMzTixDQUFDLEdBQUcsSUFBSTFFLFNBQVNFLFdBQVUsS0FBSyxDQUFDa0kscUJBQXFCO1lBQ3RFNGdCLEtBQUszVyxVQUFVLENBQUMxTixDQUFDLEdBQUcsSUFBSTNFLFNBQVNFLFdBQVUsS0FBSyxDQUFDa0kscUJBQXFCO1lBQ3RFNGdCLEtBQUszVyxVQUFVLENBQUNyWCxLQUFLLEdBQUcsSUFBSWdGLFNBQVNFLFdBQVUsU0FBU2tJO1lBQ3hENGdCLEtBQUszVyxVQUFVLENBQUNwWCxNQUFNLEdBQUcsSUFBSStFLFNBQVNFLFdBQVUsVUFBVWtJO1lBQzFELElBQUk2Z0IsUUFBUSxJQUFJYixTQUFTbG9CLFdBQVU7WUFDbkMrb0IsTUFBTTVXLFVBQVUsQ0FBQzdNLFNBQVMsR0FBRyxJQUFJeEYsU0FBU0UsV0FBVSxhQUFhLElBQUksQ0FBQ29ELFlBQVksQ0FBQyxxQkFBcUJsQyxRQUFRO1lBQ2hINm5CLE1BQU10VyxRQUFRLEdBQUc7Z0JBQUNxVzthQUFLO1lBQ3ZCLElBQUl2QixhQUFhLElBQUlqQyxXQUFXdGxCLFdBQVU7WUFDMUN1bkIsV0FBV3BWLFVBQVUsQ0FBQzNOLENBQUMsR0FBRyxJQUFJMUUsU0FBU0UsV0FBVSxLQUFLO1lBQ3REdW5CLFdBQVdwVixVQUFVLENBQUMxTixDQUFDLEdBQUcsSUFBSTNFLFNBQVNFLFdBQVUsS0FBSztZQUN0RHVuQixXQUFXcFYsVUFBVSxDQUFDclgsS0FBSyxHQUFHLElBQUlnRixTQUFTRSxXQUFVLFNBQVM2b0IsU0FBUy90QixLQUFLO1lBQzVFeXNCLFdBQVdwVixVQUFVLENBQUNwWCxNQUFNLEdBQUcsSUFBSStFLFNBQVNFLFdBQVUsVUFBVTZvQixTQUFTOXRCLE1BQU07WUFDL0V3c0IsV0FBVzlVLFFBQVEsR0FBRztnQkFBQ3NXO2FBQU07WUFDN0IsSUFBSXZCLGdCQUFnQnhuQixVQUFTbkYsWUFBWSxDQUFDZ3VCLFNBQVMvdEIsS0FBSyxFQUFFK3RCLFNBQVM5dEIsTUFBTTtZQUN6RSxJQUFJMHNCLGFBQWFELGNBQWNFLFVBQVUsQ0FBQztZQUMxQ0QsV0FBVzdMLFNBQVMsR0FBRzZNO1lBQ3ZCbEIsV0FBV2hiLE1BQU0sQ0FBQ2tiO1lBQ2xCLE9BQU9BLFdBQVd4a0IsYUFBYSxDQUFDdWtCLGVBQWU7UUFDakQ7UUFFQSxPQUFPaUI7SUFDVDtJQUVBRCxxQkFBcUJELGNBQWMsRUFBRTtRQUNuQyxJQUFJLENBQUNILG1CQUFtQixDQUFDM2hCLE9BQU8sQ0FBQ3VpQixDQUFBQTtZQUMvQixJQUFJLENBQUMsSUFBSSxDQUFDNWxCLFlBQVksQ0FBQzRsQixvQkFBb0J4b0IsUUFBUSxNQUFNK25CLGVBQWVubEIsWUFBWSxDQUFDNGxCLG9CQUFvQnhvQixRQUFRLElBQUk7Z0JBQ25ILElBQUksQ0FBQzRDLFlBQVksQ0FBQzRsQixvQkFBb0IsTUFBTS9uQixRQUFRLENBQUNzbkIsZUFBZW5sQixZQUFZLENBQUM0bEIsb0JBQW9COW5CLFFBQVE7WUFDL0c7UUFDRjtJQUNGO0lBRUF5bkIsaUJBQWlCckIsaUJBQWlCLEVBQUVqcUIsS0FBSyxFQUFFO1FBQ3pDLElBQUlpcUIsa0JBQWtCOW1CLFFBQVEsSUFBSTtZQUNoQyxJQUFJeW9CLFlBQVksSUFBSW5wQixTQUFTLElBQUksQ0FBQ0UsUUFBUSxFQUFFLFNBQVMzQztZQUNyRCxPQUFPNHJCLFVBQVUxbEIsVUFBVSxDQUFDK2pCLG1CQUFtQmhtQixRQUFRO1FBQ3pEO1FBRUEsT0FBT2pFO0lBQ1Q7QUFFRjtBQUVBLE1BQU02ckIsOEJBQThCZjtJQUNsQ3BvQixZQUFZQyxTQUFRLEVBQUV0RSxJQUFJLEVBQUV3VyxnQkFBZ0IsQ0FBRTtRQUM1QyxLQUFLLENBQUNsUyxXQUFVdEUsTUFBTXdXO1FBQ3RCLElBQUksQ0FBQ3RLLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ3dnQixtQkFBbUIsQ0FBQ2xrQixJQUFJLENBQUMsTUFBTSxNQUFNLE1BQU07SUFDbEQ7SUFFQXdrQixZQUFZMWxCLEdBQUcsRUFBRUgsT0FBTyxFQUFFO1FBQ3hCLElBQUlzbUIscUJBQXFCLElBQUksQ0FBQ2IsZ0JBQWdCLE9BQU87UUFDckQsSUFBSXRoQixjQUFjbWlCLHFCQUFxQnRtQixRQUFROGIsY0FBYyxDQUFDM2IsT0FBTztRQUVyRSxJQUFJbW1CLHNCQUFzQixDQUFDbmlCLGFBQWE7WUFDdEMsT0FBTztRQUNUO1FBRUEsSUFBSSxDQUFDLElBQUksQ0FBQzVELFlBQVksQ0FBQyxNQUFNNUMsUUFBUSxNQUFNLENBQUMsSUFBSSxDQUFDNEMsWUFBWSxDQUFDLE1BQU01QyxRQUFRLE1BQU0sQ0FBQyxJQUFJLENBQUM0QyxZQUFZLENBQUMsTUFBTTVDLFFBQVEsTUFBTSxDQUFDLElBQUksQ0FBQzRDLFlBQVksQ0FBQyxNQUFNNUMsUUFBUSxJQUFJO1lBQzVKLElBQUksQ0FBQzRDLFlBQVksQ0FBQyxNQUFNLE1BQU1uQyxRQUFRLENBQUM7WUFDdkMsSUFBSSxDQUFDbUMsWUFBWSxDQUFDLE1BQU0sTUFBTW5DLFFBQVEsQ0FBQztZQUN2QyxJQUFJLENBQUNtQyxZQUFZLENBQUMsTUFBTSxNQUFNbkMsUUFBUSxDQUFDO1lBQ3ZDLElBQUksQ0FBQ21DLFlBQVksQ0FBQyxNQUFNLE1BQU1uQyxRQUFRLENBQUM7UUFDekM7UUFFQSxJQUFJa1csS0FBS2dTLHFCQUFxQm5pQixZQUFZeEMsQ0FBQyxHQUFHd0MsWUFBWWxNLEtBQUssR0FBRyxJQUFJLENBQUNzSSxZQUFZLENBQUMsTUFBTWhDLFNBQVMsS0FBSyxJQUFJLENBQUNnQyxZQUFZLENBQUMsTUFBTXZCLFNBQVMsQ0FBQztRQUMxSSxJQUFJeVYsS0FBSzZSLHFCQUFxQm5pQixZQUFZdkMsQ0FBQyxHQUFHdUMsWUFBWWpNLE1BQU0sR0FBRyxJQUFJLENBQUNxSSxZQUFZLENBQUMsTUFBTWhDLFNBQVMsS0FBSyxJQUFJLENBQUNnQyxZQUFZLENBQUMsTUFBTXZCLFNBQVMsQ0FBQztRQUMzSSxJQUFJMFYsS0FBSzRSLHFCQUFxQm5pQixZQUFZeEMsQ0FBQyxHQUFHd0MsWUFBWWxNLEtBQUssR0FBRyxJQUFJLENBQUNzSSxZQUFZLENBQUMsTUFBTWhDLFNBQVMsS0FBSyxJQUFJLENBQUNnQyxZQUFZLENBQUMsTUFBTXZCLFNBQVMsQ0FBQztRQUMxSSxJQUFJMlYsS0FBSzJSLHFCQUFxQm5pQixZQUFZdkMsQ0FBQyxHQUFHdUMsWUFBWWpNLE1BQU0sR0FBRyxJQUFJLENBQUNxSSxZQUFZLENBQUMsTUFBTWhDLFNBQVMsS0FBSyxJQUFJLENBQUNnQyxZQUFZLENBQUMsTUFBTXZCLFNBQVMsQ0FBQztRQUUzSSxJQUFJc1YsT0FBT0ksTUFBTUQsT0FBT0UsSUFBSTtZQUMxQixPQUFPO1FBQ1Q7UUFFQSxPQUFPeFUsSUFBSW9tQixvQkFBb0IsQ0FBQ2pTLElBQUlHLElBQUlDLElBQUlDO0lBQzlDO0FBRUY7QUFFQSxNQUFNNlIsOEJBQThCbEI7SUFDbENwb0IsWUFBWUMsU0FBUSxFQUFFdEUsSUFBSSxFQUFFd1csZ0JBQWdCLENBQUU7UUFDNUMsS0FBSyxDQUFDbFMsV0FBVXRFLE1BQU13VztRQUN0QixJQUFJLENBQUN0SyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUN3Z0IsbUJBQW1CLENBQUNsa0IsSUFBSSxDQUFDLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTTtJQUM3RDtJQUVBd2tCLFlBQVkxbEIsR0FBRyxFQUFFSCxPQUFPLEVBQUU7UUFDeEIsSUFBSXNtQixxQkFBcUIsSUFBSSxDQUFDYixnQkFBZ0IsT0FBTztRQUNyRCxJQUFJdGhCLGNBQWNuRSxRQUFROGIsY0FBYyxDQUFDM2I7UUFFekMsSUFBSW1tQixzQkFBc0IsQ0FBQ25pQixhQUFhO1lBQ3RDLE9BQU87UUFDVDtRQUVBLElBQUksQ0FBQyxJQUFJLENBQUM1RCxZQUFZLENBQUMsTUFBTTVDLFFBQVEsSUFBSTtZQUN2QyxJQUFJLENBQUM0QyxZQUFZLENBQUMsTUFBTSxNQUFNbkMsUUFBUSxDQUFDO1FBQ3pDO1FBRUEsSUFBSSxDQUFDLElBQUksQ0FBQ21DLFlBQVksQ0FBQyxNQUFNNUMsUUFBUSxJQUFJO1lBQ3ZDLElBQUksQ0FBQzRDLFlBQVksQ0FBQyxNQUFNLE1BQU1uQyxRQUFRLENBQUM7UUFDekM7UUFFQSxJQUFJLENBQUMsSUFBSSxDQUFDbUMsWUFBWSxDQUFDLEtBQUs1QyxRQUFRLElBQUk7WUFDdEMsSUFBSSxDQUFDNEMsWUFBWSxDQUFDLEtBQUssTUFBTW5DLFFBQVEsQ0FBQztRQUN4QztRQUVBLElBQUkyTyxLQUFLdVoscUJBQXFCbmlCLFlBQVl4QyxDQUFDLEdBQUd3QyxZQUFZbE0sS0FBSyxHQUFHLElBQUksQ0FBQ3NJLFlBQVksQ0FBQyxNQUFNaEMsU0FBUyxLQUFLLElBQUksQ0FBQ2dDLFlBQVksQ0FBQyxNQUFNdkIsU0FBUyxDQUFDO1FBQzFJLElBQUlnTyxLQUFLc1oscUJBQXFCbmlCLFlBQVl2QyxDQUFDLEdBQUd1QyxZQUFZak0sTUFBTSxHQUFHLElBQUksQ0FBQ3FJLFlBQVksQ0FBQyxNQUFNaEMsU0FBUyxLQUFLLElBQUksQ0FBQ2dDLFlBQVksQ0FBQyxNQUFNdkIsU0FBUyxDQUFDO1FBQzNJLElBQUl5bkIsS0FBSzFaO1FBQ1QsSUFBSTJaLEtBQUsxWjtRQUVULElBQUksSUFBSSxDQUFDek0sWUFBWSxDQUFDLE1BQU01QyxRQUFRLElBQUk7WUFDdEM4b0IsS0FBS0gscUJBQXFCbmlCLFlBQVl4QyxDQUFDLEdBQUd3QyxZQUFZbE0sS0FBSyxHQUFHLElBQUksQ0FBQ3NJLFlBQVksQ0FBQyxNQUFNaEMsU0FBUyxLQUFLLElBQUksQ0FBQ2dDLFlBQVksQ0FBQyxNQUFNdkIsU0FBUyxDQUFDO1FBQ3hJO1FBRUEsSUFBSSxJQUFJLENBQUN1QixZQUFZLENBQUMsTUFBTTVDLFFBQVEsSUFBSTtZQUN0QytvQixLQUFLSixxQkFBcUJuaUIsWUFBWXZDLENBQUMsR0FBR3VDLFlBQVlqTSxNQUFNLEdBQUcsSUFBSSxDQUFDcUksWUFBWSxDQUFDLE1BQU1oQyxTQUFTLEtBQUssSUFBSSxDQUFDZ0MsWUFBWSxDQUFDLE1BQU12QixTQUFTLENBQUM7UUFDekk7UUFFQSxJQUFJb2YsSUFBSWtJLHFCQUFxQixDQUFDbmlCLFlBQVlsTSxLQUFLLEdBQUdrTSxZQUFZak0sTUFBTSxJQUFJLE1BQU0sSUFBSSxDQUFDcUksWUFBWSxDQUFDLEtBQUtoQyxTQUFTLEtBQUssSUFBSSxDQUFDZ0MsWUFBWSxDQUFDLEtBQUt2QixTQUFTO1FBQ25KLElBQUkybkIsS0FBSyxJQUFJLENBQUNwbUIsWUFBWSxDQUFDLE1BQU12QixTQUFTO1FBQzFDLE9BQU9tQixJQUFJeW1CLG9CQUFvQixDQUFDSCxJQUFJQyxJQUFJQyxJQUFJNVosSUFBSUMsSUFBSW9SO0lBQ3REO0FBRUY7QUFFQSxNQUFNeUksb0JBQW9Celg7SUFDeEJsUyxZQUFZQyxTQUFRLEVBQUV0RSxJQUFJLEVBQUV3VyxnQkFBZ0IsQ0FBRTtRQUM1QyxLQUFLLENBQUNsUyxXQUFVdEUsTUFBTXdXO1FBQ3RCLElBQUksQ0FBQ3RLLElBQUksR0FBRztRQUNaLElBQUlpVixTQUFTamYsS0FBSzBFLEdBQUcsQ0FBQyxHQUFHMUUsS0FBS3dFLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQ2dCLFlBQVksQ0FBQyxVQUFVaEMsU0FBUztRQUMxRSxJQUFJdW9CLGNBQWMsSUFBSSxDQUFDemMsUUFBUSxDQUFDO1FBQ2hDLElBQUkwYyxZQUFZLElBQUksQ0FBQzFjLFFBQVEsQ0FBQyxjQUFjO1FBRTVDLElBQUkwYyxVQUFVdHBCLFNBQVMsT0FBTyxJQUFJO1lBQ2hDc3BCLFVBQVUzb0IsUUFBUSxDQUFDO1FBQ3JCO1FBRUEsSUFBSTBvQixZQUFZbnBCLFFBQVEsSUFBSTtZQUMxQm9wQixZQUFZQSxVQUFVcm1CLFVBQVUsQ0FBQ29tQjtRQUNuQztRQUVBLElBQUksQ0FBQzlNLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUN4ZixLQUFLLEdBQUd1c0IsVUFBVXRvQixRQUFRO0lBQ2pDO0FBRUY7QUFFQSxNQUFNdW9CLHVCQUF1QjVYO0lBQzNCbFMsWUFBWUMsU0FBUSxFQUFFdEUsSUFBSSxFQUFFd1csZ0JBQWdCLENBQUU7UUFDNUMsS0FBSyxDQUFDbFMsV0FBVXRFLE1BQU13VztRQUN0QixJQUFJLENBQUN0SyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNraUIsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0MsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0MsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDQyxNQUFNLEdBQUc7UUFDZGxxQixVQUFTbUMsTUFBTSxDQUFDbUcsVUFBVSxDQUFDcEUsSUFBSSxDQUFDLElBQUk7UUFDcEMsSUFBSSxDQUFDaW1CLEtBQUssR0FBRyxJQUFJLENBQUMvbUIsWUFBWSxDQUFDLFNBQVNiLGVBQWU7UUFDdkQsSUFBSSxDQUFDNm5CLFdBQVcsR0FBRyxJQUFJLENBQUNELEtBQUssR0FBRyxJQUFJLENBQUMvbUIsWUFBWSxDQUFDLE9BQU9iLGVBQWU7UUFDeEUsSUFBSSxDQUFDcVEsSUFBSSxHQUFHLElBQUksQ0FBQ3hQLFlBQVksQ0FBQztRQUM5QixJQUFJLENBQUNpbkIsRUFBRSxHQUFHLElBQUksQ0FBQ2puQixZQUFZLENBQUM7UUFDNUIsSUFBSSxDQUFDa25CLE1BQU0sR0FBRyxJQUFJeHFCLFNBQVNFLFdBQVUsVUFBVTtRQUMvQyxJQUFJdXFCLGFBQWEsSUFBSSxDQUFDbm5CLFlBQVksQ0FBQztRQUVuQyxJQUFJbW5CLFdBQVcvcEIsUUFBUSxJQUFJO1lBQ3pCLElBQUksQ0FBQzhwQixNQUFNLENBQUNycEIsUUFBUSxDQUFDc3BCLFdBQVdqcUIsU0FBUyxHQUFHRixLQUFLLENBQUM7UUFDcEQ7SUFDRjtJQUVBb3FCLGNBQWM7UUFDWixJQUFJQyxnQkFBZ0IsSUFBSSxDQUFDcm5CLFlBQVksQ0FBQyxpQkFBaUI5QyxTQUFTO1FBQ2hFLElBQUlvcUIsZ0JBQWdCLElBQUksQ0FBQ3RuQixZQUFZLENBQUMsaUJBQWlCOUMsU0FBUztRQUVoRSxJQUFJbXFCLGtCQUFrQixPQUFPO1lBQzNCLE9BQU8sSUFBSSxDQUFDOWpCLE1BQU0sQ0FBQ3VHLFFBQVEsQ0FBQ3dkLGVBQWU7UUFDN0M7UUFFQSxPQUFPLElBQUksQ0FBQy9qQixNQUFNLENBQUN2RCxZQUFZLENBQUNzbkIsZUFBZTtJQUNqRDtJQUVBQyxZQUFZO1FBQ1YsSUFBSSxFQUNGWCxZQUFZLEVBQ2IsR0FBRyxJQUFJO1FBQ1IsSUFBSSxFQUNGWSxRQUFRLEVBQ1JoWSxJQUFJLEVBQ0p5WCxFQUFFLEVBQ0gsR0FBRyxJQUFJLENBQUNRLFdBQVcsSUFBSSx1QkFBdUI7UUFFL0MsSUFBSUMsV0FBV2xZLEtBQUt4UixTQUFTLEtBQUssQ0FBQ2lwQixHQUFHanBCLFNBQVMsS0FBS3dSLEtBQUt4UixTQUFTLEVBQUMsSUFBS3dwQjtRQUV4RSxJQUFJWixpQkFBaUIsS0FBSztZQUN4QmMsWUFBWSxPQUFPLHNEQUFzRDtRQUMzRTtRQUVBLE9BQU8sR0FBRzFkLE1BQU0sQ0FBQzBkLFVBQVUxZCxNQUFNLENBQUM0YztJQUNwQztJQUVBaGQsT0FBT3JPLEtBQUssRUFBRTtRQUNaLElBQUksRUFDRmdJLE1BQU0sRUFDUCxHQUFHLElBQUk7UUFDUixJQUFJb2tCLE9BQU8sSUFBSSxDQUFDUCxXQUFXLElBQUksb0JBQW9CO1FBRW5ELElBQUksQ0FBQyxJQUFJLENBQUNULFlBQVksRUFBRTtZQUN0QixJQUFJLENBQUNBLFlBQVksR0FBR2dCLEtBQUt6cUIsU0FBUztZQUNsQyxJQUFJLENBQUMwcEIsWUFBWSxHQUFHZSxLQUFLbnBCLFFBQVE7UUFDbkMsRUFBRSw2QkFBNkI7UUFHL0IsSUFBSSxJQUFJLENBQUNrb0IsUUFBUSxHQUFHLElBQUksQ0FBQ00sV0FBVyxFQUFFO1lBQ3BDLElBQUlyTCxPQUFPLElBQUksQ0FBQzNiLFlBQVksQ0FBQyxRQUFROUMsU0FBUyxDQUFDLFdBQVcsNkNBQTZDO1lBRXZHLElBQUksSUFBSSxDQUFDOEMsWUFBWSxDQUFDLGVBQWU5QyxTQUFTLE9BQU8sZ0JBQWdCLElBQUksQ0FBQzhDLFlBQVksQ0FBQyxhQUFhOUMsU0FBUyxPQUFPLGNBQWM7Z0JBQ2hJLElBQUksQ0FBQ3dwQixRQUFRLEdBQUc7WUFDbEIsT0FBTyxJQUFJL0ssU0FBUyxZQUFZLENBQUMsSUFBSSxDQUFDbUwsTUFBTSxFQUFFO2dCQUM1QyxJQUFJLENBQUNBLE1BQU0sR0FBRztnQkFDZHZqQixPQUFPNEwsZUFBZSxHQUFHO2dCQUN6QjVMLE9BQU82TCxvQkFBb0IsR0FBR3VZLEtBQUt6cUIsU0FBUztZQUM5QyxPQUFPLElBQUl5ZSxTQUFTLFlBQVksQ0FBQyxJQUFJLENBQUNrTCxPQUFPLEVBQUU7Z0JBQzdDLElBQUksQ0FBQ0EsT0FBTyxHQUFHO2dCQUNmYyxLQUFLOXBCLFFBQVEsQ0FBQzBGLE9BQU80TCxlQUFlLEdBQUc1TCxPQUFPNkwsb0JBQW9CLEdBQUcsSUFBSSxDQUFDdVgsWUFBWTtnQkFDdEYsT0FBTztZQUNUO1lBRUEsT0FBTztRQUNUO1FBRUEsSUFBSSxDQUFDRCxRQUFRLElBQUluckIsT0FBTywrQkFBK0I7UUFFdkQsSUFBSXFzQixVQUFVO1FBRWQsSUFBSSxJQUFJLENBQUNiLEtBQUssR0FBRyxJQUFJLENBQUNMLFFBQVEsRUFBRTtZQUM5QixJQUFJZ0IsV0FBVyxJQUFJLENBQUNILFNBQVMsSUFBSSxRQUFRO1lBRXpDLElBQUlNLFdBQVcsSUFBSSxDQUFDN25CLFlBQVksQ0FBQztZQUVqQyxJQUFJNm5CLFNBQVN6cUIsUUFBUSxJQUFJO2dCQUN2QixzQkFBc0I7Z0JBQ3RCLElBQUlvSCxPQUFPcWpCLFNBQVMzcUIsU0FBUztnQkFDN0J3cUIsV0FBVyxHQUFHMWQsTUFBTSxDQUFDeEYsTUFBTSxLQUFLd0YsTUFBTSxDQUFDMGQsVUFBVTtZQUNuRDtZQUVBQyxLQUFLOXBCLFFBQVEsQ0FBQzZwQjtZQUNkRSxVQUFVO1FBQ1o7UUFFQSxPQUFPQTtJQUNUO0lBRUFILGNBQWM7UUFDWixJQUFJLEVBQ0Y3cUIsVUFBQUEsU0FBUSxFQUNSc3FCLE1BQU0sRUFDUCxHQUFHLElBQUk7UUFDUixJQUFJMXBCLFNBQVM7WUFDWGdxQixVQUFVLENBQUMsSUFBSSxDQUFDZCxRQUFRLEdBQUcsSUFBSSxDQUFDSyxLQUFLLElBQUssS0FBSSxDQUFDQyxXQUFXLEdBQUcsSUFBSSxDQUFDRCxLQUFLO1FBQ3pFO1FBRUEsSUFBSUcsT0FBTzlwQixRQUFRLElBQUk7WUFDckIsSUFBSTBxQixJQUFJdHFCLE9BQU9ncUIsUUFBUSxHQUFJTixDQUFBQSxPQUFPcHBCLFFBQVEsR0FBRzNHLE1BQU0sR0FBRztZQUN0RCxJQUFJNHdCLEtBQUt2dEIsS0FBS3d0QixLQUFLLENBQUNGO1lBQ3BCLElBQUlHLEtBQUt6dEIsS0FBSzB0QixJQUFJLENBQUNKO1lBQ25CdHFCLE9BQU9nUyxJQUFJLEdBQUcsSUFBSTlTLFNBQVNFLFdBQVUsUUFBUXJELFdBQVcydEIsT0FBT3BwQixRQUFRLEVBQUUsQ0FBQ2lxQixHQUFHO1lBQzdFdnFCLE9BQU95cEIsRUFBRSxHQUFHLElBQUl2cUIsU0FBU0UsV0FBVSxNQUFNckQsV0FBVzJ0QixPQUFPcHBCLFFBQVEsRUFBRSxDQUFDbXFCLEdBQUc7WUFDekV6cUIsT0FBT2dxQixRQUFRLEdBQUcsQ0FBQ00sSUFBSUMsRUFBQyxJQUFNRSxDQUFBQSxLQUFLRixFQUFDO1FBQ3RDLE9BQU87WUFDTHZxQixPQUFPZ1MsSUFBSSxHQUFHLElBQUksQ0FBQ0EsSUFBSTtZQUN2QmhTLE9BQU95cEIsRUFBRSxHQUFHLElBQUksQ0FBQ0EsRUFBRTtRQUNyQjtRQUVBLE9BQU96cEI7SUFDVDtBQUVGO0FBRUEsTUFBTTJxQiw0QkFBNEIxQjtJQUNoQzlwQixhQUFjO1FBQ1osS0FBSyxJQUFJekY7UUFDVCxJQUFJLENBQUNzTixJQUFJLEdBQUc7SUFDZDtJQUVBK2lCLFlBQVk7UUFDVixJQUFJLEVBQ0ZDLFFBQVEsRUFDUmhZLElBQUksRUFDSnlYLEVBQUUsRUFDSCxHQUFHLElBQUksQ0FBQ1EsV0FBVztRQUNwQixJQUFJVyxZQUFZLElBQUl4eEIsc0NBQVFBLENBQUM0WSxLQUFLdFIsUUFBUTtRQUMxQyxJQUFJbXFCLFVBQVUsSUFBSXp4QixzQ0FBUUEsQ0FBQ3F3QixHQUFHL29CLFFBQVE7UUFFdEMsSUFBSWtxQixVQUFVN25CLEVBQUUsSUFBSThuQixRQUFROW5CLEVBQUUsRUFBRTtZQUM5Qix1QkFBdUI7WUFDdkIsSUFBSXNkLElBQUl1SyxVQUFVdkssQ0FBQyxHQUFHLENBQUN3SyxRQUFReEssQ0FBQyxHQUFHdUssVUFBVXZLLENBQUMsSUFBSTJKO1lBQ2xELElBQUkvWixJQUFJMmEsVUFBVTNhLENBQUMsR0FBRyxDQUFDNGEsUUFBUTVhLENBQUMsR0FBRzJhLFVBQVUzYSxDQUFDLElBQUkrWjtZQUNsRCxJQUFJbmEsSUFBSSthLFVBQVUvYSxDQUFDLEdBQUcsQ0FBQ2diLFFBQVFoYixDQUFDLEdBQUcrYSxVQUFVL2EsQ0FBQyxJQUFJbWEsVUFBVSxVQUFVO1lBRXRFLE9BQU8sT0FBT3hkLE1BQU0sQ0FBQ3hQLEtBQUt3dEIsS0FBSyxDQUFDbkssSUFBSSxNQUFNN1QsTUFBTSxDQUFDeFAsS0FBS3d0QixLQUFLLENBQUN2YSxJQUFJLE1BQU16RCxNQUFNLENBQUN4UCxLQUFLd3RCLEtBQUssQ0FBQzNhLElBQUk7UUFDOUY7UUFFQSxPQUFPLElBQUksQ0FBQ3JOLFlBQVksQ0FBQyxRQUFROUIsUUFBUTtJQUMzQztBQUVGO0FBRUEsTUFBTW9xQixnQ0FBZ0M3QjtJQUNwQzlwQixhQUFjO1FBQ1osS0FBSyxJQUFJekY7UUFDVCxJQUFJLENBQUNzTixJQUFJLEdBQUc7SUFDZDtJQUVBK2lCLFlBQVk7UUFDVixJQUFJLEVBQ0ZDLFFBQVEsRUFDUmhZLElBQUksRUFDSnlYLEVBQUUsRUFDSCxHQUFHLElBQUksQ0FBQ1EsV0FBVyxJQUFJLHVCQUF1QjtRQUUvQyxJQUFJYyxnQkFBZ0JwdkIsVUFBVXFXLEtBQUt0UyxTQUFTO1FBQzVDLElBQUlzckIsY0FBY3J2QixVQUFVOHRCLEdBQUcvcEIsU0FBUztRQUN4QyxJQUFJd3FCLFdBQVdhLGNBQWNqdkIsR0FBRyxDQUFDLENBQUNrVyxNQUFNbFA7WUFDdEMsSUFBSTJtQixLQUFLdUIsV0FBVyxDQUFDbG9CLEVBQUU7WUFDdkIsT0FBT2tQLE9BQU8sQ0FBQ3lYLEtBQUt6WCxJQUFHLElBQUtnWTtRQUM5QixHQUFHaHNCLElBQUksQ0FBQztRQUNSLE9BQU9rc0I7SUFDVDtBQUVGO0FBRUEsTUFBTWUsb0JBQW9CNVo7SUFDeEJsUyxZQUFZQyxTQUFRLEVBQUV0RSxJQUFJLEVBQUV3VyxnQkFBZ0IsQ0FBRTtRQUM1QyxLQUFLLENBQUNsUyxXQUFVdEUsTUFBTXdXO1FBQ3RCLElBQUksQ0FBQ3RLLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ29iLE1BQU0sR0FBR2puQixPQUFPcVcsTUFBTSxDQUFDO1FBQzVCLElBQUksQ0FBQ21QLFNBQVMsR0FBRyxJQUFJLENBQUNuZSxZQUFZLENBQUMsZUFBZWhDLFNBQVM7UUFDM0QsSUFBSSxFQUNGdUIsV0FBVyxFQUNaLEdBQUczQztRQUNKLElBQUksRUFDRnlTLFFBQVEsRUFDVCxHQUFHLElBQUk7UUFFUixLQUFLLElBQUk4QixTQUFTOUIsU0FBVTtZQUMxQixPQUFROEIsTUFBTTNNLElBQUk7Z0JBQ2hCLEtBQUs7b0JBQ0g7d0JBQ0UsSUFBSSxDQUFDK2IsUUFBUSxHQUFHcFA7d0JBQ2hCLElBQUl1WCxrQkFBa0J2WCxNQUFNckgsUUFBUSxDQUFDO3dCQUVyQyxJQUFJNGUsZ0JBQWdCdHJCLFFBQVEsSUFBSTs0QkFDOUJtQyxXQUFXLENBQUNtcEIsZ0JBQWdCeHJCLFNBQVMsR0FBRyxHQUFHLElBQUk7d0JBQ2pEO3dCQUVBO29CQUNGO2dCQUVGLEtBQUs7b0JBQ0gsSUFBSSxDQUFDNGlCLFlBQVksR0FBRzNPO29CQUNwQjtnQkFFRixLQUFLO29CQUNIO3dCQUNFLElBQUlxTyxRQUFRck87d0JBRVosSUFBSXFPLE1BQU1uQixVQUFVLEVBQUU7NEJBQ3BCLElBQUksQ0FBQ29DLEtBQUssR0FBRzs0QkFDYixJQUFJLENBQUNoQixRQUFRLEdBQUc7NEJBRWhCLElBQUksT0FBTyxJQUFJLENBQUNHLE1BQU0sQ0FBQ0osTUFBTXBCLE9BQU8sQ0FBQyxLQUFLLGFBQWE7Z0NBQ3JELElBQUksQ0FBQ3dCLE1BQU0sQ0FBQ0osTUFBTXBCLE9BQU8sQ0FBQyxHQUFHemxCLE9BQU9xVyxNQUFNLENBQUM7NEJBQzdDOzRCQUVBLElBQUksQ0FBQzRRLE1BQU0sQ0FBQ0osTUFBTXBCLE9BQU8sQ0FBQyxDQUFDb0IsTUFBTW5CLFVBQVUsQ0FBQyxHQUFHbUI7d0JBQ2pELE9BQU87NEJBQ0wsSUFBSSxDQUFDSSxNQUFNLENBQUNKLE1BQU1wQixPQUFPLENBQUMsR0FBR29CO3dCQUMvQjt3QkFFQTtvQkFDRjtZQUNKO1FBQ0Y7SUFDRjtJQUVBclcsU0FBUyxDQUNUO0FBRUY7QUFFQSxNQUFNd2Ysd0JBQXdCOVo7SUFDNUJsUyxZQUFZQyxTQUFRLEVBQUV0RSxJQUFJLEVBQUV3VyxnQkFBZ0IsQ0FBRTtRQUM1QyxLQUFLLENBQUNsUyxXQUFVdEUsTUFBTXdXO1FBQ3RCLElBQUksQ0FBQ3RLLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ29rQixNQUFNLEdBQUcsSUFBSSxDQUFDNW9CLFlBQVksQ0FBQyxVQUFVaEMsU0FBUztRQUNuRCxJQUFJLENBQUM2cUIsT0FBTyxHQUFHLElBQUksQ0FBQzdvQixZQUFZLENBQUMsV0FBV2hDLFNBQVM7UUFDckQsSUFBSSxDQUFDc2lCLFVBQVUsR0FBRyxJQUFJLENBQUN0Z0IsWUFBWSxDQUFDLGdCQUFnQmhDLFNBQVM7SUFDL0Q7QUFFRjtBQUVBLE1BQU04cUIsNEJBQTRCek87SUFDaEMxZCxhQUFjO1FBQ1osS0FBSyxJQUFJekY7UUFDVCxJQUFJLENBQUNzTixJQUFJLEdBQUc7UUFDWixJQUFJLENBQUMyWixTQUFTLEdBQUc7SUFDbkI7QUFFRjtBQUVBLE1BQU00SyxvQkFBb0J6SztJQUN4QjNoQixhQUFjO1FBQ1osS0FBSyxJQUFJekY7UUFDVCxJQUFJLENBQUNzTixJQUFJLEdBQUc7SUFDZDtJQUVBMEwsVUFBVTtRQUNSLElBQUl6USxVQUFVLElBQUksQ0FBQ0ssZ0JBQWdCLEdBQUdSLGFBQWE7UUFFbkQsSUFBSUcsU0FBUztZQUNYLElBQUl1cEIsYUFBYXZwQixRQUFRNFAsUUFBUSxDQUFDLEVBQUU7WUFFcEMsSUFBSTJaLFlBQVk7Z0JBQ2QsT0FBT0EsV0FBVzlZLE9BQU87WUFDM0I7UUFDRjtRQUVBLE9BQU87SUFDVDtBQUVGO0FBRUEsTUFBTStZLGlCQUFpQjNLO0lBQ3JCM2hCLFlBQVlDLFNBQVEsRUFBRXRFLElBQUksRUFBRXdXLGdCQUFnQixDQUFFO1FBQzVDLEtBQUssQ0FBQ2xTLFdBQVV0RSxNQUFNd1c7UUFDdEIsSUFBSSxDQUFDdEssSUFBSSxHQUFHO1FBQ1osSUFBSSxFQUNGcUwsVUFBVSxFQUNYLEdBQUd2WDtRQUNKLElBQUkwd0IsYUFBYW5aLFVBQVUsQ0FBQyxFQUFFO1FBQzlCLElBQUlxWixVQUFVclosV0FBVzFZLE1BQU0sR0FBRyxLQUFLb1ksTUFBTUMsSUFBSSxDQUFDSyxZQUFZOUosS0FBSyxDQUFDek4sQ0FBQUEsT0FBUUEsS0FBS2dYLFFBQVEsS0FBSztRQUM5RixJQUFJLENBQUM0WixPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDcmQsSUFBSSxHQUFHcWQsVUFBVSxJQUFJLENBQUNuSixlQUFlLENBQUNpSixjQUFjO0lBQzNEO0lBRUE5WSxVQUFVO1FBQ1IsT0FBTyxJQUFJLENBQUNyRSxJQUFJO0lBQ2xCO0lBRUFrRixlQUFlblIsR0FBRyxFQUFFO1FBQ2xCLElBQUksSUFBSSxDQUFDc3BCLE9BQU8sRUFBRTtZQUNoQix5QkFBeUI7WUFDekIsS0FBSyxDQUFDblksZUFBZW5SO1lBQ3JCLElBQUksRUFDRmhELFVBQUFBLFNBQVEsRUFDUndFLENBQUMsRUFDREMsQ0FBQyxFQUNGLEdBQUcsSUFBSTtZQUNSLElBQUksRUFDRjRELEtBQUssRUFDTixHQUFHckksVUFBU21DLE1BQU07WUFDbkIsSUFBSXFVLFdBQVcsSUFBSTFXLFNBQVNFLFdBQVUsWUFBWXNXLEtBQUs1UixLQUFLLENBQUMxRSxVQUFTZ0QsR0FBRyxDQUFDMlQsSUFBSSxFQUFFSCxRQUFRLEdBQUcsb0RBQW9EO1lBRS9JLElBQUluTyxNQUFNckMsU0FBUyxJQUFJO2dCQUNyQnFDLE1BQU10QixnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsSUFBSW1RLFlBQVkxUyxHQUFHQyxJQUFJK1IsU0FBUzNVLFNBQVMsQ0FBQyxNQUFNMkMsSUFBSSxJQUFJLENBQUNpZSxXQUFXLENBQUN6ZixNQUFNeUI7WUFDMUc7UUFDRixPQUFPLElBQUksSUFBSSxDQUFDZ08sUUFBUSxDQUFDbFksTUFBTSxHQUFHLEdBQUc7WUFDbkMsNEJBQTRCO1lBQzVCLElBQUlzVyxJQUFJLElBQUlxWCxTQUFTLElBQUksQ0FBQ2xvQixRQUFRLEVBQUU7WUFDcEM2USxFQUFFNEIsUUFBUSxHQUFHLElBQUksQ0FBQ0EsUUFBUTtZQUMxQjVCLEVBQUVsSyxNQUFNLEdBQUcsSUFBSTtZQUNma0ssRUFBRXRFLE1BQU0sQ0FBQ3ZKO1FBQ1g7SUFDRjtJQUVBNkMsVUFBVTtRQUNSLElBQUksRUFDRm5MLFFBQUFBLE9BQU0sRUFDUCxHQUFHLElBQUksQ0FBQ3NGLFFBQVE7UUFFakIsSUFBSXRGLFNBQVE7WUFDVkEsUUFBTzZ4QixJQUFJLENBQUMsSUFBSSxDQUFDcnBCLGdCQUFnQixHQUFHNUMsU0FBUztRQUMvQztJQUNGO0lBRUF5RixjQUFjO1FBQ1osSUFBSS9DLE1BQU0sSUFBSSxDQUFDaEQsUUFBUSxDQUFDZ0QsR0FBRztRQUMzQkEsSUFBSXBILE1BQU0sQ0FBQzJLLEtBQUssQ0FBQ0MsTUFBTSxHQUFHO0lBQzVCO0FBRUY7QUFFQSxTQUFTZ21CLFVBQVVDLE1BQU0sRUFBRUMsY0FBYztJQUFJLElBQUlDLE9BQU81d0IsT0FBTzR3QixJQUFJLENBQUNGO0lBQVMsSUFBSTF3QixPQUFPNndCLHFCQUFxQixFQUFFO1FBQUUsSUFBSUMsVUFBVTl3QixPQUFPNndCLHFCQUFxQixDQUFDSDtRQUFTLElBQUlDLGdCQUFnQjtZQUFFRyxVQUFVQSxRQUFRNVksTUFBTSxDQUFDLFNBQVU2WSxHQUFHO2dCQUFJLE9BQU8vd0IsT0FBT2d4Qix3QkFBd0IsQ0FBQ04sUUFBUUssS0FBS0UsVUFBVTtZQUFFO1FBQUk7UUFBRUwsS0FBS3pvQixJQUFJLENBQUNpTCxLQUFLLENBQUN3ZCxNQUFNRTtJQUFVO0lBQUUsT0FBT0Y7QUFBTTtBQUUxVixTQUFTTSxnQkFBZ0JDLE1BQU07SUFBSSxJQUFLLElBQUl4cEIsSUFBSSxHQUFHQSxJQUFJcEosVUFBVUMsTUFBTSxFQUFFbUosSUFBSztRQUFFLElBQUl5cEIsU0FBUzd5QixTQUFTLENBQUNvSixFQUFFLElBQUksT0FBT3BKLFNBQVMsQ0FBQ29KLEVBQUUsR0FBRyxDQUFDO1FBQUcsSUFBSUEsSUFBSSxHQUFHO1lBQUU4b0IsVUFBVXp3QixPQUFPb3hCLFNBQVMsTUFBTTFtQixPQUFPLENBQUMsU0FBVWlOLEdBQUc7Z0JBQUk1WixrRUFBZUEsQ0FBQ296QixRQUFReFosS0FBS3laLE1BQU0sQ0FBQ3paLElBQUk7WUFBRztRQUFJLE9BQU8sSUFBSTNYLE9BQU9xeEIseUJBQXlCLEVBQUU7WUFBRXJ4QixPQUFPc3hCLGdCQUFnQixDQUFDSCxRQUFRbnhCLE9BQU9xeEIseUJBQXlCLENBQUNEO1FBQVUsT0FBTztZQUFFWCxVQUFVendCLE9BQU9veEIsU0FBUzFtQixPQUFPLENBQUMsU0FBVWlOLEdBQUc7Z0JBQUkzWCxPQUFPdXhCLGNBQWMsQ0FBQ0osUUFBUXhaLEtBQUszWCxPQUFPZ3hCLHdCQUF3QixDQUFDSSxRQUFRelo7WUFBTztRQUFJO0lBQUU7SUFBRSxPQUFPd1o7QUFBUTtBQUMzaEIsTUFBTUssd0JBQXdCN0w7SUFDNUIzaEIsWUFBWUMsU0FBUSxFQUFFdEUsSUFBSSxFQUFFd1csZ0JBQWdCLENBQUU7UUFDNUMsS0FBSyxDQUFDbFMsV0FBVXRFLE1BQU13VztRQUN0QixJQUFJLENBQUN0SyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUM0bEIsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ0MsVUFBVSxHQUFHO1FBQ2xCLElBQUksQ0FBQ0MsVUFBVSxHQUFHLENBQUM7UUFDbkIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDQyxrQkFBa0IsR0FBRyxFQUFFO1FBQzVCLElBQUksQ0FBQ0MsYUFBYSxHQUFHLElBQUlDLElBQUk7WUFBQztnQkFBQztnQkFBSTthQUFFO1NBQUM7UUFDdEMsSUFBSUMsY0FBYyxJQUFJLENBQUM3cUIsZ0JBQWdCLEdBQUdSLGFBQWE7UUFDdkQsSUFBSSxDQUFDdU0sSUFBSSxHQUFHLElBQUksQ0FBQ2tVLGVBQWU7UUFDaEMsSUFBSSxDQUFDNkssU0FBUyxHQUFHLElBQUksQ0FBQ0MsYUFBYSxDQUFDRjtJQUN0QztJQUVBemEsVUFBVTtRQUNSLE9BQU8sSUFBSSxDQUFDckUsSUFBSTtJQUNsQjtJQUVBakssS0FBS2hDLEdBQUcsRUFBRTtRQUNSLElBQUksRUFDRmdyQixTQUFTLEVBQ1YsR0FBRyxJQUFJO1FBRVIsSUFBSWhyQixLQUFLO1lBQ1BBLElBQUl1SSxTQUFTO1FBQ2Y7UUFFQXlpQixVQUFVdm5CLE9BQU8sQ0FBQzlLLENBQUFBO1lBQ2hCLElBQUksRUFDRmlNLElBQUksRUFDSjNDLE1BQU0sRUFDUCxHQUFHdEo7WUFFSixPQUFRaU07Z0JBQ04sS0FBS3lSLFdBQVd3RSxPQUFPO29CQUNyQixJQUFJN2EsS0FBSzt3QkFDUEEsSUFBSXlJLE1BQU0sQ0FBQ3hHLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFO29CQUNqQztvQkFFQTtnQkFFRixLQUFLb1UsV0FBV3NFLE9BQU87b0JBQ3JCLElBQUkzYSxLQUFLO3dCQUNQQSxJQUFJd0ksTUFBTSxDQUFDdkcsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUU7b0JBQ2pDO29CQUVBO2dCQUVGLEtBQUtvVSxXQUFXaUIsUUFBUTtvQkFDdEIsSUFBSXRYLEtBQUs7d0JBQ1BBLElBQUkrYyxhQUFhLENBQUM5YSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRTtvQkFDcEY7b0JBRUE7Z0JBRUYsS0FBS29VLFdBQVdtQixPQUFPO29CQUNyQixJQUFJeFgsS0FBSzt3QkFDUEEsSUFBSWdkLGdCQUFnQixDQUFDL2EsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUU7b0JBQ2pFO29CQUVBO2dCQUVGLEtBQUtvVSxXQUFXa0YsR0FBRztvQkFDakI7d0JBQ0UsSUFBSSxDQUFDM08sSUFBSUMsSUFBSTZXLElBQUlDLElBQUl1SCxPQUFPQyxRQUFRQyxLQUFLQyxHQUFHLEdBQUdwcEI7d0JBQy9DLElBQUlnYyxJQUFJeUYsS0FBS0MsS0FBS0QsS0FBS0M7d0JBQ3ZCLElBQUloYyxTQUFTK2IsS0FBS0MsS0FBSyxJQUFJRCxLQUFLQzt3QkFDaEMsSUFBSS9iLFNBQVM4YixLQUFLQyxLQUFLQSxLQUFLRCxLQUFLO3dCQUVqQyxJQUFJMWpCLEtBQUs7NEJBQ1BBLElBQUlvSSxTQUFTLENBQUN3RSxJQUFJQzs0QkFDbEI3TSxJQUFJdU0sTUFBTSxDQUFDNmU7NEJBQ1hwckIsSUFBSThCLEtBQUssQ0FBQzZGLFFBQVFDOzRCQUNsQjVILElBQUlvZSxHQUFHLENBQUMsR0FBRyxHQUFHSCxHQUFHaU4sT0FBT0EsUUFBUUMsUUFBUTlNLFFBQVEsSUFBSWdOOzRCQUNwRHJyQixJQUFJOEIsS0FBSyxDQUFDLElBQUk2RixRQUFRLElBQUlDOzRCQUMxQjVILElBQUl1TSxNQUFNLENBQUMsQ0FBQzZlOzRCQUNacHJCLElBQUlvSSxTQUFTLENBQUMsQ0FBQ3dFLElBQUksQ0FBQ0M7d0JBQ3RCO3dCQUVBO29CQUNGO2dCQUVGLEtBQUt3SixXQUFXb0YsVUFBVTtvQkFDeEIsSUFBSXpiLEtBQUs7d0JBQ1BBLElBQUkwSSxTQUFTO29CQUNmO29CQUVBO1lBQ0o7UUFDRjtJQUNGO0lBRUF5SSxlQUFlblIsR0FBRyxFQUFFO1FBQ2xCLElBQUksQ0FBQ3NyQixXQUFXLENBQUN0ckI7UUFDakJBLElBQUk4USxJQUFJO1FBQ1IsSUFBSXlhLGlCQUFpQixJQUFJLENBQUM1bkIsTUFBTSxDQUFDdUcsUUFBUSxDQUFDLG1CQUFtQjVNLFNBQVM7UUFDdEUsSUFBSWtXLFdBQVcsSUFBSSxDQUFDK0wsV0FBVztRQUMvQixJQUFJLEVBQ0ZvTCxTQUFTLEVBQ1YsR0FBRyxJQUFJO1FBQ1IsSUFBSTVPLE9BQU8vYixJQUFJNFksU0FBUztRQUV4QixJQUFJMlMsbUJBQW1CLGFBQWE7WUFDbEN2ckIsSUFBSXVJLFNBQVM7UUFDZjtRQUVBb2lCLFVBQVVsbkIsT0FBTyxDQUFDLENBQUNtYyxPQUFPbGY7WUFDeEIsSUFBSSxFQUNGb1UsRUFBRSxFQUNGQyxFQUFFLEVBQ0Z5VyxRQUFRLEVBQ1J2ZixNQUFNd2YsV0FBVyxFQUNsQixHQUFHN0w7WUFDSjVmLElBQUk4USxJQUFJO1lBQ1I5USxJQUFJb0ksU0FBUyxDQUFDME0sR0FBR3RULENBQUMsRUFBRXNULEdBQUdyVCxDQUFDO1lBQ3hCekIsSUFBSXVNLE1BQU0sQ0FBQ2lmO1lBRVgsSUFBSXhyQixJQUFJNFksU0FBUyxFQUFFO2dCQUNqQjVZLElBQUlpaEIsUUFBUSxDQUFDd0ssYUFBYSxHQUFHO1lBQy9CO1lBRUEsSUFBSXpyQixJQUFJdUcsV0FBVyxFQUFFO2dCQUNuQnZHLElBQUlraEIsVUFBVSxDQUFDdUssYUFBYSxHQUFHO1lBQ2pDO1lBRUF6ckIsSUFBSXFSLE9BQU87WUFFWCxJQUFJa2EsbUJBQW1CLGFBQWE7Z0JBQ2xDLElBQUk3cUIsTUFBTSxHQUFHO29CQUNYVixJQUFJd0ksTUFBTSxDQUFDc00sR0FBR3RULENBQUMsRUFBRXNULEdBQUdyVCxDQUFDLEdBQUcrUixXQUFXO2dCQUNyQztnQkFFQXhULElBQUl5SSxNQUFNLENBQUNzTSxHQUFHdlQsQ0FBQyxFQUFFdVQsR0FBR3RULENBQUMsR0FBRytSLFdBQVc7WUFDckMsRUFBRSw0REFBNEQ7UUFDOUQsRUFBRTtRQUNGLG1CQUFtQjtRQUNuQixhQUFhO1FBQ2IsNEJBQTRCO1FBQzVCLE9BQU87UUFDUCw4QkFBOEI7UUFDOUIsMEJBQTBCO1FBQzFCLDBCQUEwQjtRQUMxQixnQkFBZ0I7UUFDaEIsbUJBQW1CO1FBRXJCO1FBRUEsSUFBSStYLG1CQUFtQixhQUFhO1lBQ2xDdnJCLElBQUltWixTQUFTLEdBQUczRixXQUFXO1lBQzNCeFQsSUFBSXVHLFdBQVcsR0FBR3dWO1lBQ2xCL2IsSUFBSWljLE1BQU07WUFDVmpjLElBQUkwSSxTQUFTO1FBQ2Y7UUFFQTFJLElBQUlxUixPQUFPO0lBQ2I7SUFFQXFhLHFCQUFxQjtRQUNuQixJQUFJQyxNQUFNcjBCLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHO1FBQzlFLE9BQU8sSUFBSSxDQUFDc3pCLGtCQUFrQixDQUFDZSxJQUFJLElBQUk7SUFDekM7SUFFQUMscUJBQXFCNXJCLEdBQUcsRUFBRTZyQixNQUFNLEVBQUVDLGFBQWEsRUFBRUMsYUFBYSxFQUFFQyxZQUFZLEVBQUVDLFdBQVcsRUFBRUMsRUFBRSxFQUFFeGUsQ0FBQyxFQUFFeWUsS0FBSyxFQUFFO1FBQ3ZHLElBQUl0UyxTQUFTb1M7UUFDYixJQUFJRyxhQUFhLElBQUksQ0FBQzNNLFdBQVcsQ0FBQ3pmLEtBQUswTjtRQUV2QyxJQUFJQSxNQUFNLE9BQU9tZSxXQUFXLGFBQWFDLGdCQUFnQkMsZUFBZTtZQUN0RUssY0FBYyxDQUFDTCxnQkFBZ0JELGFBQVksSUFBS0U7UUFDbEQ7UUFFQSxJQUFJRyxRQUFRLENBQUMsR0FBRztZQUNkdFMsVUFBVSxJQUFJLENBQUM2UixrQkFBa0IsQ0FBQ1M7UUFDcEM7UUFFQSxJQUFJRSxhQUFhLElBQUksQ0FBQzVCLFVBQVUsR0FBRztRQUNuQyxJQUFJM1YsS0FBSyxJQUFJLENBQUN3WCx5QkFBeUIsQ0FBQ3pTLFFBQVF3UyxZQUFZO1FBQzVELElBQUl0WCxLQUFLLElBQUksQ0FBQ3VYLHlCQUF5QixDQUFDelMsU0FBU3VTLFlBQVlDLFlBQVk7UUFDekUsSUFBSUUsVUFBVTtZQUNaelg7WUFDQUM7UUFDRjtRQUNBLElBQUl5VyxXQUFXMVcsTUFBTUMsS0FBS25hLEtBQUt3SCxLQUFLLENBQUMyUyxHQUFHdFQsQ0FBQyxHQUFHcVQsR0FBR3JULENBQUMsRUFBRXNULEdBQUd2VCxDQUFDLEdBQUdzVCxHQUFHdFQsQ0FBQyxJQUFJO1FBRWpFLElBQUkwcUIsSUFBSTtZQUNOLElBQUlNLE1BQU01eEIsS0FBS3NTLEdBQUcsQ0FBQ3RTLEtBQUs2RSxFQUFFLEdBQUcsSUFBSStyQixZQUFZVTtZQUM3QyxJQUFJTyxNQUFNN3hCLEtBQUtzUyxHQUFHLENBQUMsQ0FBQ3NlLFlBQVlVO1lBQ2hDSyxRQUFRelgsRUFBRSxHQUFHbVYsZ0JBQWdCQSxnQkFBZ0IsQ0FBQyxHQUFHblYsS0FBSyxDQUFDLEdBQUc7Z0JBQ3hEdFQsR0FBR3NULEdBQUd0VCxDQUFDLEdBQUdnckI7Z0JBQ1YvcUIsR0FBR3FULEdBQUdyVCxDQUFDLEdBQUdnckI7WUFDWjtZQUNBRixRQUFReFgsRUFBRSxHQUFHa1YsZ0JBQWdCQSxnQkFBZ0IsQ0FBQyxHQUFHbFYsS0FBSyxDQUFDLEdBQUc7Z0JBQ3hEdlQsR0FBR3VULEdBQUd2VCxDQUFDLEdBQUdnckI7Z0JBQ1YvcUIsR0FBR3NULEdBQUd0VCxDQUFDLEdBQUdnckI7WUFDWjtRQUNGO1FBRUE1UyxVQUFVdVM7UUFDVixPQUFPO1lBQ0x2UztZQUNBMFM7WUFDQWY7UUFDRjtJQUNGO0lBRUEvTCxZQUFZemYsR0FBRyxFQUFFaU0sSUFBSSxFQUFFO1FBQ3JCLElBQUksRUFDRjRlLGFBQWEsRUFDZCxHQUFHLElBQUk7UUFDUixJQUFJNUksYUFBYWhXLFFBQVEsSUFBSSxDQUFDcUUsT0FBTztRQUVyQyxJQUFJdWEsY0FBYzZCLEdBQUcsQ0FBQ3pLLGFBQWE7WUFDakMsT0FBTzRJLGNBQWM4QixHQUFHLENBQUMxSztRQUMzQjtRQUVBLElBQUlGLFVBQVUsSUFBSSxDQUFDQyxpQkFBaUIsQ0FBQ2hpQixLQUFLaWlCO1FBQzFDNEksY0FBY2hYLEdBQUcsQ0FBQ29PLFlBQVlGO1FBQzlCLE9BQU9BO0lBQ1Q7SUFDQSxpR0FBaUc7SUFDakcsZ0VBQWdFO0lBR2hFdUosWUFBWXRyQixHQUFHLEVBQUU7UUFDZixJQUFJLElBQUksQ0FBQzJxQixTQUFTLEVBQUU7WUFDbEI7UUFDRjtRQUVBLElBQUluSyxhQUFhLElBQUksQ0FBQ2xRLE9BQU87UUFDN0IsSUFBSXNjLFFBQVFwTSxXQUFXcGpCLEtBQUssQ0FBQztRQUM3QixJQUFJNHVCLGVBQWV4TCxXQUFXcGpCLEtBQUssQ0FBQyxLQUFLN0YsTUFBTSxHQUFHO1FBQ2xELElBQUl3cEIsS0FBSyxJQUFJLENBQUNwZCxNQUFNLENBQUN2RCxZQUFZLENBQUMsTUFBTWhELEtBQUssR0FBRzFELEdBQUcsQ0FBQzBNLENBQUFBLElBQUtBLEVBQUV2SCxTQUFTLENBQUM7UUFDckUsSUFBSXF0QixLQUFLLElBQUksQ0FBQ3ZvQixNQUFNLENBQUN2RCxZQUFZLENBQUMsTUFBTXZCLFNBQVMsQ0FBQztRQUNsRCxJQUFJZ3RCLFNBQVMsSUFBSSxDQUFDbG9CLE1BQU0sQ0FBQ3VHLFFBQVEsQ0FBQyxlQUFlNU0sU0FBUyxDQUFDO1FBQzNELElBQUl1dkIsY0FBYyxJQUFJLENBQUMzaUIsUUFBUSxDQUFDO1FBQ2hDLElBQUk0aUIsZ0JBQWdCLElBQUksQ0FBQ25wQixNQUFNLENBQUN1RyxRQUFRLENBQUM7UUFDekMsSUFBSTZpQixnQkFBZ0I7UUFFcEIsSUFBSSxDQUFDRixZQUFZcnZCLFFBQVEsTUFBTXF2QixZQUFZM3VCLFFBQVEsT0FBTyxXQUFXO1lBQ25FNnVCLGdCQUFnQkQsY0FBY2p1QixTQUFTO1FBQ3pDLE9BQU8sSUFBSWd1QixZQUFZcnZCLFFBQVEsSUFBSTtZQUNqQyxJQUFJcXZCLFlBQVkzdUIsUUFBUSxPQUFPLGFBQWEydUIsWUFBWTN1QixRQUFRLE9BQU8sU0FBUztnQkFDOUU2dUIsZ0JBQWdCRixZQUFZaHVCLFNBQVM7WUFDdkM7UUFDRixFQUFFLDRCQUE0QjtRQUc5QixJQUFJK3JCLHFCQUFxQixFQUFFO1FBQzNCLElBQUlvQyxVQUFVeE0sV0FBV2pwQixNQUFNO1FBQy9CLElBQUksQ0FBQ3F6QixrQkFBa0IsR0FBR0E7UUFFMUIsSUFBSyxJQUFJbHFCLElBQUksR0FBR0EsSUFBSXNzQixTQUFTdHNCLElBQUs7WUFDaENrcUIsbUJBQW1CMXBCLElBQUksQ0FBQyxPQUFPNmYsRUFBRSxDQUFDcmdCLEVBQUUsS0FBSyxjQUFjcWdCLEVBQUUsQ0FBQ3JnQixFQUFFLEdBQUdxc0I7UUFDakU7UUFFQSxJQUFJRSxRQUFRckMsbUJBQW1COWdCLE1BQU0sQ0FBQyxDQUFDb2pCLEtBQUtDLEtBQUt6c0IsSUFBTUEsTUFBTSxJQUFJLElBQUl3c0IsTUFBTUMsT0FBTyxHQUFHO1FBQ3JGLElBQUkzQyxZQUFZLElBQUksQ0FBQy9LLFdBQVcsQ0FBQ3pmO1FBQ2pDLElBQUk4ckIsZ0JBQWdCbHhCLEtBQUswRSxHQUFHLENBQUNrckIsWUFBWXlDLE9BQU87UUFDaEQsSUFBSSxDQUFDekMsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNDLFVBQVUsR0FBRyxJQUFJLENBQUNsTCxXQUFXO1FBQ2xDLElBQUksQ0FBQ29MLFNBQVMsR0FBRyxFQUFFO1FBQ25CLElBQUlvQixnQkFBZ0IsSUFBSSxDQUFDcUIsYUFBYTtRQUN0QyxJQUFJQyxjQUFjLElBQUksQ0FBQ25qQixRQUFRLENBQUMsZUFBZTlMLFNBQVMsQ0FBQyxLQUFLMnRCO1FBQzlELElBQUlsUyxTQUFTO1FBRWIsSUFBSWdTLFdBQVcsWUFBWUEsV0FBVyxVQUFVO1lBQzlDaFMsU0FBUyxDQUFDaVMsZ0JBQWdCO1FBQzVCO1FBRUEsSUFBSUQsV0FBVyxTQUFTQSxXQUFXLFNBQVM7WUFDMUNoUyxTQUFTLENBQUNpUztRQUNaO1FBRUFqUyxVQUFVd1Q7UUFDVlQsTUFBTW5wQixPQUFPLENBQUMsQ0FBQ2tjLE1BQU1qZjtZQUNuQiw4RUFBOEU7WUFDOUUsSUFBSSxFQUNGbVosUUFBUXlULFVBQVUsRUFDbEJmLE9BQU8sRUFDUGYsUUFBUSxFQUNULEdBQUcsSUFBSSxDQUFDSSxvQkFBb0IsQ0FBQzVyQixLQUFLNnJCLFFBQVFDLGVBQWVDLGVBQWVDLGNBQWNuUyxRQUFRcVMsSUFBSXZNLE1BQU1qZjtZQUN6R21aLFNBQVN5VDtZQUVULElBQUksQ0FBQ2YsUUFBUXpYLEVBQUUsSUFBSSxDQUFDeVgsUUFBUXhYLEVBQUUsRUFBRTtnQkFDOUI7WUFDRixFQUFFLG9DQUFvQztZQUN0QyxpQkFBaUI7WUFDakIsaUJBQWlCO1lBQ2pCLGlCQUFpQjtZQUNqQixnQkFBZ0I7WUFDaEIsS0FBSztZQUNMLDZHQUE2RztZQUM3Ryw0RkFBNEY7WUFDNUYsa0VBQWtFO1lBQ2xFLGtCQUFrQjtZQUNsQix3Q0FBd0M7WUFDeEMsd0NBQXdDO1lBQ3hDLHVCQUF1QjtZQUN2QiwwREFBMEQ7WUFDMUQsS0FBSztZQUdMLElBQUksQ0FBQzRWLFNBQVMsQ0FBQ3pwQixJQUFJLENBQUM7Z0JBQ2xCLDBCQUEwQjtnQkFDMUIsMEJBQTBCO2dCQUMxQitLLE1BQU0yZ0IsS0FBSyxDQUFDbHNCLEVBQUU7Z0JBQ2RvVSxJQUFJeVgsUUFBUXpYLEVBQUU7Z0JBQ2RDLElBQUl3WCxRQUFReFgsRUFBRTtnQkFDZHlXO1lBQ0Y7UUFDRjtJQUNGO0lBRUFQLGNBQWNqcEIsSUFBSSxFQUFFO1FBQ2xCLElBQUksQ0FBQzBvQixVQUFVLEdBQUcsQ0FBQyxHQUFHLG9CQUFvQjtRQUUxQyxJQUFJLENBQUMxb0IsTUFBTTtZQUNULE9BQU8sRUFBRTtRQUNYO1FBRUEsSUFBSXVyQixlQUFlLEVBQUU7UUFDckIsSUFBSSxFQUNGN1MsVUFBVSxFQUNYLEdBQUcxWTtRQUNKMFksV0FBVzlELEtBQUssSUFBSSxpQ0FBaUM7UUFFckQsTUFBTyxDQUFDOEQsV0FBVzdELEtBQUssR0FBSTtZQUMxQixJQUFJLEVBQ0ZOLE9BQU8sRUFDUixHQUFHbUU7WUFDSixJQUFJOFMsU0FBU2pYLFVBQVVBLFFBQVEvVSxDQUFDLEdBQUc7WUFDbkMsSUFBSWlzQixTQUFTbFgsVUFBVUEsUUFBUTlVLENBQUMsR0FBRztZQUNuQyxJQUFJK1UsVUFBVWtFLFdBQVc1RCxJQUFJO1lBQzdCLElBQUk0VyxrQkFBa0JsWCxRQUFRNVIsSUFBSTtZQUNsQyxJQUFJM0MsU0FBUyxFQUFFO1lBRWYsT0FBUXVVLFFBQVE1UixJQUFJO2dCQUNsQixLQUFLeVIsV0FBV3NFLE9BQU87b0JBQ3JCLElBQUksQ0FBQ0MsS0FBSyxDQUFDRixZQUFZelk7b0JBQ3ZCO2dCQUVGLEtBQUtvVSxXQUFXd0UsT0FBTztvQkFDckI2UyxrQkFBa0IsSUFBSSxDQUFDNVMsS0FBSyxDQUFDSixZQUFZelk7b0JBQ3pDO2dCQUVGLEtBQUtvVSxXQUFXMEUsYUFBYTtvQkFDM0IyUyxrQkFBa0IsSUFBSSxDQUFDMVMsS0FBSyxDQUFDTixZQUFZelk7b0JBQ3pDO2dCQUVGLEtBQUtvVSxXQUFXNEUsWUFBWTtvQkFDMUJ5UyxrQkFBa0IsSUFBSSxDQUFDeFMsS0FBSyxDQUFDUixZQUFZelk7b0JBQ3pDO2dCQUVGLEtBQUtvVSxXQUFXaUIsUUFBUTtvQkFDdEIsSUFBSSxDQUFDNkQsS0FBSyxDQUFDVCxZQUFZelk7b0JBQ3ZCO2dCQUVGLEtBQUtvVSxXQUFXa0IsZUFBZTtvQkFDN0JtVyxrQkFBa0IsSUFBSSxDQUFDdFMsS0FBSyxDQUFDVixZQUFZelk7b0JBQ3pDO2dCQUVGLEtBQUtvVSxXQUFXbUIsT0FBTztvQkFDckIsSUFBSSxDQUFDNkQsS0FBSyxDQUFDWCxZQUFZelk7b0JBQ3ZCO2dCQUVGLEtBQUtvVSxXQUFXb0IsY0FBYztvQkFDNUJpVyxrQkFBa0IsSUFBSSxDQUFDcFMsS0FBSyxDQUFDWixZQUFZelk7b0JBQ3pDO2dCQUVGLEtBQUtvVSxXQUFXa0YsR0FBRztvQkFDakJ0WixTQUFTLElBQUksQ0FBQ3VaLEtBQUssQ0FBQ2Q7b0JBQ3BCO2dCQUVGLEtBQUtyRSxXQUFXb0YsVUFBVTtvQkFDeEJoQixZQUFZaUIsS0FBSyxDQUFDaEI7b0JBQ2xCO1lBQ0o7WUFFQSxJQUFJbEUsUUFBUTVSLElBQUksS0FBS3lSLFdBQVdvRixVQUFVLEVBQUU7Z0JBQzFDOFIsYUFBYXJzQixJQUFJLENBQUM7b0JBQ2hCMEQsTUFBTThvQjtvQkFDTnpyQjtvQkFDQWdCLE9BQU87d0JBQ0x6QixHQUFHZ3NCO3dCQUNIL3JCLEdBQUdnc0I7b0JBQ0w7b0JBQ0EvQyxZQUFZLElBQUksQ0FBQ2lELFVBQVUsQ0FBQ0gsUUFBUUMsUUFBUUMsaUJBQWlCenJCO2dCQUMvRDtZQUNGLE9BQU87Z0JBQ0xzckIsYUFBYXJzQixJQUFJLENBQUM7b0JBQ2hCMEQsTUFBTXlSLFdBQVdvRixVQUFVO29CQUMzQnhaLFFBQVEsRUFBRTtvQkFDVnlvQixZQUFZO2dCQUNkO1lBQ0Y7UUFDRjtRQUVBLE9BQU82QztJQUNUO0lBRUEzUyxNQUFNRixVQUFVLEVBQUV6WSxNQUFNLEVBQUU7UUFDeEIsSUFBSSxFQUNGVCxDQUFDLEVBQ0RDLENBQUMsRUFDRixHQUFHZ1osWUFBWUcsS0FBSyxDQUFDRixZQUFZL1ksS0FBSztRQUN2Q00sT0FBT2YsSUFBSSxDQUFDTSxHQUFHQztJQUNqQjtJQUVBcVosTUFBTUosVUFBVSxFQUFFelksTUFBTSxFQUFFO1FBQ3hCLElBQUksRUFDRlQsQ0FBQyxFQUNEQyxDQUFDLEVBQ0YsR0FBR2daLFlBQVlLLEtBQUssQ0FBQ0osWUFBWS9ZLEtBQUs7UUFDdkNNLE9BQU9mLElBQUksQ0FBQ00sR0FBR0M7UUFDZixPQUFPNFUsV0FBV3dFLE9BQU87SUFDM0I7SUFFQUcsTUFBTU4sVUFBVSxFQUFFelksTUFBTSxFQUFFO1FBQ3hCLElBQUksRUFDRlQsQ0FBQyxFQUNEQyxDQUFDLEVBQ0YsR0FBR2daLFlBQVlPLEtBQUssQ0FBQ04sWUFBWS9ZLEtBQUs7UUFDdkNNLE9BQU9mLElBQUksQ0FBQ00sR0FBR0M7UUFDZixPQUFPNFUsV0FBV3dFLE9BQU87SUFDM0I7SUFFQUssTUFBTVIsVUFBVSxFQUFFelksTUFBTSxFQUFFO1FBQ3hCLElBQUksRUFDRlQsQ0FBQyxFQUNEQyxDQUFDLEVBQ0YsR0FBR2daLFlBQVlTLEtBQUssQ0FBQ1IsWUFBWS9ZLEtBQUs7UUFDdkNNLE9BQU9mLElBQUksQ0FBQ00sR0FBR0M7UUFDZixPQUFPNFUsV0FBV3dFLE9BQU87SUFDM0I7SUFFQU0sTUFBTVQsVUFBVSxFQUFFelksTUFBTSxFQUFFO1FBQ3hCLElBQUksRUFDRk4sS0FBSyxFQUNMa2IsWUFBWSxFQUNaQyxZQUFZLEVBQ2IsR0FBR3JDLFlBQVlVLEtBQUssQ0FBQ1Q7UUFDdEJ6WSxPQUFPZixJQUFJLENBQUNTLE1BQU1ILENBQUMsRUFBRUcsTUFBTUYsQ0FBQyxFQUFFb2IsYUFBYXJiLENBQUMsRUFBRXFiLGFBQWFwYixDQUFDLEVBQUVxYixhQUFhdGIsQ0FBQyxFQUFFc2IsYUFBYXJiLENBQUM7SUFDOUY7SUFFQTJaLE1BQU1WLFVBQVUsRUFBRXpZLE1BQU0sRUFBRTtRQUN4QixJQUFJLEVBQ0ZOLEtBQUssRUFDTGtiLFlBQVksRUFDWkMsWUFBWSxFQUNiLEdBQUdyQyxZQUFZVyxLQUFLLENBQUNWO1FBQ3RCelksT0FBT2YsSUFBSSxDQUFDUyxNQUFNSCxDQUFDLEVBQUVHLE1BQU1GLENBQUMsRUFBRW9iLGFBQWFyYixDQUFDLEVBQUVxYixhQUFhcGIsQ0FBQyxFQUFFcWIsYUFBYXRiLENBQUMsRUFBRXNiLGFBQWFyYixDQUFDO1FBQzVGLE9BQU80VSxXQUFXaUIsUUFBUTtJQUM1QjtJQUVBK0QsTUFBTVgsVUFBVSxFQUFFelksTUFBTSxFQUFFO1FBQ3hCLElBQUksRUFDRjRhLFlBQVksRUFDWkMsWUFBWSxFQUNiLEdBQUdyQyxZQUFZWSxLQUFLLENBQUNYO1FBQ3RCelksT0FBT2YsSUFBSSxDQUFDMmIsYUFBYXJiLENBQUMsRUFBRXFiLGFBQWFwYixDQUFDLEVBQUVxYixhQUFhdGIsQ0FBQyxFQUFFc2IsYUFBYXJiLENBQUM7SUFDNUU7SUFFQTZaLE1BQU1aLFVBQVUsRUFBRXpZLE1BQU0sRUFBRTtRQUN4QixJQUFJLEVBQ0Y0YSxZQUFZLEVBQ1pDLFlBQVksRUFDYixHQUFHckMsWUFBWWEsS0FBSyxDQUFDWjtRQUN0QnpZLE9BQU9mLElBQUksQ0FBQzJiLGFBQWFyYixDQUFDLEVBQUVxYixhQUFhcGIsQ0FBQyxFQUFFcWIsYUFBYXRiLENBQUMsRUFBRXNiLGFBQWFyYixDQUFDO1FBQzFFLE9BQU80VSxXQUFXbUIsT0FBTztJQUMzQjtJQUVBZ0UsTUFBTWQsVUFBVSxFQUFFO1FBQ2hCLElBQUksRUFDRnVDLEVBQUUsRUFDRkMsRUFBRSxFQUNGRyxTQUFTLEVBQ1RDLGFBQWEsRUFDYkssS0FBSyxFQUNMQyxFQUFFLEVBQ0ZDLEVBQUUsRUFDSCxHQUFHcEQsWUFBWWUsS0FBSyxDQUFDZDtRQUV0QixJQUFJMkMsY0FBYyxLQUFLUSxLQUFLLEdBQUc7WUFDN0JBLE1BQU0sSUFBSWpqQixLQUFLNkUsRUFBRTtRQUNuQjtRQUVBLElBQUk0ZCxjQUFjLEtBQUtRLEtBQUssR0FBRztZQUM3QkEsTUFBTSxJQUFJampCLEtBQUs2RSxFQUFFO1FBQ25CO1FBRUEsT0FBTztZQUFDa2UsTUFBTW5jLENBQUM7WUFBRW1jLE1BQU1sYyxDQUFDO1lBQUV3YjtZQUFJQztZQUFJVTtZQUFJQztZQUFJUDtZQUFlRDtTQUFVO0lBQ3JFO0lBRUFzUSxXQUFXbnNCLENBQUMsRUFBRUMsQ0FBQyxFQUFFbXNCLFdBQVcsRUFBRTNyQixNQUFNLEVBQUU7UUFDcEMsSUFBSXpCLE1BQU07UUFDVixJQUFJdVUsS0FBSztRQUNULElBQUlDLEtBQUs7UUFDVCxJQUFJelksSUFBSTtRQUVSLE9BQVFxeEI7WUFDTixLQUFLdlgsV0FBV3dFLE9BQU87Z0JBQ3JCLE9BQU8sSUFBSSxDQUFDZ1QsYUFBYSxDQUFDcnNCLEdBQUdDLEdBQUdRLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFO1lBRXRELEtBQUtvVSxXQUFXaUIsUUFBUTtnQkFDdEIsd0RBQXdEO2dCQUN4RDlXLE1BQU07Z0JBQ051VSxLQUFLLElBQUksQ0FBQytZLHFCQUFxQixDQUFDLEdBQUd0c0IsR0FBR0MsR0FBR1EsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUU7Z0JBRXpHLElBQUsxRixJQUFJLE1BQU1BLEtBQUssR0FBR0EsS0FBSyxLQUFNO29CQUNoQ3lZLEtBQUssSUFBSSxDQUFDOFkscUJBQXFCLENBQUN2eEIsR0FBR2lGLEdBQUdDLEdBQUdRLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFO29CQUN6R3pCLE9BQU8sSUFBSSxDQUFDcXRCLGFBQWEsQ0FBQzlZLEdBQUd2VCxDQUFDLEVBQUV1VCxHQUFHdFQsQ0FBQyxFQUFFdVQsR0FBR3hULENBQUMsRUFBRXdULEdBQUd2VCxDQUFDO29CQUNoRHNULEtBQUtDO2dCQUNQO2dCQUVBLE9BQU94VTtZQUVULEtBQUs2VixXQUFXbUIsT0FBTztnQkFDckIsd0RBQXdEO2dCQUN4RGhYLE1BQU07Z0JBQ051VSxLQUFLLElBQUksQ0FBQ2daLHlCQUF5QixDQUFDLEdBQUd2c0IsR0FBR0MsR0FBR1EsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUU7Z0JBRXZGLElBQUsxRixJQUFJLE1BQU1BLEtBQUssR0FBR0EsS0FBSyxLQUFNO29CQUNoQ3lZLEtBQUssSUFBSSxDQUFDK1kseUJBQXlCLENBQUN4eEIsR0FBR2lGLEdBQUdDLEdBQUdRLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFO29CQUN2RnpCLE9BQU8sSUFBSSxDQUFDcXRCLGFBQWEsQ0FBQzlZLEdBQUd2VCxDQUFDLEVBQUV1VCxHQUFHdFQsQ0FBQyxFQUFFdVQsR0FBR3hULENBQUMsRUFBRXdULEdBQUd2VCxDQUFDO29CQUNoRHNULEtBQUtDO2dCQUNQO2dCQUVBLE9BQU94VTtZQUVULEtBQUs2VixXQUFXa0YsR0FBRztnQkFDakI7b0JBQ0Usb0RBQW9EO29CQUNwRC9hLE1BQU07b0JBQ04sSUFBSXlDLFFBQVFoQixNQUFNLENBQUMsRUFBRSxFQUFFLFlBQVk7b0JBRW5DLElBQUlrcEIsU0FBU2xwQixNQUFNLENBQUMsRUFBRSxFQUFFLGFBQWE7b0JBRXJDLElBQUkrckIsTUFBTS9yQixNQUFNLENBQUMsRUFBRSxHQUFHa3BCO29CQUN0QixJQUFJOEMsTUFBTXJ6QixLQUFLNkUsRUFBRSxHQUFHLE9BQU8sc0JBQXNCO29CQUVqRCxJQUFJN0UsS0FBS3N6QixHQUFHLENBQUNqckIsUUFBUStxQixPQUFPQyxLQUFLO3dCQUMvQkEsTUFBTXJ6QixLQUFLc3pCLEdBQUcsQ0FBQ2pyQixRQUFRK3FCO29CQUN6QixFQUFFLHFHQUFxRztvQkFHdkdqWixLQUFLLElBQUksQ0FBQ29aLHVCQUF1QixDQUFDbHNCLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVnQixPQUFPO29CQUVyRixJQUFJa29CLFNBQVMsR0FBRzt3QkFDZCxZQUFZO3dCQUNaLElBQUs1dUIsSUFBSTBHLFFBQVFnckIsS0FBSzF4QixJQUFJeXhCLEtBQUt6eEIsS0FBSzB4QixJQUFLOzRCQUN2Q2paLEtBQUssSUFBSSxDQUFDbVosdUJBQXVCLENBQUNsc0IsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRTFGLEdBQUc7NEJBQ2pGaUUsT0FBTyxJQUFJLENBQUNxdEIsYUFBYSxDQUFDOVksR0FBR3ZULENBQUMsRUFBRXVULEdBQUd0VCxDQUFDLEVBQUV1VCxHQUFHeFQsQ0FBQyxFQUFFd1QsR0FBR3ZULENBQUM7NEJBQ2hEc1QsS0FBS0M7d0JBQ1A7b0JBQ0YsT0FBTzt3QkFDTCxvQkFBb0I7d0JBQ3BCLElBQUt6WSxJQUFJMEcsUUFBUWdyQixLQUFLMXhCLElBQUl5eEIsS0FBS3p4QixLQUFLMHhCLElBQUs7NEJBQ3ZDalosS0FBSyxJQUFJLENBQUNtWix1QkFBdUIsQ0FBQ2xzQixNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFMUYsR0FBRzs0QkFDakZpRSxPQUFPLElBQUksQ0FBQ3F0QixhQUFhLENBQUM5WSxHQUFHdlQsQ0FBQyxFQUFFdVQsR0FBR3RULENBQUMsRUFBRXVULEdBQUd4VCxDQUFDLEVBQUV3VCxHQUFHdlQsQ0FBQzs0QkFDaERzVCxLQUFLQzt3QkFDUDtvQkFDRjtvQkFFQUEsS0FBSyxJQUFJLENBQUNtWix1QkFBdUIsQ0FBQ2xzQixNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFK3JCLEtBQUs7b0JBQ25GeHRCLE9BQU8sSUFBSSxDQUFDcXRCLGFBQWEsQ0FBQzlZLEdBQUd2VCxDQUFDLEVBQUV1VCxHQUFHdFQsQ0FBQyxFQUFFdVQsR0FBR3hULENBQUMsRUFBRXdULEdBQUd2VCxDQUFDO29CQUNoRCxPQUFPakI7Z0JBQ1Q7UUFDSjtRQUVBLE9BQU87SUFDVDtJQUVBNHRCLGVBQWVDLElBQUksRUFBRTNZLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRTtRQUN2QyxJQUFJeVksUUFBUWgzQixVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBR29lO1FBQ2hGLElBQUk2WSxRQUFRajNCLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHcWU7UUFDaEYsSUFBSTZZLElBQUksQ0FBQzNZLE1BQU1GLEdBQUUsSUFBTUMsQ0FBQUEsTUFBTUYsTUFBTTdaLFdBQVU7UUFDN0MsSUFBSTZILE1BQU05SSxLQUFLb0IsSUFBSSxDQUFDcXlCLE9BQU9BLE9BQVEsS0FBSUcsSUFBSUEsQ0FBQUE7UUFFM0MsSUFBSTVZLE1BQU1GLEtBQUs7WUFDYmhTLE9BQU8sQ0FBQztRQUNWO1FBRUEsSUFBSStxQixPQUFPRCxJQUFJOXFCO1FBQ2YsSUFBSWdyQixLQUFLO1FBRVQsSUFBSTlZLFFBQVFGLEtBQUs7WUFDZixnQkFBZ0I7WUFDaEJnWixLQUFLO2dCQUNIbHRCLEdBQUc4c0I7Z0JBQ0g3c0IsR0FBRzhzQixRQUFRRTtZQUNiO1FBQ0YsT0FBTyxJQUFJLENBQUNGLFFBQVE1WSxHQUFFLElBQU0yWSxDQUFBQSxRQUFRNVksTUFBTTdaLFdBQVUsTUFBTzJ5QixHQUFHO1lBQzVERSxLQUFLO2dCQUNIbHRCLEdBQUc4c0IsUUFBUTVxQjtnQkFDWGpDLEdBQUc4c0IsUUFBUUU7WUFDYjtRQUNGLE9BQU87WUFDTCxJQUFJRSxLQUFLO1lBQ1QsSUFBSUMsS0FBSztZQUNULElBQUlwdUIsTUFBTSxJQUFJLENBQUNxdEIsYUFBYSxDQUFDblksS0FBS0MsS0FBS0MsS0FBS0M7WUFFNUMsSUFBSXJWLE1BQU0zRSxhQUFhO2dCQUNyQixPQUFPO1lBQ1Q7WUFFQSxJQUFJTSxJQUFJLENBQUNteUIsUUFBUTVZLEdBQUUsSUFBTUUsQ0FBQUEsTUFBTUYsR0FBRSxJQUFLLENBQUM2WSxRQUFRNVksR0FBRSxJQUFNRSxDQUFBQSxNQUFNRixHQUFFO1lBQy9EeFosS0FBS3FFLE1BQU1BO1lBQ1htdUIsS0FBS2paLE1BQU12WixJQUFLeVosQ0FBQUEsTUFBTUYsR0FBRTtZQUN4QmtaLEtBQUtqWixNQUFNeFosSUFBSzBaLENBQUFBLE1BQU1GLEdBQUU7WUFDeEIsSUFBSWtaLFFBQVEsSUFBSSxDQUFDaEIsYUFBYSxDQUFDUyxPQUFPQyxPQUFPSSxJQUFJQztZQUNqRCxJQUFJRSxPQUFPbDBCLEtBQUtvQixJQUFJLENBQUNxeUIsT0FBT0EsT0FBT1EsUUFBUUE7WUFDM0NuckIsTUFBTTlJLEtBQUtvQixJQUFJLENBQUM4eUIsT0FBT0EsT0FBUSxLQUFJTixJQUFJQSxDQUFBQTtZQUV2QyxJQUFJNVksTUFBTUYsS0FBSztnQkFDYmhTLE9BQU8sQ0FBQztZQUNWO1lBRUErcUIsT0FBT0QsSUFBSTlxQjtZQUNYZ3JCLEtBQUs7Z0JBQ0hsdEIsR0FBR210QixLQUFLanJCO2dCQUNSakMsR0FBR210QixLQUFLSDtZQUNWO1FBQ0Y7UUFFQSxPQUFPQztJQUNUO0lBRUFLLGVBQWVDLFFBQVEsRUFBRTtRQUN2QixJQUFJQyxVQUFVLElBQUksQ0FBQzdCLGFBQWE7UUFDaEMsSUFBSThCLHVCQUF1QjtRQUMzQixJQUFJaEgsSUFBSTtRQUVSLElBQUk4RyxXQUFXLENBQUMsV0FBV0EsV0FBVyxVQUFVQyxTQUFTO1lBQ3ZELE9BQU87UUFDVDtRQUVBLElBQUksRUFDRmpFLFNBQVMsRUFDVixHQUFHLElBQUk7UUFFUixLQUFLLElBQUl4VSxXQUFXd1UsVUFBVztZQUM3QixJQUFJeFUsV0FBWUEsQ0FBQUEsUUFBUWtVLFVBQVUsR0FBRyxXQUFXd0UsdUJBQXVCMVksUUFBUWtVLFVBQVUsR0FBRyxVQUFVc0UsUUFBTyxHQUFJO2dCQUMvR0Usd0JBQXdCMVksUUFBUWtVLFVBQVU7Z0JBQzFDO1lBQ0Y7WUFFQSxJQUFJL3VCLFFBQVFxekIsV0FBV0U7WUFDdkIsSUFBSUMsV0FBVztZQUVmLE9BQVEzWSxRQUFRNVIsSUFBSTtnQkFDbEIsS0FBS3lSLFdBQVd3RSxPQUFPO29CQUNyQnFOLElBQUksSUFBSSxDQUFDa0csY0FBYyxDQUFDenlCLE9BQU82YSxRQUFRdlQsS0FBSyxDQUFDekIsQ0FBQyxFQUFFZ1YsUUFBUXZULEtBQUssQ0FBQ3hCLENBQUMsRUFBRStVLFFBQVF2VSxNQUFNLENBQUMsRUFBRSxFQUFFdVUsUUFBUXZVLE1BQU0sQ0FBQyxFQUFFLEVBQUV1VSxRQUFRdlQsS0FBSyxDQUFDekIsQ0FBQyxFQUFFZ1YsUUFBUXZULEtBQUssQ0FBQ3hCLENBQUM7b0JBQ3ZJO2dCQUVGLEtBQUs0VSxXQUFXa0YsR0FBRztvQkFDakI7d0JBQ0UsSUFBSXRZLFFBQVF1VCxRQUFRdlUsTUFBTSxDQUFDLEVBQUUsRUFBRSxZQUFZO3dCQUUzQyxJQUFJa3BCLFNBQVMzVSxRQUFRdlUsTUFBTSxDQUFDLEVBQUUsRUFBRSxhQUFhO3dCQUU3QyxJQUFJK3JCLE1BQU14WCxRQUFRdlUsTUFBTSxDQUFDLEVBQUUsR0FBR2twQjt3QkFDOUJnRSxXQUFXbHNCLFFBQVF0SCxRQUFRNmEsUUFBUWtVLFVBQVUsR0FBR1M7d0JBRWhELElBQUlBLFNBQVMsS0FBS2dFLFdBQVduQixPQUFPN0MsVUFBVSxLQUFLZ0UsV0FBV25CLEtBQUs7NEJBQ2pFO3dCQUNGO3dCQUVBOUYsSUFBSSxJQUFJLENBQUNpRyx1QkFBdUIsQ0FBQzNYLFFBQVF2VSxNQUFNLENBQUMsRUFBRSxFQUFFdVUsUUFBUXZVLE1BQU0sQ0FBQyxFQUFFLEVBQUV1VSxRQUFRdlUsTUFBTSxDQUFDLEVBQUUsRUFBRXVVLFFBQVF2VSxNQUFNLENBQUMsRUFBRSxFQUFFa3RCLFVBQVUzWSxRQUFRdlUsTUFBTSxDQUFDLEVBQUU7d0JBQ3hJO29CQUNGO2dCQUVGLEtBQUtvVSxXQUFXaUIsUUFBUTtvQkFDdEI2WCxXQUFXeHpCLFFBQVE2YSxRQUFRa1UsVUFBVTtvQkFFckMsSUFBSXlFLFdBQVcsR0FBRzt3QkFDaEJBLFdBQVc7b0JBQ2I7b0JBRUFqSCxJQUFJLElBQUksQ0FBQzRGLHFCQUFxQixDQUFDcUIsVUFBVTNZLFFBQVF2VCxLQUFLLENBQUN6QixDQUFDLEVBQUVnVixRQUFRdlQsS0FBSyxDQUFDeEIsQ0FBQyxFQUFFK1UsUUFBUXZVLE1BQU0sQ0FBQyxFQUFFLEVBQUV1VSxRQUFRdlUsTUFBTSxDQUFDLEVBQUUsRUFBRXVVLFFBQVF2VSxNQUFNLENBQUMsRUFBRSxFQUFFdVUsUUFBUXZVLE1BQU0sQ0FBQyxFQUFFLEVBQUV1VSxRQUFRdlUsTUFBTSxDQUFDLEVBQUUsRUFBRXVVLFFBQVF2VSxNQUFNLENBQUMsRUFBRTtvQkFDM0w7Z0JBRUYsS0FBS29VLFdBQVdtQixPQUFPO29CQUNyQjJYLFdBQVd4ekIsUUFBUTZhLFFBQVFrVSxVQUFVO29CQUVyQyxJQUFJeUUsV0FBVyxHQUFHO3dCQUNoQkEsV0FBVztvQkFDYjtvQkFFQWpILElBQUksSUFBSSxDQUFDNkYseUJBQXlCLENBQUNvQixVQUFVM1ksUUFBUXZULEtBQUssQ0FBQ3pCLENBQUMsRUFBRWdWLFFBQVF2VCxLQUFLLENBQUN4QixDQUFDLEVBQUUrVSxRQUFRdlUsTUFBTSxDQUFDLEVBQUUsRUFBRXVVLFFBQVF2VSxNQUFNLENBQUMsRUFBRSxFQUFFdVUsUUFBUXZVLE1BQU0sQ0FBQyxFQUFFLEVBQUV1VSxRQUFRdlUsTUFBTSxDQUFDLEVBQUU7b0JBQ3pKO1lBQ0o7WUFFQSxJQUFJaW1CLEdBQUc7Z0JBQ0wsT0FBT0E7WUFDVDtZQUVBO1FBQ0Y7UUFFQSxPQUFPO0lBQ1Q7SUFFQTJGLGNBQWMxWixFQUFFLEVBQUVHLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUU7UUFDNUIsT0FBTzVaLEtBQUtvQixJQUFJLENBQUMsQ0FBQ3VZLEtBQUtKLEVBQUMsSUFBTUksQ0FBQUEsS0FBS0osRUFBQyxJQUFLLENBQUNLLEtBQUtGLEVBQUMsSUFBTUUsQ0FBQUEsS0FBS0YsRUFBQztJQUM5RDtJQUVBOFksZ0JBQWdCO1FBQ2QsSUFBSSxJQUFJLENBQUMxQyxVQUFVLEtBQUssQ0FBQyxHQUFHO1lBQzFCLElBQUksQ0FBQ0EsVUFBVSxHQUFHLElBQUksQ0FBQ00sU0FBUyxDQUFDbGhCLE1BQU0sQ0FBQyxDQUFDdlMsUUFBUWlmLFVBQVlBLFFBQVFrVSxVQUFVLEdBQUcsSUFBSW56QixTQUFTaWYsUUFBUWtVLFVBQVUsR0FBR256QixRQUFRO1FBQzlIO1FBRUEsT0FBTyxJQUFJLENBQUNtekIsVUFBVTtJQUN4QjtJQUVBb0Qsc0JBQXNCc0IsR0FBRyxFQUFFMVosR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRXNaLEdBQUcsRUFBRUMsR0FBRyxFQUFFO1FBQ2pFLElBQUk5dEIsSUFBSTZ0QixNQUFNL3lCLElBQUk4eUIsT0FBT3RaLE1BQU10WixJQUFJNHlCLE9BQU94WixNQUFNblosSUFBSTJ5QixPQUFPMVosTUFBTWhaLElBQUkweUI7UUFDckUsSUFBSTN0QixJQUFJNnRCLE1BQU1oekIsSUFBSTh5QixPQUFPclosTUFBTXZaLElBQUk0eUIsT0FBT3ZaLE1BQU1wWixJQUFJMnlCLE9BQU96WixNQUFNalosSUFBSTB5QjtRQUNyRSxPQUFPO1lBQ0w1dEI7WUFDQUM7UUFDRjtJQUNGO0lBRUFzc0IsMEJBQTBCcUIsR0FBRyxFQUFFMVosR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRTtRQUMzRCxJQUFJdlUsSUFBSXNVLE1BQU1uWixJQUFJeXlCLE9BQU94WixNQUFNaFosSUFBSXd5QixPQUFPMVosTUFBTTdZLElBQUl1eUI7UUFDcEQsSUFBSTN0QixJQUFJc1UsTUFBTXBaLElBQUl5eUIsT0FBT3ZaLE1BQU1qWixJQUFJd3lCLE9BQU96WixNQUFNOVksSUFBSXV5QjtRQUNwRCxPQUFPO1lBQ0w1dEI7WUFDQUM7UUFDRjtJQUNGO0lBRUEwc0Isd0JBQXdCdmhCLEVBQUUsRUFBRUMsRUFBRSxFQUFFNlcsRUFBRSxFQUFFQyxFQUFFLEVBQUV1SCxLQUFLLEVBQUVFLEdBQUcsRUFBRTtRQUNsRCxJQUFJbUUsU0FBUzMwQixLQUFLc1MsR0FBRyxDQUFDa2U7UUFDdEIsSUFBSW9FLFNBQVM1MEIsS0FBS3VTLEdBQUcsQ0FBQ2llO1FBQ3RCLElBQUlzRCxLQUFLO1lBQ1BsdEIsR0FBR2tpQixLQUFLOW9CLEtBQUtzUyxHQUFHLENBQUNnZTtZQUNqQnpwQixHQUFHa2lCLEtBQUsvb0IsS0FBS3VTLEdBQUcsQ0FBQytkO1FBQ25CO1FBQ0EsT0FBTztZQUNMMXBCLEdBQUdvTCxLQUFNOGhCLENBQUFBLEdBQUdsdEIsQ0FBQyxHQUFHK3RCLFNBQVNiLEdBQUdqdEIsQ0FBQyxHQUFHK3RCLE1BQUs7WUFDckMvdEIsR0FBR29MLEtBQU02aEIsQ0FBQUEsR0FBR2x0QixDQUFDLEdBQUdndUIsU0FBU2QsR0FBR2p0QixDQUFDLEdBQUc4dEIsTUFBSztRQUN2QztJQUNGO0lBR0FFLHNCQUFzQkMsU0FBUyxFQUFFQyxjQUFjLEVBQUU7UUFDL0MsSUFBSVYsVUFBVSxJQUFJLENBQUM3QixhQUFhO1FBQ2hDLElBQUl3QyxZQUFZRCxrQkFBa0IsTUFBTSwwQkFBMEI7UUFFbEUsSUFBSUUsT0FBT0gsYUFBYVQsVUFBVTtRQUVsQyxJQUFJLENBQUMsSUFBSSxDQUFDYSxnQkFBZ0IsSUFBSSxJQUFJLENBQUNBLGdCQUFnQixDQUFDRCxJQUFJLEtBQUtBLFFBQVEsSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQ0YsU0FBUyxLQUFLQSxXQUFXO1lBQ2xILGdCQUFnQjtZQUNoQixJQUFJLENBQUNFLGdCQUFnQixHQUFHO2dCQUN0QkQ7Z0JBQ0FEO2dCQUNBM3RCLFFBQVEsRUFBRTtZQUNaLEdBQUcsbUJBQW1CO1lBRXRCLElBQUl3YixJQUFJO1lBRVIsSUFBSyxJQUFJRCxJQUFJLEdBQUdBLEtBQUt5UixTQUFTelIsS0FBS29TLFVBQVc7Z0JBQzVDLElBQUk5YSxLQUFLLElBQUksQ0FBQ2lhLGNBQWMsQ0FBQ3ZSO2dCQUM3QixJQUFJekksS0FBSyxJQUFJLENBQUNnYSxjQUFjLENBQUN2UixJQUFJb1M7Z0JBRWpDLElBQUksQ0FBQzlhLE1BQU0sQ0FBQ0MsSUFBSTtvQkFDZDtnQkFDRjtnQkFFQTBJLEtBQUssSUFBSSxDQUFDb1EsYUFBYSxDQUFDL1ksR0FBR3RULENBQUMsRUFBRXNULEdBQUdyVCxDQUFDLEVBQUVzVCxHQUFHdlQsQ0FBQyxFQUFFdVQsR0FBR3RULENBQUM7Z0JBRTlDLElBQUlnYyxLQUFLb1MsTUFBTTtvQkFDYixJQUFJLENBQUNDLGdCQUFnQixDQUFDN3RCLE1BQU0sQ0FBQ2YsSUFBSSxDQUFDO3dCQUNoQ00sR0FBR3NULEdBQUd0VCxDQUFDO3dCQUNQQyxHQUFHcVQsR0FBR3JULENBQUM7d0JBQ1B1dEIsVUFBVXhSO29CQUNaO29CQUNBQyxLQUFLb1M7Z0JBQ1A7WUFDRjtRQUNGO0lBQ0Y7SUFFQXZELDBCQUEwQnlELGNBQWMsRUFBRUYsSUFBSSxFQUFFRCxTQUFTLEVBQUU7UUFDekQsSUFBSSxDQUFDSCxxQkFBcUIsQ0FBQ0ksTUFBTUQ7UUFFakMsSUFBSUcsaUJBQWlCLEtBQUtBLGlCQUFpQixJQUFJLENBQUMzQyxhQUFhLEtBQUssU0FBUztZQUN6RSxPQUFPO1FBQ1Q7UUFFQSxJQUFJekIsTUFBTS93QixLQUFLQyxLQUFLLENBQUNrMUIsaUJBQWlCLElBQUksQ0FBQzNDLGFBQWEsS0FBTSxLQUFJLENBQUMwQyxnQkFBZ0IsQ0FBQzd0QixNQUFNLENBQUMxSyxNQUFNLEdBQUc7UUFDcEcsT0FBTyxJQUFJLENBQUN1NEIsZ0JBQWdCLENBQUM3dEIsTUFBTSxDQUFDMHBCLElBQUksSUFBSTtJQUM5QztBQUVGO0FBRUEsSUFBSXFFLGVBQWU7QUFDbkIsTUFBTUMscUJBQXFCOVg7SUFDekJwYixZQUFZQyxTQUFRLEVBQUV0RSxJQUFJLEVBQUV3VyxnQkFBZ0IsQ0FBRTtRQUM1QyxLQUFLLENBQUNsUyxXQUFVdEUsTUFBTXdXO1FBQ3RCLElBQUksQ0FBQ3RLLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ3NyQixNQUFNLEdBQUc7UUFDZCxJQUFJQyxPQUFPLElBQUksQ0FBQ2p3QixnQkFBZ0IsR0FBRzVDLFNBQVM7UUFFNUMsSUFBSSxDQUFDNnlCLE1BQU07WUFDVDtRQUNGO1FBRUEsSUFBSUMsUUFBUUQsS0FBS255QixRQUFRLENBQUMsV0FBVyw0QkFBNEJqRSxJQUFJLENBQUNvMkI7UUFDdEVuekIsVUFBU3F6QixNQUFNLENBQUNudkIsSUFBSSxDQUFDLElBQUk7UUFFekIsSUFBSSxDQUFDa3ZCLE9BQU87WUFDVixLQUFLLElBQUksQ0FBQ3YzQixTQUFTLENBQUNzM0I7UUFDdEIsT0FBTztZQUNMLEtBQUssSUFBSSxDQUFDRyxPQUFPLENBQUNIO1FBQ3BCO1FBRUEsSUFBSSxDQUFDQyxLQUFLLEdBQUdBO0lBQ2Y7SUFFQXYzQixVQUFVczNCLElBQUksRUFBRTtRQUNkLElBQUk5a0IsUUFBUSxJQUFJO1FBRWhCLE9BQU94VSxvRUFBaUJBLENBQUM7WUFDdkIsSUFBSTtnQkFDRixJQUFJMDVCLFFBQVEsTUFBTWxsQixNQUFNck8sUUFBUSxDQUFDL0UsV0FBVyxDQUFDazRCO2dCQUM3QzlrQixNQUFNa2xCLEtBQUssR0FBR0E7WUFDaEIsRUFBRSxPQUFPNWtCLEtBQUs7Z0JBQ1o2a0IsUUFBUUMsS0FBSyxDQUFDLDhCQUErQnJtQixNQUFNLENBQUMrbEIsTUFBTSxPQUFReGtCO1lBQ3BFO1lBRUFOLE1BQU02a0IsTUFBTSxHQUFHO1FBQ2pCO0lBQ0Y7SUFFQUksUUFBUUgsSUFBSSxFQUFFO1FBQ1osSUFBSW5rQixTQUFTLElBQUk7UUFFakIsT0FBT25WLG9FQUFpQkEsQ0FBQztZQUN2QixJQUFJNEMsUUFBUXUyQixhQUFhNzFCLElBQUksQ0FBQ2cyQjtZQUU5QixJQUFJMTJCLE9BQU87Z0JBQ1QsSUFBSWdWLE9BQU9oVixLQUFLLENBQUMsRUFBRTtnQkFFbkIsSUFBSUEsS0FBSyxDQUFDLEVBQUUsS0FBSyxVQUFVO29CQUN6QnVTLE9BQU91a0IsS0FBSyxHQUFHRyxLQUFLamlCO2dCQUN0QixPQUFPO29CQUNMekMsT0FBT3VrQixLQUFLLEdBQUdJLG1CQUFtQmxpQjtnQkFDcEM7WUFDRixPQUFPO2dCQUNMLElBQUk7b0JBQ0YsSUFBSXRXLFdBQVcsTUFBTTZULE9BQU9oUCxRQUFRLENBQUM1RSxLQUFLLENBQUMrM0I7b0JBQzNDLElBQUlTLE1BQU0sTUFBTXo0QixTQUFTOFQsSUFBSTtvQkFDN0JELE9BQU91a0IsS0FBSyxHQUFHSztnQkFDakIsRUFBRSxPQUFPamxCLEtBQUs7b0JBQ1o2a0IsUUFBUUMsS0FBSyxDQUFDLDhCQUErQnJtQixNQUFNLENBQUMrbEIsTUFBTSxPQUFReGtCO2dCQUNwRTtZQUNGO1lBRUFLLE9BQU9ra0IsTUFBTSxHQUFHO1FBQ2xCO0lBQ0Y7SUFFQS9lLGVBQWVuUixHQUFHLEVBQUU7UUFDbEIsSUFBSSxFQUNGaEQsVUFBQUEsU0FBUSxFQUNSdXpCLEtBQUssRUFDTEwsTUFBTSxFQUNQLEdBQUcsSUFBSTtRQUNSLElBQUkxdUIsSUFBSSxJQUFJLENBQUNwQixZQUFZLENBQUMsS0FBS3ZCLFNBQVMsQ0FBQztRQUN6QyxJQUFJNEMsSUFBSSxJQUFJLENBQUNyQixZQUFZLENBQUMsS0FBS3ZCLFNBQVMsQ0FBQztRQUN6QyxJQUFJL0csUUFBUSxJQUFJLENBQUNvUyxRQUFRLENBQUMsU0FBU3JMLFNBQVMsQ0FBQztRQUM3QyxJQUFJOUcsU0FBUyxJQUFJLENBQUNtUyxRQUFRLENBQUMsVUFBVXJMLFNBQVMsQ0FBQztRQUUvQyxJQUFJLENBQUNxeEIsVUFBVSxDQUFDSyxTQUFTLENBQUN6NEIsU0FBUyxDQUFDQyxRQUFRO1lBQzFDO1FBQ0Y7UUFFQWlJLElBQUk4USxJQUFJO1FBQ1I5USxJQUFJb0ksU0FBUyxDQUFDNUcsR0FBR0M7UUFFakIsSUFBSSxJQUFJLENBQUMydUIsS0FBSyxFQUFFO1lBQ2QsSUFBSVMsY0FBYzd6QixVQUFTOHpCLEtBQUssQ0FBQ0MsVUFBVSxDQUFDL3dCLEtBQUssSUFBSSxDQUFDdXdCLEtBQUssRUFBRTtnQkFDM0QzNEIsYUFBYTtnQkFDYkQsaUJBQWlCO2dCQUNqQnFSLGtCQUFrQjtnQkFDbEJDLGFBQWE7Z0JBQ2JJLFNBQVM7Z0JBQ1RDLFNBQVM7Z0JBQ1RILFlBQVlyUjtnQkFDWnNSLGFBQWFyUjtZQUNmO1lBQ0E4NEIsWUFBWTd6QixRQUFRLENBQUNnMEIsZUFBZSxDQUFDcnRCLE1BQU0sR0FBRyxJQUFJO1lBQ2xELEtBQUtrdEIsWUFBWXRuQixNQUFNO1FBQ3pCLE9BQU87WUFDTCxJQUFJMG5CLFNBQVMsSUFBSSxDQUFDVixLQUFLO1lBQ3ZCdnpCLFVBQVMySixVQUFVLENBQUM7Z0JBQ2xCM0c7Z0JBQ0E0RyxhQUFhLElBQUksQ0FBQ3hHLFlBQVksQ0FBQyx1QkFBdUI5QyxTQUFTO2dCQUMvRHhGO2dCQUNBK08sY0FBY29xQixPQUFPbjVCLEtBQUs7Z0JBQzFCQztnQkFDQStPLGVBQWVtcUIsT0FBT2w1QixNQUFNO1lBQzlCO1lBRUEsSUFBSSxJQUFJLENBQUNtNEIsTUFBTSxFQUFFO2dCQUNmLElBQUksT0FBT2UsT0FBT0MsUUFBUSxLQUFLLGVBQWVELE9BQU9DLFFBQVEsRUFBRTtvQkFDN0RseEIsSUFBSW14QixTQUFTLENBQUNGLFFBQVEsR0FBRztnQkFDM0I7WUFDRjtRQUNGO1FBRUFqeEIsSUFBSXFSLE9BQU87SUFDYjtJQUVBc0ssaUJBQWlCO1FBQ2YsSUFBSW5hLElBQUksSUFBSSxDQUFDcEIsWUFBWSxDQUFDLEtBQUt2QixTQUFTLENBQUM7UUFDekMsSUFBSTRDLElBQUksSUFBSSxDQUFDckIsWUFBWSxDQUFDLEtBQUt2QixTQUFTLENBQUM7UUFDekMsSUFBSS9HLFFBQVEsSUFBSSxDQUFDb1MsUUFBUSxDQUFDLFNBQVNyTCxTQUFTLENBQUM7UUFDN0MsSUFBSTlHLFNBQVMsSUFBSSxDQUFDbVMsUUFBUSxDQUFDLFVBQVVyTCxTQUFTLENBQUM7UUFDL0MsT0FBTyxJQUFJcVYsWUFBWTFTLEdBQUdDLEdBQUdELElBQUkxSixPQUFPMkosSUFBSTFKO0lBQzlDO0FBRUY7QUFFQSxNQUFNcTVCLHNCQUFzQmpaO0lBQzFCcGIsYUFBYztRQUNaLEtBQUssSUFBSXpGO1FBQ1QsSUFBSSxDQUFDc04sSUFBSSxHQUFHO0lBQ2Q7SUFFQTJFLE9BQU9uRCxDQUFDLEVBQUUsQ0FDVjtBQUVGO0FBRUEsTUFBTWlyQjtJQUNKdDBCLFlBQVlDLFNBQVEsQ0FBRTtRQUNwQixJQUFJLENBQUNBLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDa3pCLE1BQU0sR0FBRztRQUNkbHpCLFVBQVNzMEIsS0FBSyxDQUFDcHdCLElBQUksQ0FBQyxJQUFJO0lBQzFCO0lBRUFxSyxLQUFLcUgsVUFBVSxFQUFFMWEsR0FBRyxFQUFFO1FBQ3BCLElBQUltVCxRQUFRLElBQUk7UUFFaEIsT0FBT3hVLG9FQUFpQkEsQ0FBQztZQUN2QixJQUFJO2dCQUNGLElBQUksRUFDRm1HLFVBQUFBLFNBQVEsRUFDVCxHQUFHcU87Z0JBQ0osSUFBSWttQixjQUFjLE1BQU12MEIsVUFBUzh6QixLQUFLLENBQUNybEIsTUFBTSxDQUFDRixJQUFJLENBQUNyVDtnQkFDbkQsSUFBSW81QixRQUFRQyxZQUFZMWxCLG9CQUFvQixDQUFDO2dCQUM3QzhELE1BQU1DLElBQUksQ0FBQzBoQixPQUFPN3RCLE9BQU8sQ0FBQyt0QixDQUFBQTtvQkFDeEIsSUFBSTdkLE9BQU8zVyxVQUFTd1UsYUFBYSxDQUFDZ2dCO29CQUNsQ3gwQixVQUFTMkMsV0FBVyxDQUFDaVQsV0FBVyxHQUFHZTtnQkFDckM7WUFDRixFQUFFLE9BQU9oSSxLQUFLO2dCQUNaNmtCLFFBQVFDLEtBQUssQ0FBQyw2QkFBOEJybUIsTUFBTSxDQUFDbFMsS0FBSyxPQUFReVQ7WUFDbEU7WUFFQU4sTUFBTTZrQixNQUFNLEdBQUc7UUFDakI7SUFDRjtBQUVGO0FBRUEsTUFBTXVCLHFCQUFxQnhpQjtJQUN6QmxTLFlBQVlDLFNBQVEsRUFBRXRFLElBQUksRUFBRXdXLGdCQUFnQixDQUFFO1FBQzVDLEtBQUssQ0FBQ2xTLFdBQVV0RSxNQUFNd1c7UUFDdEIsSUFBSSxDQUFDdEssSUFBSSxHQUFHO1FBQ1osSUFBSThzQixNQUFNeDRCLGVBQWV5VyxNQUFNQyxJQUFJLENBQUNsWCxLQUFLdVgsVUFBVSxFQUFFLFlBQVk7U0FDaEV2VyxHQUFHLENBQUMwTSxDQUFBQSxJQUFLQSxFQUFFMkYsV0FBVyxFQUFFblEsSUFBSSxDQUFDLElBQUl4QyxPQUFPLENBQUMsa0VBQWtFLElBQUksa0JBQWtCO1NBQ2pJQSxPQUFPLENBQUMsZUFBZSxJQUFJLGlCQUFpQjs7UUFFN0MsSUFBSXU0QixVQUFVRCxJQUFJdDBCLEtBQUssQ0FBQztRQUN4QnUwQixRQUFRbHVCLE9BQU8sQ0FBQzJDLENBQUFBO1lBQ2QsSUFBSWpJLE1BQU1pSSxFQUFFN0ksSUFBSTtZQUVoQixJQUFJLENBQUNZLEtBQUs7Z0JBQ1I7WUFDRjtZQUVBLElBQUl5ekIsV0FBV3p6QixJQUFJZixLQUFLLENBQUM7WUFDekIsSUFBSXkwQixhQUFhRCxRQUFRLENBQUMsRUFBRSxDQUFDeDBCLEtBQUssQ0FBQztZQUNuQyxJQUFJMDBCLFdBQVdGLFFBQVEsQ0FBQyxFQUFFLENBQUN4MEIsS0FBSyxDQUFDO1lBQ2pDeTBCLFdBQVdwdUIsT0FBTyxDQUFDMkMsQ0FBQUE7Z0JBQ2pCLElBQUkyckIsV0FBVzNyQixFQUFFN0ksSUFBSTtnQkFFckIsSUFBSSxDQUFDdzBCLFVBQVU7b0JBQ2I7Z0JBQ0Y7Z0JBRUEsSUFBSUMsUUFBUWgxQixVQUFTcVMsTUFBTSxDQUFDMGlCLFNBQVMsSUFBSSxDQUFDO2dCQUMxQ0QsU0FBU3J1QixPQUFPLENBQUN3dUIsQ0FBQUE7b0JBQ2YsSUFBSWxLLE9BQU9rSyxRQUFReGYsT0FBTyxDQUFDO29CQUMzQixJQUFJM1ksT0FBT200QixRQUFRQyxNQUFNLENBQUMsR0FBR25LLE1BQU14cUIsSUFBSTtvQkFDdkMsSUFBSU4sUUFBUWcxQixRQUFRQyxNQUFNLENBQUNuSyxPQUFPLEdBQUdrSyxRQUFRMTZCLE1BQU0sR0FBR3d3QixNQUFNeHFCLElBQUk7b0JBRWhFLElBQUl6RCxRQUFRbUQsT0FBTzt3QkFDakIrMEIsS0FBSyxDQUFDbDRCLEtBQUssR0FBRyxJQUFJZ0QsU0FBU0UsV0FBVWxELE1BQU1tRDtvQkFDN0M7Z0JBQ0Y7Z0JBQ0FELFVBQVNxUyxNQUFNLENBQUMwaUIsU0FBUyxHQUFHQztnQkFDNUJoMUIsVUFBU3NTLGlCQUFpQixDQUFDeWlCLFNBQVMsR0FBR3YyQix1QkFBdUJ1MkI7Z0JBRTlELElBQUlBLGFBQWEsY0FBYztvQkFDN0IsZUFBZTtvQkFDZixJQUFJbmYsYUFBYW9mLEtBQUssQ0FBQyxjQUFjLENBQUMxMEIsU0FBUyxHQUFHbEUsT0FBTyxDQUFDLFFBQVE7b0JBQ2xFLElBQUkrNEIsT0FBT0gsTUFBTUksR0FBRyxDQUFDOTBCLFNBQVMsR0FBR0YsS0FBSyxDQUFDO29CQUN2QyswQixLQUFLMXVCLE9BQU8sQ0FBQzJ1QixDQUFBQTt3QkFDWCxJQUFJQSxJQUFJM2YsT0FBTyxDQUFDLG1CQUFtQixHQUFHOzRCQUNwQyxJQUFJdmEsTUFBTStCLGlCQUFpQm00Qjs0QkFFM0IsSUFBSWw2QixLQUFLO2dDQUNQLEtBQUssSUFBSW01QixjQUFjcjBCLFdBQVV1TyxJQUFJLENBQUNxSCxZQUFZMWE7NEJBQ3BEO3dCQUNGO29CQUNGO2dCQUNGO1lBQ0Y7UUFDRjtJQUNGO0FBRUY7QUFDQXU1QixhQUFheDNCLGdCQUFnQixHQUFHQTtBQUVoQyxNQUFNbzRCLG1CQUFtQmxhO0lBQ3ZCcGIsYUFBYztRQUNaLEtBQUssSUFBSXpGO1FBQ1QsSUFBSSxDQUFDc04sSUFBSSxHQUFHO0lBQ2Q7SUFFQXNNLFdBQVdsUixHQUFHLEVBQUU7UUFDZCxLQUFLLENBQUNrUixXQUFXbFI7UUFDakIsSUFBSTBoQixRQUFRLElBQUksQ0FBQ3RoQixZQUFZLENBQUM7UUFDOUIsSUFBSXVoQixRQUFRLElBQUksQ0FBQ3ZoQixZQUFZLENBQUM7UUFFOUIsSUFBSXNoQixNQUFNbGtCLFFBQVEsSUFBSTtZQUNwQndDLElBQUlvSSxTQUFTLENBQUNzWixNQUFNN2lCLFNBQVMsQ0FBQyxNQUFNO1FBQ3RDO1FBRUEsSUFBSThpQixNQUFNbmtCLFFBQVEsSUFBSTtZQUNwQndDLElBQUlvSSxTQUFTLENBQUMsR0FBR3VaLE1BQU05aUIsU0FBUyxDQUFDO1FBQ25DO0lBQ0Y7SUFFQW1ELEtBQUtoQyxHQUFHLEVBQUU7UUFDUixJQUFJLEVBQ0ZILE9BQU8sRUFDUixHQUFHLElBQUk7UUFFUixJQUFJQSxTQUFTO1lBQ1hBLFFBQVFtQyxJQUFJLENBQUNoQztRQUNmO0lBQ0Y7SUFFQW1SLGVBQWVuUixHQUFHLEVBQUU7UUFDbEIsSUFBSSxFQUNGaEQsVUFBQUEsU0FBUSxFQUNSNkMsT0FBTyxFQUNSLEdBQUcsSUFBSTtRQUVSLElBQUlBLFNBQVM7WUFDWCxJQUFJeXlCLFVBQVV6eUI7WUFFZCxJQUFJQSxRQUFRK0UsSUFBSSxLQUFLLFVBQVU7Z0JBQzdCLDRHQUE0RztnQkFDNUcwdEIsVUFBVSxJQUFJaFEsV0FBV3RsQixXQUFVO2dCQUNuQ3MxQixRQUFRbmpCLFVBQVUsQ0FBQzFFLE9BQU8sR0FBRyxJQUFJM04sU0FBU0UsV0FBVSxXQUFXNkMsUUFBUU8sWUFBWSxDQUFDLFdBQVc5QyxTQUFTO2dCQUN4R2cxQixRQUFRbmpCLFVBQVUsQ0FBQzZULG1CQUFtQixHQUFHLElBQUlsbUIsU0FBU0UsV0FBVSx1QkFBdUI2QyxRQUFRTyxZQUFZLENBQUMsdUJBQXVCOUMsU0FBUztnQkFDNUlnMUIsUUFBUW5qQixVQUFVLENBQUM2VixRQUFRLEdBQUcsSUFBSWxvQixTQUFTRSxXQUFVLFlBQVk2QyxRQUFRTyxZQUFZLENBQUMsWUFBWTlDLFNBQVM7Z0JBQzNHZzFCLFFBQVE3aUIsUUFBUSxHQUFHNVAsUUFBUTRQLFFBQVEsRUFBRSw4Q0FBOEM7Z0JBRW5GNVAsUUFBUXdQLE1BQU0sQ0FBQ3ZQLE9BQU8sR0FBRyxJQUFJaEQsU0FBU0UsV0FBVSxXQUFXLElBQUksQ0FBQ3FiLGdCQUFnQjtZQUNsRjtZQUVBLElBQUlpYSxRQUFRMXRCLElBQUksS0FBSyxPQUFPO2dCQUMxQixJQUFJcUYsYUFBYSxJQUFJLENBQUNDLFFBQVEsQ0FBQyxTQUFTLE9BQU87Z0JBQy9DLElBQUlDLGNBQWMsSUFBSSxDQUFDRCxRQUFRLENBQUMsVUFBVSxPQUFPLE9BQU8saURBQWlEO2dCQUV6RyxJQUFJRCxXQUFXek0sUUFBUSxJQUFJO29CQUN6QjgwQixRQUFRbmpCLFVBQVUsQ0FBQ3JYLEtBQUssR0FBRyxJQUFJZ0YsU0FBU0UsV0FBVSxTQUFTaU4sV0FBVzNNLFNBQVM7Z0JBQ2pGO2dCQUVBLElBQUk2TSxZQUFZM00sUUFBUSxJQUFJO29CQUMxQjgwQixRQUFRbmpCLFVBQVUsQ0FBQ3BYLE1BQU0sR0FBRyxJQUFJK0UsU0FBU0UsV0FBVSxVQUFVbU4sWUFBWTdNLFNBQVM7Z0JBQ3BGO1lBQ0Y7WUFFQSxJQUFJaTFCLFlBQVlELFFBQVEzdUIsTUFBTTtZQUM5QjJ1QixRQUFRM3VCLE1BQU0sR0FBRyxJQUFJO1lBQ3JCMnVCLFFBQVEvb0IsTUFBTSxDQUFDdko7WUFDZnN5QixRQUFRM3VCLE1BQU0sR0FBRzR1QjtRQUNuQjtJQUNGO0lBRUE1VyxlQUFlM2IsR0FBRyxFQUFFO1FBQ2xCLElBQUksRUFDRkgsT0FBTyxFQUNSLEdBQUcsSUFBSTtRQUVSLElBQUlBLFNBQVM7WUFDWCxPQUFPQSxRQUFROGIsY0FBYyxDQUFDM2I7UUFDaEM7UUFFQSxPQUFPO0lBQ1Q7SUFFQXd5QixtQkFBbUI7UUFDakIsSUFBSSxFQUNGeDFCLFVBQUFBLFNBQVEsRUFDUjZDLE9BQU8sRUFDUixHQUFHLElBQUk7UUFDUixPQUFPME8sVUFBVUssV0FBVyxDQUFDNVIsV0FBVTZDO0lBQ3pDO0lBRUEsSUFBSUEsVUFBVTtRQUNaLElBQUksQ0FBQyxJQUFJLENBQUM0eUIsYUFBYSxFQUFFO1lBQ3ZCLElBQUksQ0FBQ0EsYUFBYSxHQUFHLElBQUksQ0FBQ3Z5QixnQkFBZ0IsR0FBR1IsYUFBYTtRQUM1RDtRQUVBLE9BQU8sSUFBSSxDQUFDK3lCLGFBQWE7SUFDM0I7QUFFRjtBQUVBLFNBQVNDLE1BQU1wNkIsR0FBRyxFQUFFa0osQ0FBQyxFQUFFQyxDQUFDLEVBQUUzSixLQUFLLEVBQUU2NkIsT0FBTyxFQUFFQyxJQUFJO0lBQzVDLE9BQU90NkIsR0FBRyxDQUFDbUosSUFBSTNKLFFBQVEsSUFBSTBKLElBQUksSUFBSW94QixLQUFLO0FBQzFDO0FBRUEsU0FBU0MsTUFBTXY2QixHQUFHLEVBQUVrSixDQUFDLEVBQUVDLENBQUMsRUFBRTNKLEtBQUssRUFBRTY2QixPQUFPLEVBQUVDLElBQUksRUFBRUUsR0FBRztJQUNqRHg2QixHQUFHLENBQUNtSixJQUFJM0osUUFBUSxJQUFJMEosSUFBSSxJQUFJb3hCLEtBQUssR0FBR0U7QUFDdEM7QUFFQSxTQUFTdEUsRUFBRWpoQixNQUFNLEVBQUU3TSxDQUFDLEVBQUUzRSxDQUFDO0lBQ3JCLElBQUlnM0IsS0FBS3hsQixNQUFNLENBQUM3TSxFQUFFO0lBQ2xCLE9BQU9xeUIsS0FBS2gzQjtBQUNkO0FBRUEsU0FBUzJSLEVBQUVGLENBQUMsRUFBRXdsQixFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRTtJQUN0QixPQUFPRixLQUFLcDRCLEtBQUtzUyxHQUFHLENBQUNNLEtBQUt5bEIsS0FBS3I0QixLQUFLdVMsR0FBRyxDQUFDSyxLQUFLMGxCO0FBQy9DO0FBRUEsTUFBTUMsNkJBQTZCbGtCO0lBQ2pDbFMsWUFBWUMsU0FBUSxFQUFFdEUsSUFBSSxFQUFFd1csZ0JBQWdCLENBQUU7UUFDNUMsS0FBSyxDQUFDbFMsV0FBVXRFLE1BQU13VztRQUN0QixJQUFJLENBQUN0SyxJQUFJLEdBQUc7UUFDWixJQUFJMkksU0FBU2hVLFVBQVUsSUFBSSxDQUFDNkcsWUFBWSxDQUFDLFVBQVU5QyxTQUFTO1FBRTVELE9BQVEsSUFBSSxDQUFDOEMsWUFBWSxDQUFDLFFBQVE5QyxTQUFTLENBQUM7WUFDMUMsNkRBQTZEO1lBQzdELEtBQUs7Z0JBQ0g7b0JBQ0UsSUFBSW1nQixJQUFJbFEsTUFBTSxDQUFDLEVBQUU7b0JBQ2pCLHdDQUF3QyxHQUV4Q0EsU0FBUzt3QkFBQyxRQUFRLFFBQVFrUTt3QkFBRyxRQUFRLFFBQVFBO3dCQUFHLFFBQVEsUUFBUUE7d0JBQUc7d0JBQUc7d0JBQUcsUUFBUSxRQUFRQTt3QkFBRyxRQUFRLFFBQVFBO3dCQUFHLFFBQVEsUUFBUUE7d0JBQUc7d0JBQUc7d0JBQUcsUUFBUSxRQUFRQTt3QkFBRyxRQUFRLFFBQVFBO3dCQUFHLFFBQVEsUUFBUUE7d0JBQUc7d0JBQUc7d0JBQUc7d0JBQUc7d0JBQUc7d0JBQUc7d0JBQUc7d0JBQUc7d0JBQUc7d0JBQUc7d0JBQUc7d0JBQUc7cUJBQUU7b0JBR3BPO2dCQUNGO1lBRUYsS0FBSztnQkFDSDtvQkFDRSxJQUFJalEsSUFBSUQsTUFBTSxDQUFDLEVBQUUsR0FBRzNTLEtBQUs2RSxFQUFFLEdBQUc7b0JBQzlCLHdDQUF3QyxHQUV4QzhOLFNBQVM7d0JBQUNHLEVBQUVGLEdBQUcsT0FBTyxPQUFPLENBQUM7d0JBQVFFLEVBQUVGLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQzt3QkFBUUUsRUFBRUYsR0FBRyxPQUFPLENBQUMsT0FBTzt3QkFBUTt3QkFBRzt3QkFBR0UsRUFBRUYsR0FBRyxPQUFPLENBQUMsT0FBTzt3QkFBUUUsRUFBRUYsR0FBRyxPQUFPLE9BQU87d0JBQVFFLEVBQUVGLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQzt3QkFBUTt3QkFBRzt3QkFBR0UsRUFBRUYsR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDO3dCQUFRRSxFQUFFRixHQUFHLE9BQU8sQ0FBQyxPQUFPO3dCQUFRRSxFQUFFRixHQUFHLE9BQU8sT0FBTzt3QkFBUTt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFHdFQ7Z0JBQ0Y7WUFFRixLQUFLO2dCQUNILHdDQUF3QyxHQUN4Q0QsU0FBUztvQkFBQztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBUTtvQkFBUTtvQkFBUTtvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztpQkFBRTtnQkFHbkc7UUFDSjtRQUVBLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQzZsQixjQUFjLEdBQUcsSUFBSSxDQUFDaHpCLFlBQVksQ0FBQyxrQkFBa0I1QyxRQUFRO0lBQ3BFO0lBRUEyTyxNQUFNbk0sR0FBRyxFQUFFcXpCLEVBQUUsRUFBRUMsRUFBRSxFQUFFeDdCLEtBQUssRUFBRUMsTUFBTSxFQUFFO1FBQ2hDLGdDQUFnQztRQUNoQyxJQUFJLEVBQ0ZxN0IsY0FBYyxFQUNkN2xCLE1BQU0sRUFDUCxHQUFHLElBQUk7UUFDUixJQUFJZ21CLFVBQVV2ekIsSUFBSXd6QixZQUFZLENBQUMsR0FBRyxHQUFHMTdCLE9BQU9DO1FBRTVDLElBQUssSUFBSTBKLElBQUksR0FBR0EsSUFBSTFKLFFBQVEwSixJQUFLO1lBQy9CLElBQUssSUFBSUQsSUFBSSxHQUFHQSxJQUFJMUosT0FBTzBKLElBQUs7Z0JBQzlCLElBQUl5YyxJQUFJeVUsTUFBTWEsUUFBUTlrQixJQUFJLEVBQUVqTixHQUFHQyxHQUFHM0osT0FBT0MsUUFBUTtnQkFDakQsSUFBSThWLElBQUk2a0IsTUFBTWEsUUFBUTlrQixJQUFJLEVBQUVqTixHQUFHQyxHQUFHM0osT0FBT0MsUUFBUTtnQkFDakQsSUFBSTBWLElBQUlpbEIsTUFBTWEsUUFBUTlrQixJQUFJLEVBQUVqTixHQUFHQyxHQUFHM0osT0FBT0MsUUFBUTtnQkFDakQsSUFBSXlWLElBQUlrbEIsTUFBTWEsUUFBUTlrQixJQUFJLEVBQUVqTixHQUFHQyxHQUFHM0osT0FBT0MsUUFBUTtnQkFDakQsSUFBSTA3QixLQUFLakYsRUFBRWpoQixRQUFRLEdBQUcwUSxLQUFLdVEsRUFBRWpoQixRQUFRLEdBQUdNLEtBQUsyZ0IsRUFBRWpoQixRQUFRLEdBQUdFLEtBQUsrZ0IsRUFBRWpoQixRQUFRLEdBQUdDLEtBQUtnaEIsRUFBRWpoQixRQUFRLEdBQUc7Z0JBQzlGLElBQUltbUIsS0FBS2xGLEVBQUVqaEIsUUFBUSxHQUFHMFEsS0FBS3VRLEVBQUVqaEIsUUFBUSxHQUFHTSxLQUFLMmdCLEVBQUVqaEIsUUFBUSxHQUFHRSxLQUFLK2dCLEVBQUVqaEIsUUFBUSxHQUFHQyxLQUFLZ2hCLEVBQUVqaEIsUUFBUSxHQUFHO2dCQUM5RixJQUFJb21CLEtBQUtuRixFQUFFamhCLFFBQVEsSUFBSTBRLEtBQUt1USxFQUFFamhCLFFBQVEsSUFBSU0sS0FBSzJnQixFQUFFamhCLFFBQVEsSUFBSUUsS0FBSytnQixFQUFFamhCLFFBQVEsSUFBSUMsS0FBS2doQixFQUFFamhCLFFBQVEsSUFBSTtnQkFDbkcsSUFBSXFtQixLQUFLcEYsRUFBRWpoQixRQUFRLElBQUkwUSxLQUFLdVEsRUFBRWpoQixRQUFRLElBQUlNLEtBQUsyZ0IsRUFBRWpoQixRQUFRLElBQUlFLEtBQUsrZ0IsRUFBRWpoQixRQUFRLElBQUlDLEtBQUtnaEIsRUFBRWpoQixRQUFRLElBQUk7Z0JBRW5HLElBQUk2bEIsZ0JBQWdCO29CQUNsQkssS0FBSztvQkFDTEMsS0FBSztvQkFDTEMsS0FBSztvQkFDTEMsTUFBTXBtQixJQUFJO2dCQUNaO2dCQUVBcWxCLE1BQU1VLFFBQVE5a0IsSUFBSSxFQUFFak4sR0FBR0MsR0FBRzNKLE9BQU9DLFFBQVEsR0FBRzA3QjtnQkFDNUNaLE1BQU1VLFFBQVE5a0IsSUFBSSxFQUFFak4sR0FBR0MsR0FBRzNKLE9BQU9DLFFBQVEsR0FBRzI3QjtnQkFDNUNiLE1BQU1VLFFBQVE5a0IsSUFBSSxFQUFFak4sR0FBR0MsR0FBRzNKLE9BQU9DLFFBQVEsR0FBRzQ3QjtnQkFDNUNkLE1BQU1VLFFBQVE5a0IsSUFBSSxFQUFFak4sR0FBR0MsR0FBRzNKLE9BQU9DLFFBQVEsR0FBRzY3QjtZQUM5QztRQUNGO1FBRUE1ekIsSUFBSWdMLFNBQVMsQ0FBQyxHQUFHLEdBQUdsVCxPQUFPQztRQUMzQmlJLElBQUk2ekIsWUFBWSxDQUFDTixTQUFTLEdBQUc7SUFDL0I7QUFFRjtBQUVBLE1BQU1PLG9CQUFvQjdrQjtJQUN4QmxTLGFBQWM7UUFDWixLQUFLLElBQUl6RjtRQUNULElBQUksQ0FBQ3NOLElBQUksR0FBRztJQUNkO0lBRUF1SCxNQUFNbk0sR0FBRyxFQUFFSCxPQUFPLEVBQUU7UUFDbEIsSUFBSSxFQUNGN0MsVUFBQUEsU0FBUSxFQUNULEdBQUcsSUFBSSxFQUFFLHFCQUFxQjtRQUUvQixJQUFJd0UsSUFBSSxJQUFJLENBQUNwQixZQUFZLENBQUMsS0FBS3ZCLFNBQVMsQ0FBQztRQUN6QyxJQUFJNEMsSUFBSSxJQUFJLENBQUNyQixZQUFZLENBQUMsS0FBS3ZCLFNBQVMsQ0FBQztRQUN6QyxJQUFJL0csUUFBUSxJQUFJLENBQUNvUyxRQUFRLENBQUMsU0FBU3JMLFNBQVMsQ0FBQztRQUM3QyxJQUFJOUcsU0FBUyxJQUFJLENBQUNtUyxRQUFRLENBQUMsVUFBVXJMLFNBQVMsQ0FBQztRQUUvQyxJQUFJLENBQUMvRyxTQUFTLENBQUNDLFFBQVE7WUFDckIsSUFBSWlNLGNBQWMsSUFBSWtRO1lBQ3RCLElBQUksQ0FBQ3pFLFFBQVEsQ0FBQ2hNLE9BQU8sQ0FBQzhOLENBQUFBO2dCQUNwQnZOLFlBQVk0USxjQUFjLENBQUNyRCxNQUFNb0ssY0FBYyxDQUFDM2I7WUFDbEQ7WUFDQXdCLElBQUk1RyxLQUFLd3RCLEtBQUssQ0FBQ3BrQixZQUFZbVEsRUFBRTtZQUM3QjFTLElBQUk3RyxLQUFLd3RCLEtBQUssQ0FBQ3BrQixZQUFZc1EsRUFBRTtZQUM3QnhjLFFBQVE4QyxLQUFLd3RCLEtBQUssQ0FBQ3BrQixZQUFZbE0sS0FBSztZQUNwQ0MsU0FBUzZDLEtBQUt3dEIsS0FBSyxDQUFDcGtCLFlBQVlqTSxNQUFNO1FBQ3hDO1FBRUEsSUFBSWc4QixnQkFBZ0IsSUFBSSxDQUFDN2hCLFlBQVksQ0FBQ3JTLFNBQVNpMEIsWUFBWTNoQixZQUFZO1FBQ3ZFLElBQUk2aEIsYUFBYWgzQixVQUFTbkYsWUFBWSxDQUFDMkosSUFBSTFKLE9BQU8ySixJQUFJMUo7UUFDdEQsSUFBSWs4QixVQUFVRCxXQUFXdFAsVUFBVSxDQUFDO1FBQ3BDMW5CLFVBQVNtQyxNQUFNLENBQUNtSCxXQUFXLENBQUMydEI7UUFDNUIsSUFBSSxDQUFDOWlCLGNBQWMsQ0FBQzhpQixVQUFVLHlDQUF5QztRQUN2RSw4Q0FBOEM7UUFFOUMsSUFBSWQscUJBQXFCbjJCLFdBQVU7WUFDakMwUyxVQUFVO1lBQ1ZPLFlBQVksRUFBRTtZQUNkZCxZQUFZO2dCQUFDO29CQUNYVyxVQUFVO29CQUNWN1MsT0FBTztnQkFDVDtnQkFBRztvQkFDRDZTLFVBQVU7b0JBQ1Y3UyxPQUFPO2dCQUNUO2FBQUU7UUFDSixHQUFHa1AsS0FBSyxDQUFDOG5CLFNBQVMsR0FBRyxHQUFHenlCLElBQUkxSixPQUFPMkosSUFBSTFKO1FBQ3ZDLElBQUltOEIsWUFBWWwzQixVQUFTbkYsWUFBWSxDQUFDMkosSUFBSTFKLE9BQU8ySixJQUFJMUo7UUFDckQsSUFBSW84QixTQUFTRCxVQUFVeFAsVUFBVSxDQUFDO1FBQ2xDMW5CLFVBQVNtQyxNQUFNLENBQUNtSCxXQUFXLENBQUM2dEI7UUFDNUJ0MEIsUUFBUTBKLE1BQU0sQ0FBQzRxQjtRQUNmQSxPQUFPQyx3QkFBd0IsR0FBRztRQUNsQ0QsT0FBT3ZiLFNBQVMsR0FBR3FiLFFBQVFoMEIsYUFBYSxDQUFDK3pCLFlBQVk7UUFDckRHLE9BQU9FLFFBQVEsQ0FBQyxHQUFHLEdBQUc3eUIsSUFBSTFKLE9BQU8ySixJQUFJMUo7UUFDckNpSSxJQUFJNFksU0FBUyxHQUFHdWIsT0FBT2wwQixhQUFhLENBQUNpMEIsV0FBVztRQUNoRGwwQixJQUFJcTBCLFFBQVEsQ0FBQyxHQUFHLEdBQUc3eUIsSUFBSTFKLE9BQU8ySixJQUFJMUosU0FBUyxnQkFBZ0I7UUFFM0QsSUFBSSxDQUFDdWEsYUFBYSxDQUFDelMsU0FBU2swQjtJQUM5QjtJQUVBeHFCLE9BQU9uRCxDQUFDLEVBQUUsQ0FDVjtBQUVGO0FBQ0EwdEIsWUFBWTNoQixZQUFZLEdBQUc7SUFBQztJQUFRO0lBQWE7Q0FBWTtBQUU3RCxJQUFJbWlCLE9BQU8sS0FDWDtBQUVBLE1BQU1DLHdCQUF3QnRsQjtJQUM1QmxTLGFBQWM7UUFDWixLQUFLLElBQUl6RjtRQUNULElBQUksQ0FBQ3NOLElBQUksR0FBRztJQUNkO0lBRUF1SCxNQUFNbk0sR0FBRyxFQUFFO1FBQ1QsSUFBSSxFQUNGaEQsVUFBQUEsU0FBUSxFQUNULEdBQUcsSUFBSTtRQUNSLElBQUl3M0IsZUFBZWg4QixRQUFRaThCLGNBQWMsQ0FBQ3owQjtRQUMxQyxJQUFJLEVBQ0Z1SSxTQUFTLEVBQ1RHLFNBQVMsRUFDVixHQUFHMUk7UUFFSixJQUFJdzBCLGNBQWM7WUFDaEJBLGFBQWFqc0IsU0FBUyxHQUFHK3JCO1lBQ3pCRSxhQUFhOXJCLFNBQVMsR0FBRzRyQjtRQUMzQjtRQUVBOTdCLFFBQVEyVCxLQUFLLENBQUM1RCxXQUFXdkksS0FBSyxFQUFFO1FBQ2hDLElBQUksQ0FBQ3lQLFFBQVEsQ0FBQ2hNLE9BQU8sQ0FBQzhOLENBQUFBO1lBQ3BCLElBQUksT0FBT0EsTUFBTXZQLElBQUksS0FBSyxhQUFhO2dCQUNyQztZQUNGO1lBRUEsSUFBSU0sWUFBWSxPQUFPaVAsTUFBTWloQixnQkFBZ0IsS0FBSyxjQUFjamhCLE1BQU1paEIsZ0JBQWdCLEtBQUssTUFBTSxpQkFBaUI7WUFFbEgsSUFBSSxDQUFDbHdCLFdBQVc7Z0JBQ2RBLFlBQVlpTSxVQUFVSyxXQUFXLENBQUM1UixXQUFVdVU7WUFDOUM7WUFFQSxJQUFJalAsV0FBVztnQkFDYkEsVUFBVTZKLEtBQUssQ0FBQ25NO1lBQ2xCO1lBRUF1UixNQUFNdlAsSUFBSSxDQUFDaEM7WUFFWCxJQUFJdzBCLGNBQWM7Z0JBQ2hCQSxhQUFhOXJCLFNBQVMsR0FBR0E7WUFDM0I7WUFFQSxJQUFJcEcsV0FBVztnQkFDYkEsVUFBVThKLE9BQU8sQ0FBQ3BNO1lBQ3BCO1FBQ0Y7UUFDQXhILFFBQVEyVCxLQUFLLENBQUN6RCxXQUFXMUksS0FBSyxFQUFFO1FBQ2hDQSxJQUFJbUgsSUFBSTtRQUVSLElBQUlxdEIsY0FBYztZQUNoQkEsYUFBYWpzQixTQUFTLEdBQUdBO1lBQ3pCaXNCLGFBQWE5ckIsU0FBUyxHQUFHQTtRQUMzQjtJQUNGO0lBRUFhLE9BQU9uRCxDQUFDLEVBQUUsQ0FDVjtBQUVGO0FBRUEsTUFBTXN1QixzQkFBc0J6bEI7SUFDMUJsUyxhQUFjO1FBQ1osS0FBSyxJQUFJekY7UUFDVCxJQUFJLENBQUNzTixJQUFJLEdBQUc7SUFDZDtJQUVBdUgsTUFBTW5NLEdBQUcsRUFBRUgsT0FBTyxFQUFFO1FBQ2xCLHFCQUFxQjtRQUNyQixJQUFJLEVBQ0Y3QyxVQUFBQSxTQUFRLEVBQ1J5UyxRQUFRLEVBQ1QsR0FBRyxJQUFJO1FBQ1IsSUFBSXpMLGNBQWNuRSxRQUFROGIsY0FBYyxDQUFDM2I7UUFFekMsSUFBSSxDQUFDZ0UsYUFBYTtZQUNoQjtRQUNGO1FBRUEsSUFBSTJ3QixLQUFLO1FBQ1QsSUFBSUMsS0FBSztRQUNUbmxCLFNBQVNoTSxPQUFPLENBQUM4TixDQUFBQTtZQUNmLElBQUlzakIsTUFBTXRqQixNQUFNdWpCLG1CQUFtQixJQUFJO1lBQ3ZDSCxLQUFLLzVCLEtBQUswRSxHQUFHLENBQUNxMUIsSUFBSUU7WUFDbEJELEtBQUtoNkIsS0FBSzBFLEdBQUcsQ0FBQ3MxQixJQUFJQztRQUNwQjtRQUNBLElBQUkvOEIsUUFBUThDLEtBQUt3dEIsS0FBSyxDQUFDcGtCLFlBQVlsTSxLQUFLO1FBQ3hDLElBQUlDLFNBQVM2QyxLQUFLd3RCLEtBQUssQ0FBQ3BrQixZQUFZak0sTUFBTTtRQUMxQyxJQUFJZzlCLGlCQUFpQmo5QixRQUFRLElBQUk2OEI7UUFDakMsSUFBSUssa0JBQWtCajlCLFNBQVMsSUFBSTY4QjtRQUVuQyxJQUFJRyxpQkFBaUIsS0FBS0Msa0JBQWtCLEdBQUc7WUFDN0M7UUFDRjtRQUVBLElBQUl4ekIsSUFBSTVHLEtBQUt3dEIsS0FBSyxDQUFDcGtCLFlBQVl4QyxDQUFDO1FBQ2hDLElBQUlDLElBQUk3RyxLQUFLd3RCLEtBQUssQ0FBQ3BrQixZQUFZdkMsQ0FBQztRQUNoQyxJQUFJc3lCLGdCQUFnQixJQUFJLENBQUM3aEIsWUFBWSxDQUFDclMsU0FBUzYwQixjQUFjdmlCLFlBQVk7UUFDekUsSUFBSStoQixZQUFZbDNCLFVBQVNuRixZQUFZLENBQUNrOUIsZ0JBQWdCQztRQUN0RCxJQUFJYixTQUFTRCxVQUFVeFAsVUFBVSxDQUFDO1FBQ2xDMW5CLFVBQVNtQyxNQUFNLENBQUNtSCxXQUFXLENBQUM2dEI7UUFDNUJBLE9BQU8vckIsU0FBUyxDQUFDLENBQUM1RyxJQUFJbXpCLElBQUksQ0FBQ2x6QixJQUFJbXpCO1FBQy9CLzBCLFFBQVEwSixNQUFNLENBQUM0cUIsU0FBUyxnQkFBZ0I7UUFFeEMxa0IsU0FBU2hNLE9BQU8sQ0FBQzhOLENBQUFBO1lBQ2YsSUFBSSxPQUFPQSxNQUFNcEYsS0FBSyxLQUFLLFlBQVk7Z0JBQ3JDb0YsTUFBTXBGLEtBQUssQ0FBQ2dvQixRQUFRLEdBQUcsR0FBR1ksZ0JBQWdCQztZQUM1QztRQUNGLElBQUksZUFBZTtRQUVuQmgxQixJQUFJbXhCLFNBQVMsQ0FBQytDLFdBQVcsR0FBRyxHQUFHYSxnQkFBZ0JDLGlCQUFpQnh6QixJQUFJbXpCLElBQUlsekIsSUFBSW16QixJQUFJRyxnQkFBZ0JDO1FBQ2hHLElBQUksQ0FBQzFpQixhQUFhLENBQUN6UyxTQUFTazBCO0lBQzlCO0lBRUF4cUIsT0FBT25ELENBQUMsRUFBRSxDQUNWO0FBRUY7QUFDQXN1QixjQUFjdmlCLFlBQVksR0FBRztJQUFDO0lBQVU7SUFBYTtDQUFZO0FBRWpFLE1BQU04aUIsNEJBQTRCaG1CO0lBQ2hDbFMsWUFBWUMsU0FBUSxFQUFFdEUsSUFBSSxFQUFFd1csZ0JBQWdCLENBQUU7UUFDNUMsS0FBSyxDQUFDbFMsV0FBVXRFLE1BQU13VztRQUN0QixJQUFJLENBQUN0SyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNtTCw0QkFBNEI7SUFDbkM7SUFFQTVELE1BQU0vRixDQUFDLEVBQUVpdEIsRUFBRSxFQUFFQyxFQUFFLEVBQUU0QixNQUFNLEVBQUV2QyxPQUFPLEVBQUUsQ0FDbEM7QUFFRjtBQUVBLE1BQU13Qyw0QkFBNEJsbUI7SUFDaENsUyxhQUFjO1FBQ1osS0FBSyxJQUFJekY7UUFDVCxJQUFJLENBQUNzTixJQUFJLEdBQUc7SUFDZDtJQUVBdUgsTUFBTS9GLENBQUMsRUFBRWl0QixFQUFFLEVBQUVDLEVBQUUsRUFBRTRCLE1BQU0sRUFBRXZDLE9BQU8sRUFBRSxDQUNsQztBQUVGO0FBRUEsTUFBTXlDLDJCQUEyQm5tQjtJQUMvQmxTLGFBQWM7UUFDWixLQUFLLElBQUl6RjtRQUNULElBQUksQ0FBQ3NOLElBQUksR0FBRztJQUNkO0lBRUF1SCxNQUFNL0YsQ0FBQyxFQUFFaXRCLEVBQUUsRUFBRUMsRUFBRSxFQUFFNEIsTUFBTSxFQUFFdkMsT0FBTyxFQUFFLENBQ2xDO0FBRUY7QUFFQSxNQUFNMEMsOEJBQThCcG1CO0lBQ2xDbFMsWUFBWUMsU0FBUSxFQUFFdEUsSUFBSSxFQUFFd1csZ0JBQWdCLENBQUU7UUFDNUMsS0FBSyxDQUFDbFMsV0FBVXRFLE1BQU13VztRQUN0QixJQUFJLENBQUN0SyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUMwd0IsVUFBVSxHQUFHMTZCLEtBQUt3dEIsS0FBSyxDQUFDLElBQUksQ0FBQ2hvQixZQUFZLENBQUMsZ0JBQWdCaEMsU0FBUztRQUN4RSxJQUFJLENBQUMwMkIsbUJBQW1CLEdBQUcsSUFBSSxDQUFDUSxVQUFVO0lBQzVDO0lBRUFucEIsTUFBTW5NLEdBQUcsRUFBRXdCLENBQUMsRUFBRUMsQ0FBQyxFQUFFM0osS0FBSyxFQUFFQyxNQUFNLEVBQUU7UUFDOUIsSUFBSSxFQUNGaUYsVUFBQUEsU0FBUSxFQUNSczRCLFVBQVUsRUFDWCxHQUFHLElBQUk7UUFDUixJQUFJQyxPQUFPdjRCLFVBQVN0RixNQUFNLEdBQUdzRixVQUFTdEYsTUFBTSxDQUFDc0YsUUFBUSxDQUFDdTRCLElBQUksR0FBRztRQUM3RCxJQUFJMzhCLFNBQVNvSCxJQUFJcEgsTUFBTSxFQUFFLDJDQUEyQztRQUVwRUEsT0FBT29YLEVBQUUsR0FBR2hULFVBQVN3NEIsV0FBVztRQUVoQyxJQUFJRCxNQUFNO1lBQ1IzOEIsT0FBTzJLLEtBQUssQ0FBQ2t5QixPQUFPLEdBQUc7WUFDdkJGLEtBQUtHLFdBQVcsQ0FBQzk4QjtRQUNuQjtRQUVBMUIsNkRBQVVBLENBQUMwQixRQUFRNEksR0FBR0MsR0FBRzNKLE9BQU9DLFFBQVF1OUI7UUFFeEMsSUFBSUMsTUFBTTtZQUNSQSxLQUFLSSxXQUFXLENBQUMvOEI7UUFDbkI7SUFDRjtBQUVGO0FBRUEsTUFBTWc5QixxQkFBcUIzbUI7SUFDekJsUyxhQUFjO1FBQ1osS0FBSyxJQUFJekY7UUFDVCxJQUFJLENBQUNzTixJQUFJLEdBQUc7SUFDZDtBQUVGO0FBRUEsTUFBTWl4QixvQkFBb0I1bUI7SUFDeEJsUyxhQUFjO1FBQ1osS0FBSyxJQUFJekY7UUFDVCxJQUFJLENBQUNzTixJQUFJLEdBQUc7SUFDZDtBQUVGO0FBRUEsSUFBSWt4QixXQUFXO0lBQ2IsT0FBT3hUO0lBQ1AsUUFBUWlCO0lBQ1IsVUFBVU07SUFDVixXQUFXQztJQUNYLFFBQVFDO0lBQ1IsWUFBWUk7SUFDWixXQUFXQztJQUNYLFFBQVEzSjtJQUNSLFdBQVc0SjtJQUNYLFVBQVVPO0lBQ1YsUUFBUUs7SUFDUixrQkFBa0JpQjtJQUNsQixrQkFBa0JHO0lBQ2xCLFFBQVFLO0lBQ1IsV0FBV0c7SUFDWCxnQkFBZ0IwQjtJQUNoQixvQkFBb0JHO0lBQ3BCLFFBQVFHO0lBQ1IsYUFBYUU7SUFDYixpQkFBaUJHO0lBQ2pCLFNBQVM1SztJQUNULFFBQVFJO0lBQ1IsU0FBUzBEO0lBQ1QsUUFBUStHO0lBQ1IsS0FBS0U7SUFDTCxZQUFZa0I7SUFDWixTQUFTMEY7SUFDVCxLQUFLL0s7SUFDTCxVQUFVa007SUFDVixTQUFTSztJQUNULE9BQU9ZO0lBQ1AsUUFBUXlCO0lBQ1IsWUFBWVM7SUFDWixVQUFVRztJQUNWLGdCQUFnQk87SUFDaEIsZ0JBQWdCRTtJQUNoQixlQUFlQztJQUNmLGlCQUFpQmpDO0lBQ2pCLGtCQUFrQmtDO0lBQ2xCLFNBQVNPO0lBQ1QsUUFBUUM7QUFDVjtBQUVBLFNBQVNFLFVBQVV0TSxNQUFNLEVBQUVDLGNBQWM7SUFBSSxJQUFJQyxPQUFPNXdCLE9BQU80d0IsSUFBSSxDQUFDRjtJQUFTLElBQUkxd0IsT0FBTzZ3QixxQkFBcUIsRUFBRTtRQUFFLElBQUlDLFVBQVU5d0IsT0FBTzZ3QixxQkFBcUIsQ0FBQ0g7UUFBUyxJQUFJQyxnQkFBZ0I7WUFBRUcsVUFBVUEsUUFBUTVZLE1BQU0sQ0FBQyxTQUFVNlksR0FBRztnQkFBSSxPQUFPL3dCLE9BQU9neEIsd0JBQXdCLENBQUNOLFFBQVFLLEtBQUtFLFVBQVU7WUFBRTtRQUFJO1FBQUVMLEtBQUt6b0IsSUFBSSxDQUFDaUwsS0FBSyxDQUFDd2QsTUFBTUU7SUFBVTtJQUFFLE9BQU9GO0FBQU07QUFFMVYsU0FBU3FNLGdCQUFnQjlMLE1BQU07SUFBSSxJQUFLLElBQUl4cEIsSUFBSSxHQUFHQSxJQUFJcEosVUFBVUMsTUFBTSxFQUFFbUosSUFBSztRQUFFLElBQUl5cEIsU0FBUzd5QixTQUFTLENBQUNvSixFQUFFLElBQUksT0FBT3BKLFNBQVMsQ0FBQ29KLEVBQUUsR0FBRyxDQUFDO1FBQUcsSUFBSUEsSUFBSSxHQUFHO1lBQUVxMUIsVUFBVWg5QixPQUFPb3hCLFNBQVMsTUFBTTFtQixPQUFPLENBQUMsU0FBVWlOLEdBQUc7Z0JBQUk1WixrRUFBZUEsQ0FBQ296QixRQUFReFosS0FBS3laLE1BQU0sQ0FBQ3paLElBQUk7WUFBRztRQUFJLE9BQU8sSUFBSTNYLE9BQU9xeEIseUJBQXlCLEVBQUU7WUFBRXJ4QixPQUFPc3hCLGdCQUFnQixDQUFDSCxRQUFRbnhCLE9BQU9xeEIseUJBQXlCLENBQUNEO1FBQVUsT0FBTztZQUFFNEwsVUFBVWg5QixPQUFPb3hCLFNBQVMxbUIsT0FBTyxDQUFDLFNBQVVpTixHQUFHO2dCQUFJM1gsT0FBT3V4QixjQUFjLENBQUNKLFFBQVF4WixLQUFLM1gsT0FBT2d4Qix3QkFBd0IsQ0FBQ0ksUUFBUXpaO1lBQU87UUFBSTtJQUFFO0lBQUUsT0FBT3daO0FBQVE7QUFFM2hCLFNBQVNyeUIsYUFBYUMsS0FBSyxFQUFFQyxNQUFNO0lBQ2pDLElBQUlhLFNBQVNvRSxTQUFTd1UsYUFBYSxDQUFDO0lBQ3BDNVksT0FBT2QsS0FBSyxHQUFHQTtJQUNmYyxPQUFPYixNQUFNLEdBQUdBO0lBQ2hCLE9BQU9hO0FBQ1Q7QUFFQSxTQUFTWCxZQUFZbzdCLEVBQUU7SUFDckIsT0FBTzRDLGFBQWE5cEIsS0FBSyxDQUFDLElBQUksRUFBRTdVO0FBQ2xDO0FBRUEsU0FBUzIrQjtJQUNQQSxlQUFlcC9CLG9FQUFpQkEsQ0FBQyxVQUFXdTdCLEdBQUc7UUFDN0MsSUFBSThELHVCQUF1QjUrQixVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRztRQUMvRixJQUFJaTVCLFFBQVF2ekIsU0FBU3dVLGFBQWEsQ0FBQztRQUVuQyxJQUFJMGtCLHNCQUFzQjtZQUN4QjNGLE1BQU00RixXQUFXLEdBQUc7UUFDdEI7UUFFQSxPQUFPLElBQUlud0IsUUFBUSxDQUFDQyxTQUFTbXdCO1lBQzNCN0YsTUFBTThGLE1BQU0sR0FBRztnQkFDYnB3QixRQUFRc3FCO1lBQ1Y7WUFFQUEsTUFBTStGLE9BQU8sR0FBRyxDQUFDQyxRQUFRQyxTQUFTQyxTQUFTQyxRQUFRakc7Z0JBQ2pEMkYsT0FBTzNGO1lBQ1Q7WUFFQUYsTUFBTTZCLEdBQUcsR0FBR0E7UUFDZDtJQUNGO0lBQ0EsT0FBTzZELGFBQWE5cEIsS0FBSyxDQUFDLElBQUksRUFBRTdVO0FBQ2xDO0FBRUEsTUFBTXEvQjtJQUNKNTVCLFlBQVkrekIsS0FBSyxDQUFFO1FBQ2pCLElBQUksRUFDRnJ5QixhQUFhLEVBQUUsRUFDZkUsU0FBUyxFQUFFLEVBQ1g5RyxlQUFlOCtCLFNBQVM5K0IsWUFBWSxFQUNwQ0ksY0FBYzArQixTQUFTMStCLFdBQVcsRUFDbENpK0Isb0JBQW9CLEVBQ3JCLEdBQUc1K0IsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUtFLFlBQVlGLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUN6RSxJQUFJLENBQUN3NUIsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ254QixXQUFXLEdBQUc1RyxPQUFPcVcsTUFBTSxDQUFDO1FBQ2pDLElBQUksQ0FBQ0MsTUFBTSxHQUFHdFcsT0FBT3FXLE1BQU0sQ0FBQztRQUM1QixJQUFJLENBQUNFLGlCQUFpQixHQUFHdlcsT0FBT3FXLE1BQU0sQ0FBQztRQUN2QyxJQUFJLENBQUNpaEIsTUFBTSxHQUFHLEVBQUU7UUFDaEIsSUFBSSxDQUFDaUIsS0FBSyxHQUFHLEVBQUU7UUFDZixJQUFJLENBQUNzRixXQUFXLEdBQUcsRUFBRTtRQUNyQixJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUMxM0IsTUFBTSxHQUFHMnhCLE1BQU0zeEIsTUFBTTtRQUMxQixJQUFJLENBQUNWLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDRSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDOUcsWUFBWSxHQUFHQTtRQUNwQixJQUFJLENBQUNJLFdBQVcsR0FBRyxJQUFJLENBQUM2K0IsZUFBZSxDQUFDNytCLGFBQWFpK0I7UUFDckQsSUFBSSxDQUFDLzJCLE1BQU0sQ0FBQ3lHLElBQUksQ0FBQyxJQUFJLENBQUNteEIsY0FBYyxDQUFDajBCLElBQUksQ0FBQyxJQUFJO1FBQzlDLElBQUksQ0FBQzNELE1BQU0sQ0FBQ3lHLElBQUksQ0FBQyxJQUFJLENBQUNveEIsYUFBYSxDQUFDbDBCLElBQUksQ0FBQyxJQUFJO0lBQy9DO0lBRUFnMEIsZ0JBQWdCNytCLFdBQVcsRUFBRWkrQixvQkFBb0IsRUFBRTtRQUNqRCxJQUFJLE9BQU9BLHlCQUF5QixXQUFXO1lBQzdDLE9BQU8sQ0FBQy9MLFFBQVE4TSw0QkFBOEJoL0IsWUFBWWt5QixRQUFRLE9BQU84TSw4QkFBOEIsWUFBWUEsNEJBQTRCZjtRQUNqSjtRQUVBLE9BQU9qK0I7SUFDVDtJQUVBLElBQUlQLFNBQVM7UUFDWCxPQUFPLElBQUksQ0FBQ3lILE1BQU0sQ0FBQ3pILE1BQU07SUFDM0I7SUFFQSxJQUFJVSxRQUFRO1FBQ1YsT0FBTyxJQUFJLENBQUMrRyxNQUFNLENBQUMvRyxLQUFLO0lBQzFCO0lBRUEsSUFBSTRILE1BQU07UUFDUixPQUFPLElBQUksQ0FBQ2IsTUFBTSxDQUFDYSxHQUFHO0lBQ3hCO0lBRUEsSUFBSXJCLFNBQVM7UUFDWCxJQUFJLEVBQ0ZpNEIsV0FBVyxFQUNaLEdBQUcsSUFBSTtRQUNSLE9BQU9BLFdBQVcsQ0FBQ0EsWUFBWXIvQixNQUFNLEdBQUcsRUFBRTtJQUM1QztJQUVBLElBQUlvSCxPQUFPMUIsS0FBSyxFQUFFO1FBQ2hCLElBQUksRUFDRjI1QixXQUFXLEVBQ1osR0FBRyxJQUFJO1FBQ1JBLFlBQVkxMUIsSUFBSSxDQUFDakU7SUFDbkI7SUFFQXVkLFlBQVk7UUFDVixJQUFJLEVBQ0ZvYyxXQUFXLEVBQ1osR0FBRyxJQUFJO1FBQ1JBLFlBQVl4MUIsR0FBRztJQUNqQjtJQUVBbzBCLGNBQWM7UUFDWixPQUFPLFFBQVFwckIsTUFBTSxDQUFDLEVBQUUsSUFBSSxDQUFDeXNCLFFBQVE7SUFDdkM7SUFFQUUsaUJBQWlCO1FBQ2YsT0FBTyxJQUFJLENBQUMxRyxNQUFNLENBQUNscUIsS0FBSyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFOHBCLE1BQU07SUFDeEM7SUFFQThHLGdCQUFnQjtRQUNkLE9BQU8sSUFBSSxDQUFDMUYsS0FBSyxDQUFDbnJCLEtBQUssQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRThwQixNQUFNO0lBQ3ZDO0lBRUFnSCxzQkFBc0JsNkIsU0FBUSxFQUFFO1FBQzlCLElBQUlnMEIsa0JBQWtCLElBQUksQ0FBQ3hmLGFBQWEsQ0FBQ3hVLFVBQVNnMEIsZUFBZTtRQUNqRUEsZ0JBQWdCek8sSUFBSSxHQUFHO1FBQ3ZCeU8sZ0JBQWdCamhCLDRCQUE0QjtRQUM1QyxJQUFJLENBQUNpaEIsZUFBZSxHQUFHQTtRQUN2QixPQUFPQTtJQUNUO0lBRUF4ZixjQUFjOVksSUFBSSxFQUFFO1FBQ2xCLElBQUl5K0IsY0FBY3orQixLQUFLb1gsUUFBUSxDQUFDMVcsT0FBTyxDQUFDLFdBQVc7UUFDbkQsSUFBSWcrQixjQUFjVCxTQUFTVSxZQUFZLENBQUNGLFlBQVk7UUFFcEQsSUFBSSxPQUFPQyxnQkFBZ0IsYUFBYTtZQUN0QyxPQUFPLElBQUlBLFlBQVksSUFBSSxFQUFFMStCO1FBQy9CO1FBRUEsT0FBTyxJQUFJZ2EsZUFBZSxJQUFJLEVBQUVoYTtJQUNsQztJQUVBMlgsZUFBZTNYLElBQUksRUFBRTtRQUNuQixPQUFPLElBQUkycEIsU0FBUyxJQUFJLEVBQUUzcEI7SUFDNUI7SUFFQWlPLFdBQVcyd0IsTUFBTSxFQUFFO1FBQ2pCLElBQUksQ0FBQ240QixNQUFNLENBQUN3SCxVQUFVLENBQUNxdkIsZ0JBQWdCO1lBQ3JDaDVCLFVBQVUsSUFBSTtRQUNoQixHQUFHczZCO0lBQ0w7QUFFRjtBQUNBWCxTQUFTOStCLFlBQVksR0FBR0E7QUFDeEI4K0IsU0FBUzErQixXQUFXLEdBQUdBO0FBQ3ZCMCtCLFNBQVNVLFlBQVksR0FBR3ZCO0FBRXhCLFNBQVN5QixRQUFROU4sTUFBTSxFQUFFQyxjQUFjO0lBQUksSUFBSUMsT0FBTzV3QixPQUFPNHdCLElBQUksQ0FBQ0Y7SUFBUyxJQUFJMXdCLE9BQU82d0IscUJBQXFCLEVBQUU7UUFBRSxJQUFJQyxVQUFVOXdCLE9BQU82d0IscUJBQXFCLENBQUNIO1FBQVMsSUFBSUMsZ0JBQWdCO1lBQUVHLFVBQVVBLFFBQVE1WSxNQUFNLENBQUMsU0FBVTZZLEdBQUc7Z0JBQUksT0FBTy93QixPQUFPZ3hCLHdCQUF3QixDQUFDTixRQUFRSyxLQUFLRSxVQUFVO1lBQUU7UUFBSTtRQUFFTCxLQUFLem9CLElBQUksQ0FBQ2lMLEtBQUssQ0FBQ3dkLE1BQU1FO0lBQVU7SUFBRSxPQUFPRjtBQUFNO0FBRXhWLFNBQVM2TixjQUFjdE4sTUFBTTtJQUFJLElBQUssSUFBSXhwQixJQUFJLEdBQUdBLElBQUlwSixVQUFVQyxNQUFNLEVBQUVtSixJQUFLO1FBQUUsSUFBSXlwQixTQUFTN3lCLFNBQVMsQ0FBQ29KLEVBQUUsSUFBSSxPQUFPcEosU0FBUyxDQUFDb0osRUFBRSxHQUFHLENBQUM7UUFBRyxJQUFJQSxJQUFJLEdBQUc7WUFBRTYyQixRQUFReCtCLE9BQU9veEIsU0FBUyxNQUFNMW1CLE9BQU8sQ0FBQyxTQUFVaU4sR0FBRztnQkFBSTVaLGtFQUFlQSxDQUFDb3pCLFFBQVF4WixLQUFLeVosTUFBTSxDQUFDelosSUFBSTtZQUFHO1FBQUksT0FBTyxJQUFJM1gsT0FBT3F4Qix5QkFBeUIsRUFBRTtZQUFFcnhCLE9BQU9zeEIsZ0JBQWdCLENBQUNILFFBQVFueEIsT0FBT3F4Qix5QkFBeUIsQ0FBQ0Q7UUFBVSxPQUFPO1lBQUVvTixRQUFReCtCLE9BQU9veEIsU0FBUzFtQixPQUFPLENBQUMsU0FBVWlOLEdBQUc7Z0JBQUkzWCxPQUFPdXhCLGNBQWMsQ0FBQ0osUUFBUXhaLEtBQUszWCxPQUFPZ3hCLHdCQUF3QixDQUFDSSxRQUFRelo7WUFBTztRQUFJO0lBQUU7SUFBRSxPQUFPd1o7QUFBUTtBQUNyaEI7O0NBRUMsR0FFRCxNQUFNdU47SUFDSjs7Ozs7R0FLQyxHQUNEMTZCLFlBQVlpRCxHQUFHLEVBQUU0d0IsR0FBRyxDQUFFO1FBQ3BCLElBQUk4RyxVQUFVcGdDLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDbkYsSUFBSSxDQUFDbVUsTUFBTSxHQUFHLElBQUlOLE9BQU91c0I7UUFDekIsSUFBSSxDQUFDdjRCLE1BQU0sR0FBRyxJQUFJNkYsT0FBT2hGLEtBQUswM0I7UUFDOUIsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO1FBQ2YsSUFBSTE2QixZQUFXLElBQUkyNUIsU0FBUyxJQUFJLEVBQUVlO1FBQ2xDLElBQUkxRyxrQkFBa0JoMEIsVUFBU2s2QixxQkFBcUIsQ0FBQ3RHO1FBQ3JELElBQUksQ0FBQzV6QixRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ2cwQixlQUFlLEdBQUdBO0lBQ3pCO0lBQ0E7Ozs7OztHQU1DLEdBR0QsT0FBT3BoQixLQUFLNVAsR0FBRyxFQUFFNHdCLEdBQUcsRUFBRTtRQUNwQixJQUFJK0csYUFBYXJnQztRQUNqQixPQUFPVCxvRUFBaUJBLENBQUM7WUFDdkIsSUFBSTZnQyxVQUFVQyxXQUFXcGdDLE1BQU0sR0FBRyxLQUFLb2dDLFVBQVUsQ0FBQyxFQUFFLEtBQUtuZ0MsWUFBWW1nQyxVQUFVLENBQUMsRUFBRSxHQUFHLENBQUM7WUFDdEYsSUFBSWxzQixTQUFTLElBQUlOLE9BQU91c0I7WUFDeEIsSUFBSW5HLGNBQWMsTUFBTTlsQixPQUFPL0osS0FBSyxDQUFDa3ZCO1lBQ3JDLE9BQU8sSUFBSTZHLE1BQU16M0IsS0FBS3V4QixhQUFhbUc7UUFDckM7SUFDRjtJQUNBOzs7Ozs7R0FNQyxHQUdELE9BQU9FLFdBQVc1M0IsR0FBRyxFQUFFNHdCLEdBQUcsRUFBRTtRQUMxQixJQUFJOEcsVUFBVXBnQyxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ25GLElBQUltVSxTQUFTLElBQUlOLE9BQU91c0I7UUFDeEIsSUFBSW5HLGNBQWM5bEIsT0FBT0gsZUFBZSxDQUFDc2xCO1FBQ3pDLE9BQU8sSUFBSTZHLE1BQU16M0IsS0FBS3V4QixhQUFhbUc7SUFDckM7SUFDQTs7Ozs7O0dBTUMsR0FHREcsS0FBSzczQixHQUFHLEVBQUU0d0IsR0FBRyxFQUFFO1FBQ2IsSUFBSThHLFVBQVVwZ0MsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUtFLFlBQVlGLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUNuRixPQUFPbWdDLE1BQU03bkIsSUFBSSxDQUFDNVAsS0FBSzR3QixLQUFLNEcsY0FBY0EsY0FBYyxDQUFDLEdBQUcsSUFBSSxDQUFDRSxPQUFPLEdBQUdBO0lBQzdFO0lBQ0E7Ozs7OztHQU1DLEdBR0QzRyxXQUFXL3dCLEdBQUcsRUFBRTR3QixHQUFHLEVBQUU7UUFDbkIsSUFBSThHLFVBQVVwZ0MsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUtFLFlBQVlGLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUNuRixPQUFPbWdDLE1BQU1HLFVBQVUsQ0FBQzUzQixLQUFLNHdCLEtBQUs0RyxjQUFjQSxjQUFjLENBQUMsR0FBRyxJQUFJLENBQUNFLE9BQU8sR0FBR0E7SUFDbkY7SUFDQTs7O0dBR0MsR0FHRDV4QixRQUFRO1FBQ04sT0FBTyxJQUFJLENBQUMzRyxNQUFNLENBQUMyRyxLQUFLO0lBQzFCO0lBQ0E7OztHQUdDLEdBR0RJLFVBQVU7UUFDUixPQUFPLElBQUksQ0FBQy9HLE1BQU0sQ0FBQytHLE9BQU87SUFDNUI7SUFDQTs7O0dBR0MsR0FHRHFELFNBQVM7UUFDUCxJQUFJdXVCLGNBQWN4Z0MsV0FDZCtULFFBQVEsSUFBSTtRQUVoQixPQUFPeFUsb0VBQWlCQSxDQUFDO1lBQ3ZCLElBQUk2Z0MsVUFBVUksWUFBWXZnQyxNQUFNLEdBQUcsS0FBS3VnQyxXQUFXLENBQUMsRUFBRSxLQUFLdGdDLFlBQVlzZ0MsV0FBVyxDQUFDLEVBQUUsR0FBRyxDQUFDO1lBRXpGenNCLE1BQU1wSSxLQUFLLENBQUN1MEIsY0FBYztnQkFDeEJ6dUIsY0FBYztnQkFDZHBSLGlCQUFpQjtnQkFDakJDLGFBQWE7WUFDZixHQUFHOC9CO1lBRUgsTUFBTXJzQixNQUFNdkYsS0FBSztZQUVqQnVGLE1BQU1qSSxJQUFJO1FBQ1o7SUFDRjtJQUNBOzs7R0FHQyxHQUdESCxRQUFRO1FBQ04sSUFBSXkwQixVQUFVcGdDLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDbkYsSUFBSSxFQUNGMDVCLGVBQWUsRUFDZjd4QixNQUFNLEVBQ051NEIsU0FBU0ssV0FBVyxFQUNyQixHQUFHLElBQUk7UUFDUjU0QixPQUFPOEQsS0FBSyxDQUFDK3RCLGlCQUFpQndHLGNBQWNBLGNBQWM7WUFDeER6dUIsY0FBYztRQUNoQixHQUFHZ3ZCLGNBQWNMO0lBQ25CO0lBQ0E7O0dBRUMsR0FHRHQwQixPQUFPO1FBQ0wsSUFBSSxDQUFDakUsTUFBTSxDQUFDaUUsSUFBSTtJQUNsQjtJQUNBOzs7OztHQUtDLEdBR0QyZixPQUFPanJCLEtBQUssRUFBRTtRQUNaLElBQUlDLFNBQVNULFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHUTtRQUNqRixJQUFJa3JCLHNCQUFzQjFyQixVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRztRQUM5RixJQUFJLENBQUMwNUIsZUFBZSxDQUFDak8sTUFBTSxDQUFDanJCLE9BQU9DLFFBQVFpckI7SUFDN0M7QUFFRjtBQUUwb0MsQ0FDMW9DLDR0UkFBNHRSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV3YnVpbGQvLi9ub2RlX21vZHVsZXMvY2FudmcvbGliL2luZGV4LmVzLmpzPzBkZDEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICdjb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZS5qcyc7XG5pbXBvcnQgX2FzeW5jVG9HZW5lcmF0b3IgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yJztcbmltcG9ydCAnY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5tYXRjaC5qcyc7XG5pbXBvcnQgJ2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZS5qcyc7XG5pbXBvcnQgJ2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3RhcnRzLXdpdGguanMnO1xuaW1wb3J0ICdjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3IuanMnO1xuaW1wb3J0ICdjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qcyc7XG5pbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHknO1xuaW1wb3J0ICdjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkucmVkdWNlLmpzJztcbmltcG9ydCAnY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5lbmRzLXdpdGguanMnO1xuaW1wb3J0ICdjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0LmpzJztcbmltcG9ydCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZnJvbSAncmFmJztcbmltcG9ydCAnY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy50cmltLmpzJztcbmltcG9ydCBSR0JDb2xvciBmcm9tICdyZ2Jjb2xvcic7XG5pbXBvcnQgJ2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmRleC1vZi5qcyc7XG5pbXBvcnQgJ2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaW5jbHVkZXMuanMnO1xuaW1wb3J0ICdjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkucmV2ZXJzZS5qcyc7XG5pbXBvcnQgeyBTVkdQYXRoRGF0YSB9IGZyb20gJ3N2Zy1wYXRoZGF0YSc7XG5pbXBvcnQgJ2NvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nLmpzJztcbmltcG9ydCB7IGNhbnZhc1JHQkEgfSBmcm9tICdzdGFja2JsdXItY2FudmFzJztcblxuLyoqXHJcbiAqIE9wdGlvbnMgcHJlc2V0IGZvciBgT2Zmc2NyZWVuQ2FudmFzYC5cclxuICogQHBhcmFtIGNvbmZpZyAtIFByZXNldCByZXF1aXJlbWVudHMuXHJcbiAqIEBwYXJhbSBjb25maWcuRE9NUGFyc2VyIC0gWE1ML0hUTUwgcGFyc2VyIGZyb20gc3RyaW5nIGludG8gRE9NIERvY3VtZW50LlxyXG4gKiBAcmV0dXJucyBQcmVzZXQgb2JqZWN0LlxyXG4gKi9cbmZ1bmN0aW9uIG9mZnNjcmVlbigpIHtcbiAgdmFyIHtcbiAgICBET01QYXJzZXI6IERPTVBhcnNlckZhbGxiYWNrXG4gIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICB2YXIgcHJlc2V0ID0ge1xuICAgIHdpbmRvdzogbnVsbCxcbiAgICBpZ25vcmVBbmltYXRpb246IHRydWUsXG4gICAgaWdub3JlTW91c2U6IHRydWUsXG4gICAgRE9NUGFyc2VyOiBET01QYXJzZXJGYWxsYmFjayxcblxuICAgIGNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICByZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgY3JlYXRlSW1hZ2UodXJsKSB7XG4gICAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdmFyIHJlc3BvbnNlID0geWllbGQgZmV0Y2godXJsKTtcbiAgICAgICAgdmFyIGJsb2IgPSB5aWVsZCByZXNwb25zZS5ibG9iKCk7XG4gICAgICAgIHZhciBpbWcgPSB5aWVsZCBjcmVhdGVJbWFnZUJpdG1hcChibG9iKTtcbiAgICAgICAgcmV0dXJuIGltZztcbiAgICAgIH0pKCk7XG4gICAgfVxuXG4gIH07XG5cbiAgaWYgKHR5cGVvZiBET01QYXJzZXIgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBET01QYXJzZXJGYWxsYmFjayA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHByZXNldCwgJ0RPTVBhcnNlcicpO1xuICB9XG5cbiAgcmV0dXJuIHByZXNldDtcbn1cblxuLyoqXHJcbiAqIE9wdGlvbnMgcHJlc2V0IGZvciBgbm9kZS1jYW52YXNgLlxyXG4gKiBAcGFyYW0gY29uZmlnIC0gUHJlc2V0IHJlcXVpcmVtZW50cy5cclxuICogQHBhcmFtIGNvbmZpZy5ET01QYXJzZXIgLSBYTUwvSFRNTCBwYXJzZXIgZnJvbSBzdHJpbmcgaW50byBET00gRG9jdW1lbnQuXHJcbiAqIEBwYXJhbSBjb25maWcuY2FudmFzIC0gYG5vZGUtY2FudmFzYCBleHBvcnRzLlxyXG4gKiBAcGFyYW0gY29uZmlnLmZldGNoIC0gV0hBVFdHLWNvbXBhdGlibGUgYGZldGNoYCBmdW5jdGlvbi5cclxuICogQHJldHVybnMgUHJlc2V0IG9iamVjdC5cclxuICovXG5mdW5jdGlvbiBub2RlKF9yZWYpIHtcbiAgdmFyIHtcbiAgICBET01QYXJzZXIsXG4gICAgY2FudmFzLFxuICAgIGZldGNoXG4gIH0gPSBfcmVmO1xuICByZXR1cm4ge1xuICAgIHdpbmRvdzogbnVsbCxcbiAgICBpZ25vcmVBbmltYXRpb246IHRydWUsXG4gICAgaWdub3JlTW91c2U6IHRydWUsXG4gICAgRE9NUGFyc2VyLFxuICAgIGZldGNoLFxuICAgIGNyZWF0ZUNhbnZhczogY2FudmFzLmNyZWF0ZUNhbnZhcyxcbiAgICBjcmVhdGVJbWFnZTogY2FudmFzLmxvYWRJbWFnZVxuICB9O1xufVxuXG52YXIgaW5kZXggPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0b2Zmc2NyZWVuOiBvZmZzY3JlZW4sXG5cdG5vZGU6IG5vZGVcbn0pO1xuXG4vKipcclxuICogSFRNTC1zYWZlIGNvbXByZXNzIHdoaXRlLXNwYWNlcy5cclxuICogQHBhcmFtIHN0ciAtIFN0cmluZyB0byBjb21wcmVzcy5cclxuICogQHJldHVybnMgU3RyaW5nLlxyXG4gKi9cbmZ1bmN0aW9uIGNvbXByZXNzU3BhY2VzKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyg/IVxcdTMwMDApXFxzKy9nbSwgJyAnKTtcbn1cbi8qKlxyXG4gKiBIVE1MLXNhZmUgbGVmdCB0cmltLlxyXG4gKiBAcGFyYW0gc3RyIC0gU3RyaW5nIHRvIHRyaW0uXHJcbiAqIEByZXR1cm5zIFN0cmluZy5cclxuICovXG5cbmZ1bmN0aW9uIHRyaW1MZWZ0KHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15bXFxuIFxcdF0rLywgJycpO1xufVxuLyoqXHJcbiAqIEhUTUwtc2FmZSByaWdodCB0cmltLlxyXG4gKiBAcGFyYW0gc3RyIC0gU3RyaW5nIHRvIHRyaW0uXHJcbiAqIEByZXR1cm5zIFN0cmluZy5cclxuICovXG5cbmZ1bmN0aW9uIHRyaW1SaWdodChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXFxuIFxcdF0rJC8sICcnKTtcbn1cbi8qKlxyXG4gKiBTdHJpbmcgdG8gbnVtYmVycyBhcnJheS5cclxuICogQHBhcmFtIHN0ciAtIE51bWJlcnMgc3RyaW5nLlxyXG4gKiBAcmV0dXJucyBOdW1iZXJzIGFycmF5LlxyXG4gKi9cblxuZnVuY3Rpb24gdG9OdW1iZXJzKHN0cikge1xuICB2YXIgbWF0Y2hlcyA9IChzdHIgfHwgJycpLm1hdGNoKC8tPyhcXGQrKD86XFwuXFxkKig/OltlRV1bKy1dP1xcZCspPyk/fFxcLlxcZCspKD89XFxEfCQpL2dtKSB8fCBbXTtcbiAgcmV0dXJuIG1hdGNoZXMubWFwKHBhcnNlRmxvYXQpO1xufSAvLyBNaWNyb3NvZnQgRWRnZSBmaXhcblxudmFyIGFsbFVwcGVyY2FzZSA9IC9eW0EtWi1dKyQvO1xuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhdHRyaWJ1dGUgbmFtZS5cclxuICogQHBhcmFtIG5hbWUgLSBBdHRyaWJ1dGUgbmFtZS5cclxuICogQHJldHVybnMgTm9ybWFsaXplZCBhdHRyaWJ1dGUgbmFtZS5cclxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUobmFtZSkge1xuICBpZiAoYWxsVXBwZXJjYXNlLnRlc3QobmFtZSkpIHtcbiAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgcmV0dXJuIG5hbWU7XG59XG4vKipcclxuICogUGFyc2UgZXh0ZXJuYWwgVVJMLlxyXG4gKiBAcGFyYW0gdXJsIC0gQ1NTIHVybCBzdHJpbmcuXHJcbiAqIEByZXR1cm5zIFBhcnNlZCBVUkwuXHJcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZUV4dGVybmFsVXJsKHVybCkge1xuICAvLyAgICAgICAgICAgICAgICAgICAgICBzaW5nbGUgcXVvdGVzIFsyXVxuICAvLyAgICAgICAgICAgICAgICAgICAgICB2ICAgICAgICAgZG91YmxlIHF1b3RlcyBbM11cbiAgLy8gICAgICAgICAgICAgICAgICAgICAgdiAgICAgICAgIHYgICAgICAgICBubyBxdW90ZXMgWzRdXG4gIC8vICAgICAgICAgICAgICAgICAgICAgIHYgICAgICAgICB2ICAgICAgICAgdlxuICB2YXIgdXJsTWF0Y2ggPSAvdXJsXFwoKCcoW14nXSspJ3xcIihbXlwiXSspXCJ8KFteJ1wiKV0rKSlcXCkvLmV4ZWModXJsKSB8fCBbXTtcbiAgcmV0dXJuIHVybE1hdGNoWzJdIHx8IHVybE1hdGNoWzNdIHx8IHVybE1hdGNoWzRdO1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybSBmbG9hdHMgdG8gaW50ZWdlcnMgaW4gcmdiIGNvbG9ycy5cclxuICogQHBhcmFtIGNvbG9yIC0gQ29sb3IgdG8gbm9ybWFsaXplLlxyXG4gKiBAcmV0dXJucyBOb3JtYWxpemVkIGNvbG9yLlxyXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplQ29sb3IoY29sb3IpIHtcbiAgaWYgKCFjb2xvci5zdGFydHNXaXRoKCdyZ2InKSkge1xuICAgIHJldHVybiBjb2xvcjtcbiAgfVxuXG4gIHZhciByZ2JQYXJ0cyA9IDM7XG4gIHZhciBub3JtYWxpemVkQ29sb3IgPSBjb2xvci5yZXBsYWNlKC9cXGQrKFxcLlxcZCspPy9nLCAobnVtLCBpc0Zsb2F0KSA9PiByZ2JQYXJ0cy0tICYmIGlzRmxvYXQgPyBTdHJpbmcoTWF0aC5yb3VuZChwYXJzZUZsb2F0KG51bSkpKSA6IG51bSk7XG4gIHJldHVybiBub3JtYWxpemVkQ29sb3I7XG59XG5cbi8vIHNsaWdodGx5IG1vZGlmaWVkIHZlcnNpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL2tlZWdhbnN0cmVldC9zcGVjaWZpY2l0eS9ibG9iL21hc3Rlci9zcGVjaWZpY2l0eS5qc1xudmFyIGF0dHJpYnV0ZVJlZ2V4ID0gLyhcXFtbXlxcXV0rXFxdKS9nO1xudmFyIGlkUmVnZXggPSAvKCNbXlxccys+fi5bOl0rKS9nO1xudmFyIGNsYXNzUmVnZXggPSAvKFxcLlteXFxzKz5+Lls6XSspL2c7XG52YXIgcHNldWRvRWxlbWVudFJlZ2V4ID0gLyg6OlteXFxzKz5+Lls6XSt8OmZpcnN0LWxpbmV8OmZpcnN0LWxldHRlcnw6YmVmb3JlfDphZnRlcikvZ2k7XG52YXIgcHNldWRvQ2xhc3NXaXRoQnJhY2tldHNSZWdleCA9IC8oOltcXHctXStcXChbXildKlxcKSkvZ2k7XG52YXIgcHNldWRvQ2xhc3NSZWdleCA9IC8oOlteXFxzKz5+Lls6XSspL2c7XG52YXIgZWxlbWVudFJlZ2V4ID0gLyhbXlxccys+fi5bOl0rKS9nO1xuXG5mdW5jdGlvbiBmaW5kU2VsZWN0b3JNYXRjaChzZWxlY3RvciwgcmVnZXgpIHtcbiAgdmFyIG1hdGNoZXMgPSByZWdleC5leGVjKHNlbGVjdG9yKTtcblxuICBpZiAoIW1hdGNoZXMpIHtcbiAgICByZXR1cm4gW3NlbGVjdG9yLCAwXTtcbiAgfVxuXG4gIHJldHVybiBbc2VsZWN0b3IucmVwbGFjZShyZWdleCwgJyAnKSwgbWF0Y2hlcy5sZW5ndGhdO1xufVxuLyoqXHJcbiAqIE1lYXN1cmUgc2VsZWN0b3Igc3BlY2lmaWNpdHkuXHJcbiAqIEBwYXJhbSBzZWxlY3RvciAtIFNlbGVjdG9yIHRvIG1lYXN1cmUuXHJcbiAqIEByZXR1cm5zIFNwZWNpZmljaXR5LlxyXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRTZWxlY3RvclNwZWNpZmljaXR5KHNlbGVjdG9yKSB7XG4gIHZhciBzcGVjaWZpY2l0eSA9IFswLCAwLCAwXTtcbiAgdmFyIGN1cnJlbnRTZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoLzpub3RcXCgoW14pXSopXFwpL2csICcgICAgICQxICcpLnJlcGxhY2UoL3tbXFxzXFxTXSovZ20sICcgJyk7XG4gIHZhciBkZWx0YSA9IDA7XG4gIFtjdXJyZW50U2VsZWN0b3IsIGRlbHRhXSA9IGZpbmRTZWxlY3Rvck1hdGNoKGN1cnJlbnRTZWxlY3RvciwgYXR0cmlidXRlUmVnZXgpO1xuICBzcGVjaWZpY2l0eVsxXSArPSBkZWx0YTtcbiAgW2N1cnJlbnRTZWxlY3RvciwgZGVsdGFdID0gZmluZFNlbGVjdG9yTWF0Y2goY3VycmVudFNlbGVjdG9yLCBpZFJlZ2V4KTtcbiAgc3BlY2lmaWNpdHlbMF0gKz0gZGVsdGE7XG4gIFtjdXJyZW50U2VsZWN0b3IsIGRlbHRhXSA9IGZpbmRTZWxlY3Rvck1hdGNoKGN1cnJlbnRTZWxlY3RvciwgY2xhc3NSZWdleCk7XG4gIHNwZWNpZmljaXR5WzFdICs9IGRlbHRhO1xuICBbY3VycmVudFNlbGVjdG9yLCBkZWx0YV0gPSBmaW5kU2VsZWN0b3JNYXRjaChjdXJyZW50U2VsZWN0b3IsIHBzZXVkb0VsZW1lbnRSZWdleCk7XG4gIHNwZWNpZmljaXR5WzJdICs9IGRlbHRhO1xuICBbY3VycmVudFNlbGVjdG9yLCBkZWx0YV0gPSBmaW5kU2VsZWN0b3JNYXRjaChjdXJyZW50U2VsZWN0b3IsIHBzZXVkb0NsYXNzV2l0aEJyYWNrZXRzUmVnZXgpO1xuICBzcGVjaWZpY2l0eVsxXSArPSBkZWx0YTtcbiAgW2N1cnJlbnRTZWxlY3RvciwgZGVsdGFdID0gZmluZFNlbGVjdG9yTWF0Y2goY3VycmVudFNlbGVjdG9yLCBwc2V1ZG9DbGFzc1JlZ2V4KTtcbiAgc3BlY2lmaWNpdHlbMV0gKz0gZGVsdGE7XG4gIGN1cnJlbnRTZWxlY3RvciA9IGN1cnJlbnRTZWxlY3Rvci5yZXBsYWNlKC9bKlxccys+fl0vZywgJyAnKS5yZXBsYWNlKC9bIy5dL2csICcgJyk7XG4gIFtjdXJyZW50U2VsZWN0b3IsIGRlbHRhXSA9IGZpbmRTZWxlY3Rvck1hdGNoKGN1cnJlbnRTZWxlY3RvciwgZWxlbWVudFJlZ2V4KTsgLy8gbGd0bSBbanMvdXNlbGVzcy1hc3NpZ25tZW50LXRvLWxvY2FsXVxuXG4gIHNwZWNpZmljaXR5WzJdICs9IGRlbHRhO1xuICByZXR1cm4gc3BlY2lmaWNpdHkuam9pbignJyk7XG59XG5cbnZhciBQU0VVRE9fWkVSTyA9IC4wMDAwMDAwMTtcbi8qKlxyXG4gKiBWZWN0b3IgbWFnbml0dWRlLlxyXG4gKiBAcGFyYW0gdlxyXG4gKiBAcmV0dXJucyBOdW1iZXIgcmVzdWx0LlxyXG4gKi9cblxuZnVuY3Rpb24gdmVjdG9yTWFnbml0dWRlKHYpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh2WzBdLCAyKSArIE1hdGgucG93KHZbMV0sIDIpKTtcbn1cbi8qKlxyXG4gKiBSYXRpbyBiZXR3ZWVuIHR3byB2ZWN0b3JzLlxyXG4gKiBAcGFyYW0gdVxyXG4gKiBAcGFyYW0gdlxyXG4gKiBAcmV0dXJucyBOdW1iZXIgcmVzdWx0LlxyXG4gKi9cblxuZnVuY3Rpb24gdmVjdG9yc1JhdGlvKHUsIHYpIHtcbiAgcmV0dXJuICh1WzBdICogdlswXSArIHVbMV0gKiB2WzFdKSAvICh2ZWN0b3JNYWduaXR1ZGUodSkgKiB2ZWN0b3JNYWduaXR1ZGUodikpO1xufVxuLyoqXHJcbiAqIEFuZ2xlIGJldHdlZW4gdHdvIHZlY3RvcnMuXHJcbiAqIEBwYXJhbSB1XHJcbiAqIEBwYXJhbSB2XHJcbiAqIEByZXR1cm5zIE51bWJlciByZXN1bHQuXHJcbiAqL1xuXG5mdW5jdGlvbiB2ZWN0b3JzQW5nbGUodSwgdikge1xuICByZXR1cm4gKHVbMF0gKiB2WzFdIDwgdVsxXSAqIHZbMF0gPyAtMSA6IDEpICogTWF0aC5hY29zKHZlY3RvcnNSYXRpbyh1LCB2KSk7XG59XG5mdW5jdGlvbiBDQjEodCkge1xuICByZXR1cm4gdCAqIHQgKiB0O1xufVxuZnVuY3Rpb24gQ0IyKHQpIHtcbiAgcmV0dXJuIDMgKiB0ICogdCAqICgxIC0gdCk7XG59XG5mdW5jdGlvbiBDQjModCkge1xuICByZXR1cm4gMyAqIHQgKiAoMSAtIHQpICogKDEgLSB0KTtcbn1cbmZ1bmN0aW9uIENCNCh0KSB7XG4gIHJldHVybiAoMSAtIHQpICogKDEgLSB0KSAqICgxIC0gdCk7XG59XG5mdW5jdGlvbiBRQjEodCkge1xuICByZXR1cm4gdCAqIHQ7XG59XG5mdW5jdGlvbiBRQjIodCkge1xuICByZXR1cm4gMiAqIHQgKiAoMSAtIHQpO1xufVxuZnVuY3Rpb24gUUIzKHQpIHtcbiAgcmV0dXJuICgxIC0gdCkgKiAoMSAtIHQpO1xufVxuXG5jbGFzcyBQcm9wZXJ0eSB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmlzTm9ybWFsaXplZENvbG9yID0gZmFsc2U7XG4gIH1cblxuICBzdGF0aWMgZW1wdHkoZG9jdW1lbnQpIHtcbiAgICByZXR1cm4gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnRU1QVFknLCAnJyk7XG4gIH1cblxuICBzcGxpdCgpIHtcbiAgICB2YXIgc2VwYXJhdG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnICc7XG4gICAgdmFyIHtcbiAgICAgIGRvY3VtZW50LFxuICAgICAgbmFtZVxuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiBjb21wcmVzc1NwYWNlcyh0aGlzLmdldFN0cmluZygpKS50cmltKCkuc3BsaXQoc2VwYXJhdG9yKS5tYXAodmFsdWUgPT4gbmV3IFByb3BlcnR5KGRvY3VtZW50LCBuYW1lLCB2YWx1ZSkpO1xuICB9XG5cbiAgaGFzVmFsdWUoemVyb0lzVmFsdWUpIHtcbiAgICB2YXIge1xuICAgICAgdmFsdWVcbiAgICB9ID0gdGhpcztcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09ICcnICYmICh6ZXJvSXNWYWx1ZSB8fCB2YWx1ZSAhPT0gMCkgJiYgdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJztcbiAgfVxuXG4gIGlzU3RyaW5nKHJlZ2V4cCkge1xuICAgIHZhciB7XG4gICAgICB2YWx1ZVxuICAgIH0gPSB0aGlzO1xuICAgIHZhciByZXN1bHQgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuXG4gICAgaWYgKCFyZXN1bHQgfHwgIXJlZ2V4cCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVnZXhwLnRlc3QodmFsdWUpO1xuICB9XG5cbiAgaXNVcmxEZWZpbml0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmlzU3RyaW5nKC9edXJsXFwoLyk7XG4gIH1cblxuICBpc1BpeGVscygpIHtcbiAgICBpZiAoIXRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBhc1N0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7XG5cbiAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgIGNhc2UgYXNTdHJpbmcuZW5kc1dpdGgoJ3B4Jyk6XG4gICAgICBjYXNlIC9eWzAtOV0rJC8udGVzdChhc1N0cmluZyk6XG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXRWYWx1ZShkZWYpIHtcbiAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcy5oYXNWYWx1ZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVmO1xuICB9XG5cbiAgZ2V0TnVtYmVyKGRlZikge1xuICAgIGlmICghdGhpcy5oYXNWYWx1ZSgpKSB7XG4gICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KGRlZik7XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIHZhbHVlXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbHVlKTtcblxuICAgIGlmICh0aGlzLmlzU3RyaW5nKC8lJC8pKSB7XG4gICAgICBuIC89IDEwMC4wO1xuICAgIH1cblxuICAgIHJldHVybiBuO1xuICB9XG5cbiAgZ2V0U3RyaW5nKGRlZikge1xuICAgIGlmICh0eXBlb2YgZGVmID09PSAndW5kZWZpbmVkJyB8fCB0aGlzLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdGhpcy52YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6IFN0cmluZyh0aGlzLnZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gU3RyaW5nKGRlZik7XG4gIH1cblxuICBnZXRDb2xvcihkZWYpIHtcbiAgICB2YXIgY29sb3IgPSB0aGlzLmdldFN0cmluZyhkZWYpO1xuXG4gICAgaWYgKHRoaXMuaXNOb3JtYWxpemVkQ29sb3IpIHtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG5cbiAgICB0aGlzLmlzTm9ybWFsaXplZENvbG9yID0gdHJ1ZTtcbiAgICBjb2xvciA9IG5vcm1hbGl6ZUNvbG9yKGNvbG9yKTtcbiAgICB0aGlzLnZhbHVlID0gY29sb3I7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG5cbiAgZ2V0RHBpKCkge1xuICAgIHJldHVybiA5Ni4wOyAvLyBUT0RPOiBjb21wdXRlP1xuICB9XG5cbiAgZ2V0UmVtKCkge1xuICAgIHJldHVybiB0aGlzLmRvY3VtZW50LnJvb3RFbVNpemU7XG4gIH1cblxuICBnZXRFbSgpIHtcbiAgICByZXR1cm4gdGhpcy5kb2N1bWVudC5lbVNpemU7XG4gIH1cblxuICBnZXRVbml0cygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTdHJpbmcoKS5yZXBsYWNlKC9bMC05Li1dL2csICcnKTtcbiAgfVxuXG4gIGdldFBpeGVscyhheGlzT3JJc0ZvbnRTaXplKSB7XG4gICAgdmFyIHByb2Nlc3NQZXJjZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgIGlmICghdGhpcy5oYXNWYWx1ZSgpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB2YXIgW2F4aXMsIGlzRm9udFNpemVdID0gdHlwZW9mIGF4aXNPcklzRm9udFNpemUgPT09ICdib29sZWFuJyA/IFt1bmRlZmluZWQsIGF4aXNPcklzRm9udFNpemVdIDogW2F4aXNPcklzRm9udFNpemVdO1xuICAgIHZhciB7XG4gICAgICB2aWV3UG9ydFxuICAgIH0gPSB0aGlzLmRvY3VtZW50LnNjcmVlbjtcblxuICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC92bWluJC8pOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAvIDEwMC4wICogTWF0aC5taW4odmlld1BvcnQuY29tcHV0ZVNpemUoJ3gnKSwgdmlld1BvcnQuY29tcHV0ZVNpemUoJ3knKSk7XG5cbiAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvdm1heCQvKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgLyAxMDAuMCAqIE1hdGgubWF4KHZpZXdQb3J0LmNvbXB1dGVTaXplKCd4JyksIHZpZXdQb3J0LmNvbXB1dGVTaXplKCd5JykpO1xuXG4gICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3Z3JC8pOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAvIDEwMC4wICogdmlld1BvcnQuY29tcHV0ZVNpemUoJ3gnKTtcblxuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC92aCQvKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgLyAxMDAuMCAqIHZpZXdQb3J0LmNvbXB1dGVTaXplKCd5Jyk7XG5cbiAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvcmVtJC8pOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHRoaXMuZ2V0UmVtKCk7XG5cbiAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvZW0kLyk6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogdGhpcy5nZXRFbSgpO1xuXG4gICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL2V4JC8pOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHRoaXMuZ2V0RW0oKSAvIDIuMDtcblxuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9weCQvKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCk7XG5cbiAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvcHQkLyk6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogdGhpcy5nZXREcGkoKSAqICgxLjAgLyA3Mi4wKTtcblxuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9wYyQvKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiAxNTtcblxuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9jbSQvKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiB0aGlzLmdldERwaSgpIC8gMi41NDtcblxuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9tbSQvKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiB0aGlzLmdldERwaSgpIC8gMjUuNDtcblxuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9pbiQvKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiB0aGlzLmdldERwaSgpO1xuXG4gICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoLyUkLykgJiYgaXNGb250U2l6ZTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiB0aGlzLmdldEVtKCk7XG5cbiAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvJSQvKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiB2aWV3UG9ydC5jb21wdXRlU2l6ZShheGlzKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBuID0gdGhpcy5nZXROdW1iZXIoKTtcblxuICAgICAgICAgIGlmIChwcm9jZXNzUGVyY2VudCAmJiBuIDwgMS4wKSB7XG4gICAgICAgICAgICByZXR1cm4gbiAqIHZpZXdQb3J0LmNvbXB1dGVTaXplKGF4aXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0TWlsbGlzZWNvbmRzKCkge1xuICAgIGlmICghdGhpcy5oYXNWYWx1ZSgpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1N0cmluZygvbXMkLykpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogMTAwMDtcbiAgfVxuXG4gIGdldFJhZGlhbnMoKSB7XG4gICAgaWYgKCF0aGlzLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9kZWckLyk6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogKE1hdGguUEkgLyAxODAuMCk7XG5cbiAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvZ3JhZCQvKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiAoTWF0aC5QSSAvIDIwMC4wKTtcblxuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9yYWQkLyk6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIChNYXRoLlBJIC8gMTgwLjApO1xuICAgIH1cbiAgfVxuXG4gIGdldERlZmluaXRpb24oKSB7XG4gICAgdmFyIGFzU3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTtcbiAgICB2YXIgbmFtZSA9IC8jKFteKSdcIl0rKS8uZXhlYyhhc1N0cmluZyk7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgbmFtZSA9IG5hbWVbMV07XG4gICAgfVxuXG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICBuYW1lID0gYXNTdHJpbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQuZGVmaW5pdGlvbnNbbmFtZV07XG4gIH1cblxuICBnZXRGaWxsU3R5bGVEZWZpbml0aW9uKGVsZW1lbnQsIG9wYWNpdHkpIHtcbiAgICB2YXIgZGVmID0gdGhpcy5nZXREZWZpbml0aW9uKCk7XG5cbiAgICBpZiAoIWRlZikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvLyBncmFkaWVudFxuXG5cbiAgICBpZiAodHlwZW9mIGRlZi5jcmVhdGVHcmFkaWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGRlZi5jcmVhdGVHcmFkaWVudCh0aGlzLmRvY3VtZW50LmN0eCwgZWxlbWVudCwgb3BhY2l0eSk7XG4gICAgfSAvLyBwYXR0ZXJuXG5cblxuICAgIGlmICh0eXBlb2YgZGVmLmNyZWF0ZVBhdHRlcm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkZWYuZ2V0SHJlZkF0dHJpYnV0ZSgpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgdmFyIHBhdHRlcm5UcmFuc2Zvcm0gPSBkZWYuZ2V0QXR0cmlidXRlKCdwYXR0ZXJuVHJhbnNmb3JtJyk7XG4gICAgICAgIGRlZiA9IGRlZi5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0RGVmaW5pdGlvbigpO1xuXG4gICAgICAgIGlmIChwYXR0ZXJuVHJhbnNmb3JtLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICBkZWYuZ2V0QXR0cmlidXRlKCdwYXR0ZXJuVHJhbnNmb3JtJywgdHJ1ZSkuc2V0VmFsdWUocGF0dGVyblRyYW5zZm9ybS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlZi5jcmVhdGVQYXR0ZXJuKHRoaXMuZG9jdW1lbnQuY3R4LCBlbGVtZW50LCBvcGFjaXR5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldFRleHRCYXNlbGluZSgpIHtcbiAgICBpZiAoIXRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb3BlcnR5LnRleHRCYXNlbGluZU1hcHBpbmdbdGhpcy5nZXRTdHJpbmcoKV07XG4gIH1cblxuICBhZGRPcGFjaXR5KG9wYWNpdHkpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldENvbG9yKCk7XG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aDtcbiAgICB2YXIgY29tbWFzID0gMDsgLy8gU2ltdWxhdGUgb2xkIFJHQkNvbG9yIHZlcnNpb24sIHdoaWNoIGNhbid0IHBhcnNlIHJnYmEuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVbaV0gPT09ICcsJykge1xuICAgICAgICBjb21tYXMrKztcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbW1hcyA9PT0gMykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3BhY2l0eS5oYXNWYWx1ZSgpICYmIHRoaXMuaXNTdHJpbmcoKSAmJiBjb21tYXMgIT09IDMpIHtcbiAgICAgIHZhciBjb2xvciA9IG5ldyBSR0JDb2xvcih2YWx1ZSk7XG5cbiAgICAgIGlmIChjb2xvci5vaykge1xuICAgICAgICBjb2xvci5hbHBoYSA9IG9wYWNpdHkuZ2V0TnVtYmVyKCk7XG4gICAgICAgIHZhbHVlID0gY29sb3IudG9SR0JBKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCB0aGlzLm5hbWUsIHZhbHVlKTtcbiAgfVxuXG59XG5Qcm9wZXJ0eS50ZXh0QmFzZWxpbmVNYXBwaW5nID0ge1xuICAnYmFzZWxpbmUnOiAnYWxwaGFiZXRpYycsXG4gICdiZWZvcmUtZWRnZSc6ICd0b3AnLFxuICAndGV4dC1iZWZvcmUtZWRnZSc6ICd0b3AnLFxuICAnbWlkZGxlJzogJ21pZGRsZScsXG4gICdjZW50cmFsJzogJ21pZGRsZScsXG4gICdhZnRlci1lZGdlJzogJ2JvdHRvbScsXG4gICd0ZXh0LWFmdGVyLWVkZ2UnOiAnYm90dG9tJyxcbiAgJ2lkZW9ncmFwaGljJzogJ2lkZW9ncmFwaGljJyxcbiAgJ2FscGhhYmV0aWMnOiAnYWxwaGFiZXRpYycsXG4gICdoYW5naW5nJzogJ2hhbmdpbmcnLFxuICAnbWF0aGVtYXRpY2FsJzogJ2FscGhhYmV0aWMnXG59O1xuXG5jbGFzcyBWaWV3UG9ydCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudmlld1BvcnRzID0gW107XG4gIH1cblxuICBjbGVhcigpIHtcbiAgICB0aGlzLnZpZXdQb3J0cyA9IFtdO1xuICB9XG5cbiAgc2V0Q3VycmVudCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy52aWV3UG9ydHMucHVzaCh7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0pO1xuICB9XG5cbiAgcmVtb3ZlQ3VycmVudCgpIHtcbiAgICB0aGlzLnZpZXdQb3J0cy5wb3AoKTtcbiAgfVxuXG4gIGdldEN1cnJlbnQoKSB7XG4gICAgdmFyIHtcbiAgICAgIHZpZXdQb3J0c1xuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiB2aWV3UG9ydHNbdmlld1BvcnRzLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnQoKS53aWR0aDtcbiAgfVxuXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudCgpLmhlaWdodDtcbiAgfVxuXG4gIGNvbXB1dGVTaXplKGQpIHtcbiAgICBpZiAodHlwZW9mIGQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gZDtcbiAgICB9XG5cbiAgICBpZiAoZCA9PT0gJ3gnKSB7XG4gICAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgICB9XG5cbiAgICBpZiAoZCA9PT0gJ3knKSB7XG4gICAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh0aGlzLndpZHRoLCAyKSArIE1hdGgucG93KHRoaXMuaGVpZ2h0LCAyKSkgLyBNYXRoLnNxcnQoMik7XG4gIH1cblxufVxuXG5jbGFzcyBQb2ludCB7XG4gIGNvbnN0cnVjdG9yKHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cblxuICBzdGF0aWMgcGFyc2UocG9pbnQpIHtcbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgIHZhciBbeCA9IGRlZmF1bHRWYWx1ZSwgeSA9IGRlZmF1bHRWYWx1ZV0gPSB0b051bWJlcnMocG9pbnQpO1xuICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSk7XG4gIH1cblxuICBzdGF0aWMgcGFyc2VTY2FsZShzY2FsZSkge1xuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE7XG4gICAgdmFyIFt4ID0gZGVmYXVsdFZhbHVlLCB5ID0geF0gPSB0b051bWJlcnMoc2NhbGUpO1xuICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSk7XG4gIH1cblxuICBzdGF0aWMgcGFyc2VQYXRoKHBhdGgpIHtcbiAgICB2YXIgcG9pbnRzID0gdG9OdW1iZXJzKHBhdGgpO1xuICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgIHZhciBwYXRoUG9pbnRzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICBwYXRoUG9pbnRzLnB1c2gobmV3IFBvaW50KHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoUG9pbnRzO1xuICB9XG5cbiAgYW5nbGVUbyhwb2ludCkge1xuICAgIHJldHVybiBNYXRoLmF0YW4yKHBvaW50LnkgLSB0aGlzLnksIHBvaW50LnggLSB0aGlzLngpO1xuICB9XG5cbiAgYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtKSB7XG4gICAgdmFyIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHhwID0geCAqIHRyYW5zZm9ybVswXSArIHkgKiB0cmFuc2Zvcm1bMl0gKyB0cmFuc2Zvcm1bNF07XG4gICAgdmFyIHlwID0geCAqIHRyYW5zZm9ybVsxXSArIHkgKiB0cmFuc2Zvcm1bM10gKyB0cmFuc2Zvcm1bNV07XG4gICAgdGhpcy54ID0geHA7XG4gICAgdGhpcy55ID0geXA7XG4gIH1cblxufVxuXG5jbGFzcyBNb3VzZSB7XG4gIGNvbnN0cnVjdG9yKHNjcmVlbikge1xuICAgIHRoaXMuc2NyZWVuID0gc2NyZWVuO1xuICAgIHRoaXMud29ya2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZXZlbnRzID0gW107XG4gICAgdGhpcy5ldmVudEVsZW1lbnRzID0gW107IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcblxuICAgIHRoaXMub25DbGljayA9IHRoaXMub25DbGljay5iaW5kKHRoaXMpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG5cbiAgICB0aGlzLm9uTW91c2VNb3ZlID0gdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgaXNXb3JraW5nKCkge1xuICAgIHJldHVybiB0aGlzLndvcmtpbmc7XG4gIH1cblxuICBzdGFydCgpIHtcbiAgICBpZiAodGhpcy53b3JraW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIHNjcmVlbixcbiAgICAgIG9uQ2xpY2ssXG4gICAgICBvbk1vdXNlTW92ZVxuICAgIH0gPSB0aGlzO1xuICAgIHZhciBjYW52YXMgPSBzY3JlZW4uY3R4LmNhbnZhcztcbiAgICBjYW52YXMub25jbGljayA9IG9uQ2xpY2s7XG4gICAgY2FudmFzLm9ubW91c2Vtb3ZlID0gb25Nb3VzZU1vdmU7XG4gICAgdGhpcy53b3JraW5nID0gdHJ1ZTtcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgaWYgKCF0aGlzLndvcmtpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY2FudmFzID0gdGhpcy5zY3JlZW4uY3R4LmNhbnZhcztcbiAgICB0aGlzLndvcmtpbmcgPSBmYWxzZTtcbiAgICBjYW52YXMub25jbGljayA9IG51bGw7XG4gICAgY2FudmFzLm9ubW91c2Vtb3ZlID0gbnVsbDtcbiAgfVxuXG4gIGhhc0V2ZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy53b3JraW5nICYmIHRoaXMuZXZlbnRzLmxlbmd0aCA+IDA7XG4gIH1cblxuICBydW5FdmVudHMoKSB7XG4gICAgaWYgKCF0aGlzLndvcmtpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIge1xuICAgICAgc2NyZWVuOiBkb2N1bWVudCxcbiAgICAgIGV2ZW50cyxcbiAgICAgIGV2ZW50RWxlbWVudHNcbiAgICB9ID0gdGhpcztcbiAgICB2YXIge1xuICAgICAgc3R5bGVcbiAgICB9ID0gZG9jdW1lbnQuY3R4LmNhbnZhcztcblxuICAgIGlmIChzdHlsZSkge1xuICAgICAgc3R5bGUuY3Vyc29yID0gJyc7XG4gICAgfVxuXG4gICAgZXZlbnRzLmZvckVhY2goKF9yZWYsIGkpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHJ1blxuICAgICAgfSA9IF9yZWY7XG4gICAgICB2YXIgZWxlbWVudCA9IGV2ZW50RWxlbWVudHNbaV07XG5cbiAgICAgIHdoaWxlIChlbGVtZW50KSB7XG4gICAgICAgIHJ1bihlbGVtZW50KTtcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50O1xuICAgICAgfVxuICAgIH0pOyAvLyBkb25lIHJ1bm5pbmcsIGNsZWFyXG5cbiAgICB0aGlzLmV2ZW50cyA9IFtdO1xuICAgIHRoaXMuZXZlbnRFbGVtZW50cyA9IFtdO1xuICB9XG5cbiAgY2hlY2tQYXRoKGVsZW1lbnQsIGN0eCkge1xuICAgIGlmICghdGhpcy53b3JraW5nIHx8ICFjdHgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIge1xuICAgICAgZXZlbnRzLFxuICAgICAgZXZlbnRFbGVtZW50c1xuICAgIH0gPSB0aGlzO1xuICAgIGV2ZW50cy5mb3JFYWNoKChfcmVmMiwgaSkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IF9yZWYyO1xuXG4gICAgICBpZiAoIWV2ZW50RWxlbWVudHNbaV0gJiYgY3R4LmlzUG9pbnRJblBhdGggJiYgY3R4LmlzUG9pbnRJblBhdGgoeCwgeSkpIHtcbiAgICAgICAgZXZlbnRFbGVtZW50c1tpXSA9IGVsZW1lbnQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjaGVja0JvdW5kaW5nQm94KGVsZW1lbnQsIGJvdW5kaW5nQm94KSB7XG4gICAgaWYgKCF0aGlzLndvcmtpbmcgfHwgIWJvdW5kaW5nQm94KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIGV2ZW50cyxcbiAgICAgIGV2ZW50RWxlbWVudHNcbiAgICB9ID0gdGhpcztcbiAgICBldmVudHMuZm9yRWFjaCgoX3JlZjMsIGkpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSBfcmVmMztcblxuICAgICAgaWYgKCFldmVudEVsZW1lbnRzW2ldICYmIGJvdW5kaW5nQm94LmlzUG9pbnRJbkJveCh4LCB5KSkge1xuICAgICAgICBldmVudEVsZW1lbnRzW2ldID0gZWxlbWVudDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIG1hcFhZKHgsIHkpIHtcbiAgICB2YXIge1xuICAgICAgd2luZG93LFxuICAgICAgY3R4XG4gICAgfSA9IHRoaXMuc2NyZWVuO1xuICAgIHZhciBwb2ludCA9IG5ldyBQb2ludCh4LCB5KTtcbiAgICB2YXIgZWxlbWVudCA9IGN0eC5jYW52YXM7XG5cbiAgICB3aGlsZSAoZWxlbWVudCkge1xuICAgICAgcG9pbnQueCAtPSBlbGVtZW50Lm9mZnNldExlZnQ7XG4gICAgICBwb2ludC55IC09IGVsZW1lbnQub2Zmc2V0VG9wO1xuICAgICAgZWxlbWVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuICAgIH1cblxuICAgIGlmICh3aW5kb3cuc2Nyb2xsWCkge1xuICAgICAgcG9pbnQueCArPSB3aW5kb3cuc2Nyb2xsWDtcbiAgICB9XG5cbiAgICBpZiAod2luZG93LnNjcm9sbFkpIHtcbiAgICAgIHBvaW50LnkgKz0gd2luZG93LnNjcm9sbFk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvaW50O1xuICB9XG5cbiAgb25DbGljayhldmVudCkge1xuICAgIHZhciB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSB0aGlzLm1hcFhZKGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgIHRoaXMuZXZlbnRzLnB1c2goe1xuICAgICAgdHlwZTogJ29uY2xpY2snLFxuICAgICAgeCxcbiAgICAgIHksXG5cbiAgICAgIHJ1bihldmVudFRhcmdldCkge1xuICAgICAgICBpZiAoZXZlbnRUYXJnZXQub25DbGljaykge1xuICAgICAgICAgIGV2ZW50VGFyZ2V0Lm9uQ2xpY2soKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfSk7XG4gIH1cblxuICBvbk1vdXNlTW92ZShldmVudCkge1xuICAgIHZhciB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSB0aGlzLm1hcFhZKGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgIHRoaXMuZXZlbnRzLnB1c2goe1xuICAgICAgdHlwZTogJ29ubW91c2Vtb3ZlJyxcbiAgICAgIHgsXG4gICAgICB5LFxuXG4gICAgICBydW4oZXZlbnRUYXJnZXQpIHtcbiAgICAgICAgaWYgKGV2ZW50VGFyZ2V0Lm9uTW91c2VNb3ZlKSB7XG4gICAgICAgICAgZXZlbnRUYXJnZXQub25Nb3VzZU1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfSk7XG4gIH1cblxufVxuXG52YXIgZGVmYXVsdFdpbmRvdyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogbnVsbDtcbnZhciBkZWZhdWx0RmV0Y2gkMSA9IHR5cGVvZiBmZXRjaCAhPT0gJ3VuZGVmaW5lZCcgPyBmZXRjaC5iaW5kKHVuZGVmaW5lZCkgLy8gYGZldGNoYCBkZXBlbmRzIG9uIGNvbnRleHQ6IGBzb21lT2JqZWN0LmZldGNoKC4uLilgIHdpbGwgdGhyb3cgZXJyb3IuXG46IG51bGw7XG5jbGFzcyBTY3JlZW4ge1xuICBjb25zdHJ1Y3RvcihjdHgpIHtcbiAgICB2YXIge1xuICAgICAgZmV0Y2ggPSBkZWZhdWx0RmV0Y2gkMSxcbiAgICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3dcbiAgICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLkZSQU1FUkFURSA9IDMwO1xuICAgIHRoaXMuTUFYX1ZJUlRVQUxfUElYRUxTID0gMzAwMDA7XG4gICAgdGhpcy5DTElFTlRfV0lEVEggPSA4MDA7XG4gICAgdGhpcy5DTElFTlRfSEVJR0hUID0gNjAwO1xuICAgIHRoaXMudmlld1BvcnQgPSBuZXcgVmlld1BvcnQoKTtcbiAgICB0aGlzLm1vdXNlID0gbmV3IE1vdXNlKHRoaXMpO1xuICAgIHRoaXMuYW5pbWF0aW9ucyA9IFtdO1xuICAgIHRoaXMud2FpdHMgPSBbXTtcbiAgICB0aGlzLmZyYW1lRHVyYXRpb24gPSAwO1xuICAgIHRoaXMuaXNSZWFkeUxvY2sgPSBmYWxzZTtcbiAgICB0aGlzLmlzRmlyc3RSZW5kZXIgPSB0cnVlO1xuICAgIHRoaXMuaW50ZXJ2YWxJZCA9IG51bGw7XG4gICAgdGhpcy53aW5kb3cgPSB3aW5kb3c7XG4gICAgdGhpcy5mZXRjaCA9IGZldGNoO1xuICB9XG5cbiAgd2FpdChjaGVja2VyKSB7XG4gICAgdGhpcy53YWl0cy5wdXNoKGNoZWNrZXIpO1xuICB9XG5cbiAgcmVhZHkoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1taXN1c2VkLXByb21pc2VzXG4gICAgaWYgKCF0aGlzLnJlYWR5UHJvbWlzZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJlYWR5UHJvbWlzZTtcbiAgfVxuXG4gIGlzUmVhZHkoKSB7XG4gICAgaWYgKHRoaXMuaXNSZWFkeUxvY2spIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpc1JlYWR5TG9jayA9IHRoaXMud2FpdHMuZXZlcnkoXyA9PiBfKCkpO1xuXG4gICAgaWYgKGlzUmVhZHlMb2NrKSB7XG4gICAgICB0aGlzLndhaXRzID0gW107XG5cbiAgICAgIGlmICh0aGlzLnJlc29sdmVSZWFkeSkge1xuICAgICAgICB0aGlzLnJlc29sdmVSZWFkeSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaXNSZWFkeUxvY2sgPSBpc1JlYWR5TG9jaztcbiAgICByZXR1cm4gaXNSZWFkeUxvY2s7XG4gIH1cblxuICBzZXREZWZhdWx0cyhjdHgpIHtcbiAgICAvLyBpbml0aWFsIHZhbHVlcyBhbmQgZGVmYXVsdHNcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgY3R4LmxpbmVDYXAgPSAnYnV0dCc7XG4gICAgY3R4LmxpbmVKb2luID0gJ21pdGVyJztcbiAgICBjdHgubWl0ZXJMaW1pdCA9IDQ7XG4gIH1cblxuICBzZXRWaWV3Qm94KF9yZWYpIHtcbiAgICB2YXIge1xuICAgICAgZG9jdW1lbnQsXG4gICAgICBjdHgsXG4gICAgICBhc3BlY3RSYXRpbyxcbiAgICAgIHdpZHRoLFxuICAgICAgZGVzaXJlZFdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgZGVzaXJlZEhlaWdodCxcbiAgICAgIG1pblggPSAwLFxuICAgICAgbWluWSA9IDAsXG4gICAgICByZWZYLFxuICAgICAgcmVmWSxcbiAgICAgIGNsaXAgPSBmYWxzZSxcbiAgICAgIGNsaXBYID0gMCxcbiAgICAgIGNsaXBZID0gMFxuICAgIH0gPSBfcmVmO1xuICAgIC8vIGFzcGVjdCByYXRpbyAtIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9jb29yZHMuaHRtbCNQcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0cmlidXRlXG4gICAgdmFyIGNsZWFuQXNwZWN0UmF0aW8gPSBjb21wcmVzc1NwYWNlcyhhc3BlY3RSYXRpbykucmVwbGFjZSgvXmRlZmVyXFxzLywgJycpOyAvLyBpZ25vcmUgZGVmZXJcblxuICAgIHZhciBbYXNwZWN0UmF0aW9BbGlnbiwgYXNwZWN0UmF0aW9NZWV0T3JTbGljZV0gPSBjbGVhbkFzcGVjdFJhdGlvLnNwbGl0KCcgJyk7XG4gICAgdmFyIGFsaWduID0gYXNwZWN0UmF0aW9BbGlnbiB8fCAneE1pZFlNaWQnO1xuICAgIHZhciBtZWV0T3JTbGljZSA9IGFzcGVjdFJhdGlvTWVldE9yU2xpY2UgfHwgJ21lZXQnOyAvLyBjYWxjdWxhdGUgc2NhbGVcblxuICAgIHZhciBzY2FsZVggPSB3aWR0aCAvIGRlc2lyZWRXaWR0aDtcbiAgICB2YXIgc2NhbGVZID0gaGVpZ2h0IC8gZGVzaXJlZEhlaWdodDtcbiAgICB2YXIgc2NhbGVNaW4gPSBNYXRoLm1pbihzY2FsZVgsIHNjYWxlWSk7XG4gICAgdmFyIHNjYWxlTWF4ID0gTWF0aC5tYXgoc2NhbGVYLCBzY2FsZVkpO1xuICAgIHZhciBmaW5hbERlc2lyZWRXaWR0aCA9IGRlc2lyZWRXaWR0aDtcbiAgICB2YXIgZmluYWxEZXNpcmVkSGVpZ2h0ID0gZGVzaXJlZEhlaWdodDtcblxuICAgIGlmIChtZWV0T3JTbGljZSA9PT0gJ21lZXQnKSB7XG4gICAgICBmaW5hbERlc2lyZWRXaWR0aCAqPSBzY2FsZU1pbjtcbiAgICAgIGZpbmFsRGVzaXJlZEhlaWdodCAqPSBzY2FsZU1pbjtcbiAgICB9XG5cbiAgICBpZiAobWVldE9yU2xpY2UgPT09ICdzbGljZScpIHtcbiAgICAgIGZpbmFsRGVzaXJlZFdpZHRoICo9IHNjYWxlTWF4O1xuICAgICAgZmluYWxEZXNpcmVkSGVpZ2h0ICo9IHNjYWxlTWF4O1xuICAgIH1cblxuICAgIHZhciByZWZYUHJvcCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3JlZlgnLCByZWZYKTtcbiAgICB2YXIgcmVmWVByb3AgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdyZWZZJywgcmVmWSk7XG4gICAgdmFyIGhhc1JlZnMgPSByZWZYUHJvcC5oYXNWYWx1ZSgpICYmIHJlZllQcm9wLmhhc1ZhbHVlKCk7XG5cbiAgICBpZiAoaGFzUmVmcykge1xuICAgICAgY3R4LnRyYW5zbGF0ZSgtc2NhbGVNaW4gKiByZWZYUHJvcC5nZXRQaXhlbHMoJ3gnKSwgLXNjYWxlTWluICogcmVmWVByb3AuZ2V0UGl4ZWxzKCd5JykpO1xuICAgIH1cblxuICAgIGlmIChjbGlwKSB7XG4gICAgICB2YXIgc2NhbGVkQ2xpcFggPSBzY2FsZU1pbiAqIGNsaXBYO1xuICAgICAgdmFyIHNjYWxlZENsaXBZID0gc2NhbGVNaW4gKiBjbGlwWTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oc2NhbGVkQ2xpcFgsIHNjYWxlZENsaXBZKTtcbiAgICAgIGN0eC5saW5lVG8od2lkdGgsIHNjYWxlZENsaXBZKTtcbiAgICAgIGN0eC5saW5lVG8od2lkdGgsIGhlaWdodCk7XG4gICAgICBjdHgubGluZVRvKHNjYWxlZENsaXBYLCBoZWlnaHQpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgY3R4LmNsaXAoKTtcbiAgICB9XG5cbiAgICBpZiAoIWhhc1JlZnMpIHtcbiAgICAgIHZhciBpc01lZXRNaW5ZID0gbWVldE9yU2xpY2UgPT09ICdtZWV0JyAmJiBzY2FsZU1pbiA9PT0gc2NhbGVZO1xuICAgICAgdmFyIGlzU2xpY2VNYXhZID0gbWVldE9yU2xpY2UgPT09ICdzbGljZScgJiYgc2NhbGVNYXggPT09IHNjYWxlWTtcbiAgICAgIHZhciBpc01lZXRNaW5YID0gbWVldE9yU2xpY2UgPT09ICdtZWV0JyAmJiBzY2FsZU1pbiA9PT0gc2NhbGVYO1xuICAgICAgdmFyIGlzU2xpY2VNYXhYID0gbWVldE9yU2xpY2UgPT09ICdzbGljZScgJiYgc2NhbGVNYXggPT09IHNjYWxlWDtcblxuICAgICAgaWYgKGFsaWduLnN0YXJ0c1dpdGgoJ3hNaWQnKSAmJiAoaXNNZWV0TWluWSB8fCBpc1NsaWNlTWF4WSkpIHtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh3aWR0aCAvIDIuMCAtIGZpbmFsRGVzaXJlZFdpZHRoIC8gMi4wLCAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFsaWduLmVuZHNXaXRoKCdZTWlkJykgJiYgKGlzTWVldE1pblggfHwgaXNTbGljZU1heFgpKSB7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoMCwgaGVpZ2h0IC8gMi4wIC0gZmluYWxEZXNpcmVkSGVpZ2h0IC8gMi4wKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFsaWduLnN0YXJ0c1dpdGgoJ3hNYXgnKSAmJiAoaXNNZWV0TWluWSB8fCBpc1NsaWNlTWF4WSkpIHtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh3aWR0aCAtIGZpbmFsRGVzaXJlZFdpZHRoLCAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFsaWduLmVuZHNXaXRoKCdZTWF4JykgJiYgKGlzTWVldE1pblggfHwgaXNTbGljZU1heFgpKSB7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoMCwgaGVpZ2h0IC0gZmluYWxEZXNpcmVkSGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9IC8vIHNjYWxlXG5cblxuICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgY2FzZSBhbGlnbiA9PT0gJ25vbmUnOlxuICAgICAgICBjdHguc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBtZWV0T3JTbGljZSA9PT0gJ21lZXQnOlxuICAgICAgICBjdHguc2NhbGUoc2NhbGVNaW4sIHNjYWxlTWluKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgbWVldE9yU2xpY2UgPT09ICdzbGljZSc6XG4gICAgICAgIGN0eC5zY2FsZShzY2FsZU1heCwgc2NhbGVNYXgpO1xuICAgICAgICBicmVhaztcbiAgICB9IC8vIHRyYW5zbGF0ZVxuXG5cbiAgICBjdHgudHJhbnNsYXRlKC1taW5YLCAtbWluWSk7XG4gIH1cblxuICBzdGFydChlbGVtZW50KSB7XG4gICAgdmFyIHtcbiAgICAgIGVuYWJsZVJlZHJhdyA9IGZhbHNlLFxuICAgICAgaWdub3JlTW91c2UgPSBmYWxzZSxcbiAgICAgIGlnbm9yZUFuaW1hdGlvbiA9IGZhbHNlLFxuICAgICAgaWdub3JlRGltZW5zaW9ucyA9IGZhbHNlLFxuICAgICAgaWdub3JlQ2xlYXIgPSBmYWxzZSxcbiAgICAgIGZvcmNlUmVkcmF3LFxuICAgICAgc2NhbGVXaWR0aCxcbiAgICAgIHNjYWxlSGVpZ2h0LFxuICAgICAgb2Zmc2V0WCxcbiAgICAgIG9mZnNldFlcbiAgICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgRlJBTUVSQVRFLFxuICAgICAgbW91c2VcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgZnJhbWVEdXJhdGlvbiA9IDEwMDAgLyBGUkFNRVJBVEU7XG4gICAgdGhpcy5mcmFtZUR1cmF0aW9uID0gZnJhbWVEdXJhdGlvbjtcbiAgICB0aGlzLnJlYWR5UHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgdGhpcy5yZXNvbHZlUmVhZHkgPSByZXNvbHZlO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuaXNSZWFkeSgpKSB7XG4gICAgICB0aGlzLnJlbmRlcihlbGVtZW50LCBpZ25vcmVEaW1lbnNpb25zLCBpZ25vcmVDbGVhciwgc2NhbGVXaWR0aCwgc2NhbGVIZWlnaHQsIG9mZnNldFgsIG9mZnNldFkpO1xuICAgIH1cblxuICAgIGlmICghZW5hYmxlUmVkcmF3KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgdmFyIHRoZW4gPSBub3c7XG4gICAgdmFyIGRlbHRhID0gMDtcblxuICAgIHZhciB0aWNrID0gKCkgPT4ge1xuICAgICAgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgIGRlbHRhID0gbm93IC0gdGhlbjtcblxuICAgICAgaWYgKGRlbHRhID49IGZyYW1lRHVyYXRpb24pIHtcbiAgICAgICAgdGhlbiA9IG5vdyAtIGRlbHRhICUgZnJhbWVEdXJhdGlvbjtcblxuICAgICAgICBpZiAodGhpcy5zaG91bGRVcGRhdGUoaWdub3JlQW5pbWF0aW9uLCBmb3JjZVJlZHJhdykpIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcihlbGVtZW50LCBpZ25vcmVEaW1lbnNpb25zLCBpZ25vcmVDbGVhciwgc2NhbGVXaWR0aCwgc2NhbGVIZWlnaHQsIG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgICAgIG1vdXNlLnJ1bkV2ZW50cygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW50ZXJ2YWxJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aWNrKTtcbiAgICB9O1xuXG4gICAgaWYgKCFpZ25vcmVNb3VzZSkge1xuICAgICAgbW91c2Uuc3RhcnQoKTtcbiAgICB9XG5cbiAgICB0aGlzLmludGVydmFsSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGljayk7XG4gIH1cblxuICBzdG9wKCkge1xuICAgIGlmICh0aGlzLmludGVydmFsSWQpIHtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZS5jYW5jZWwodGhpcy5pbnRlcnZhbElkKTtcbiAgICAgIHRoaXMuaW50ZXJ2YWxJZCA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5tb3VzZS5zdG9wKCk7XG4gIH1cblxuICBzaG91bGRVcGRhdGUoaWdub3JlQW5pbWF0aW9uLCBmb3JjZVJlZHJhdykge1xuICAgIC8vIG5lZWQgdXBkYXRlIGZyb20gYW5pbWF0aW9ucz9cbiAgICBpZiAoIWlnbm9yZUFuaW1hdGlvbikge1xuICAgICAgdmFyIHtcbiAgICAgICAgZnJhbWVEdXJhdGlvblxuICAgICAgfSA9IHRoaXM7XG4gICAgICB2YXIgc2hvdWxkVXBkYXRlID0gdGhpcy5hbmltYXRpb25zLnJlZHVjZSgoc2hvdWxkVXBkYXRlLCBhbmltYXRpb24pID0+IGFuaW1hdGlvbi51cGRhdGUoZnJhbWVEdXJhdGlvbikgfHwgc2hvdWxkVXBkYXRlLCBmYWxzZSk7XG5cbiAgICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSAvLyBuZWVkIHVwZGF0ZSBmcm9tIHJlZHJhdz9cblxuXG4gICAgaWYgKHR5cGVvZiBmb3JjZVJlZHJhdyA9PT0gJ2Z1bmN0aW9uJyAmJiBmb3JjZVJlZHJhdygpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNSZWFkeUxvY2sgJiYgdGhpcy5pc1JlYWR5KCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gbmVlZCB1cGRhdGUgZnJvbSBtb3VzZSBldmVudHM/XG5cblxuICAgIGlmICh0aGlzLm1vdXNlLmhhc0V2ZW50cygpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZW5kZXIoZWxlbWVudCwgaWdub3JlRGltZW5zaW9ucywgaWdub3JlQ2xlYXIsIHNjYWxlV2lkdGgsIHNjYWxlSGVpZ2h0LCBvZmZzZXRYLCBvZmZzZXRZKSB7XG4gICAgdmFyIHtcbiAgICAgIENMSUVOVF9XSURUSCxcbiAgICAgIENMSUVOVF9IRUlHSFQsXG4gICAgICB2aWV3UG9ydCxcbiAgICAgIGN0eCxcbiAgICAgIGlzRmlyc3RSZW5kZXJcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgY2FudmFzID0gY3R4LmNhbnZhcztcbiAgICB2aWV3UG9ydC5jbGVhcigpO1xuXG4gICAgaWYgKGNhbnZhcy53aWR0aCAmJiBjYW52YXMuaGVpZ2h0KSB7XG4gICAgICB2aWV3UG9ydC5zZXRDdXJyZW50KGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZXdQb3J0LnNldEN1cnJlbnQoQ0xJRU5UX1dJRFRILCBDTElFTlRfSEVJR0hUKTtcbiAgICB9XG5cbiAgICB2YXIgd2lkdGhTdHlsZSA9IGVsZW1lbnQuZ2V0U3R5bGUoJ3dpZHRoJyk7XG4gICAgdmFyIGhlaWdodFN0eWxlID0gZWxlbWVudC5nZXRTdHlsZSgnaGVpZ2h0Jyk7XG5cbiAgICBpZiAoIWlnbm9yZURpbWVuc2lvbnMgJiYgKGlzRmlyc3RSZW5kZXIgfHwgdHlwZW9mIHNjYWxlV2lkdGggIT09ICdudW1iZXInICYmIHR5cGVvZiBzY2FsZUhlaWdodCAhPT0gJ251bWJlcicpKSB7XG4gICAgICAvLyBzZXQgY2FudmFzIHNpemVcbiAgICAgIGlmICh3aWR0aFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGhTdHlsZS5nZXRQaXhlbHMoJ3gnKTtcblxuICAgICAgICBpZiAoY2FudmFzLnN0eWxlKSB7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gXCJcIi5jb25jYXQoY2FudmFzLndpZHRoLCBcInB4XCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChoZWlnaHRTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHRTdHlsZS5nZXRQaXhlbHMoJ3knKTtcblxuICAgICAgICBpZiAoY2FudmFzLnN0eWxlKSB7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IFwiXCIuY29uY2F0KGNhbnZhcy5oZWlnaHQsIFwicHhcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY1dpZHRoID0gY2FudmFzLmNsaWVudFdpZHRoIHx8IGNhbnZhcy53aWR0aDtcbiAgICB2YXIgY0hlaWdodCA9IGNhbnZhcy5jbGllbnRIZWlnaHQgfHwgY2FudmFzLmhlaWdodDtcblxuICAgIGlmIChpZ25vcmVEaW1lbnNpb25zICYmIHdpZHRoU3R5bGUuaGFzVmFsdWUoKSAmJiBoZWlnaHRTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICBjV2lkdGggPSB3aWR0aFN0eWxlLmdldFBpeGVscygneCcpO1xuICAgICAgY0hlaWdodCA9IGhlaWdodFN0eWxlLmdldFBpeGVscygneScpO1xuICAgIH1cblxuICAgIHZpZXdQb3J0LnNldEN1cnJlbnQoY1dpZHRoLCBjSGVpZ2h0KTtcblxuICAgIGlmICh0eXBlb2Ygb2Zmc2V0WCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd4JywgdHJ1ZSkuc2V0VmFsdWUob2Zmc2V0WCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvZmZzZXRZID09PSAnbnVtYmVyJykge1xuICAgICAgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3knLCB0cnVlKS5zZXRWYWx1ZShvZmZzZXRZKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNjYWxlV2lkdGggPT09ICdudW1iZXInIHx8IHR5cGVvZiBzY2FsZUhlaWdodCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhciB2aWV3Qm94ID0gdG9OdW1iZXJzKGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd2aWV3Qm94JykuZ2V0U3RyaW5nKCkpO1xuICAgICAgdmFyIHhSYXRpbyA9IDA7XG4gICAgICB2YXIgeVJhdGlvID0gMDtcblxuICAgICAgaWYgKHR5cGVvZiBzY2FsZVdpZHRoID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgX3dpZHRoU3R5bGUgPSBlbGVtZW50LmdldFN0eWxlKCd3aWR0aCcpO1xuXG4gICAgICAgIGlmIChfd2lkdGhTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgeFJhdGlvID0gX3dpZHRoU3R5bGUuZ2V0UGl4ZWxzKCd4JykgLyBzY2FsZVdpZHRoO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc05hTih2aWV3Qm94WzJdKSkge1xuICAgICAgICAgIHhSYXRpbyA9IHZpZXdCb3hbMl0gLyBzY2FsZVdpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygc2NhbGVIZWlnaHQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBfaGVpZ2h0U3R5bGUgPSBlbGVtZW50LmdldFN0eWxlKCdoZWlnaHQnKTtcblxuICAgICAgICBpZiAoX2hlaWdodFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICB5UmF0aW8gPSBfaGVpZ2h0U3R5bGUuZ2V0UGl4ZWxzKCd5JykgLyBzY2FsZUhlaWdodDtcbiAgICAgICAgfSBlbHNlIGlmICghaXNOYU4odmlld0JveFszXSkpIHtcbiAgICAgICAgICB5UmF0aW8gPSB2aWV3Qm94WzNdIC8gc2NhbGVIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF4UmF0aW8pIHtcbiAgICAgICAgeFJhdGlvID0geVJhdGlvO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXlSYXRpbykge1xuICAgICAgICB5UmF0aW8gPSB4UmF0aW87XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd3aWR0aCcsIHRydWUpLnNldFZhbHVlKHNjYWxlV2lkdGgpO1xuICAgICAgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRydWUpLnNldFZhbHVlKHNjYWxlSGVpZ2h0KTtcbiAgICAgIHZhciB0cmFuc2Zvcm1TdHlsZSA9IGVsZW1lbnQuZ2V0U3R5bGUoJ3RyYW5zZm9ybScsIHRydWUsIHRydWUpO1xuICAgICAgdHJhbnNmb3JtU3R5bGUuc2V0VmFsdWUoXCJcIi5jb25jYXQodHJhbnNmb3JtU3R5bGUuZ2V0U3RyaW5nKCksIFwiIHNjYWxlKFwiKS5jb25jYXQoMS4wIC8geFJhdGlvLCBcIiwgXCIpLmNvbmNhdCgxLjAgLyB5UmF0aW8sIFwiKVwiKSk7XG4gICAgfSAvLyBjbGVhciBhbmQgcmVuZGVyXG5cblxuICAgIGlmICghaWdub3JlQ2xlYXIpIHtcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY1dpZHRoLCBjSGVpZ2h0KTtcbiAgICB9XG5cbiAgICBlbGVtZW50LnJlbmRlcihjdHgpO1xuXG4gICAgaWYgKGlzRmlyc3RSZW5kZXIpIHtcbiAgICAgIHRoaXMuaXNGaXJzdFJlbmRlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG59XG5TY3JlZW4uZGVmYXVsdFdpbmRvdyA9IGRlZmF1bHRXaW5kb3c7XG5TY3JlZW4uZGVmYXVsdEZldGNoID0gZGVmYXVsdEZldGNoJDE7XG5cbnZhciB7XG4gIGRlZmF1bHRGZXRjaFxufSA9IFNjcmVlbjtcbnZhciBEZWZhdWx0RE9NUGFyc2VyID0gdHlwZW9mIERPTVBhcnNlciAhPT0gJ3VuZGVmaW5lZCcgPyBET01QYXJzZXIgOiBudWxsO1xuY2xhc3MgUGFyc2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdmFyIHtcbiAgICAgIGZldGNoID0gZGVmYXVsdEZldGNoLFxuICAgICAgRE9NUGFyc2VyID0gRGVmYXVsdERPTVBhcnNlclxuICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHRoaXMuZmV0Y2ggPSBmZXRjaDtcbiAgICB0aGlzLkRPTVBhcnNlciA9IERPTVBhcnNlcjtcbiAgfVxuXG4gIHBhcnNlKHJlc291cmNlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHJlc291cmNlLnN0YXJ0c1dpdGgoJzwnKSkge1xuICAgICAgICByZXR1cm4gX3RoaXMucGFyc2VGcm9tU3RyaW5nKHJlc291cmNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzLmxvYWQocmVzb3VyY2UpO1xuICAgIH0pKCk7XG4gIH1cblxuICBwYXJzZUZyb21TdHJpbmcoeG1sKSB7XG4gICAgdmFyIHBhcnNlciA9IG5ldyB0aGlzLkRPTVBhcnNlcigpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLmNoZWNrRG9jdW1lbnQocGFyc2VyLnBhcnNlRnJvbVN0cmluZyh4bWwsICdpbWFnZS9zdmcreG1sJykpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHRoaXMuY2hlY2tEb2N1bWVudChwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHhtbCwgJ3RleHQveG1sJykpO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrRG9jdW1lbnQoZG9jdW1lbnQpIHtcbiAgICB2YXIgcGFyc2VyRXJyb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgncGFyc2VyZXJyb3InKVswXTtcblxuICAgIGlmIChwYXJzZXJFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHBhcnNlckVycm9yLnRleHRDb250ZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9jdW1lbnQ7XG4gIH1cblxuICBsb2FkKHVybCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgcmVzcG9uc2UgPSB5aWVsZCBfdGhpczIuZmV0Y2godXJsKTtcbiAgICAgIHZhciB4bWwgPSB5aWVsZCByZXNwb25zZS50ZXh0KCk7XG4gICAgICByZXR1cm4gX3RoaXMyLnBhcnNlRnJvbVN0cmluZyh4bWwpO1xuICAgIH0pKCk7XG4gIH1cblxufVxuXG5jbGFzcyBUcmFuc2xhdGUge1xuICBjb25zdHJ1Y3RvcihfLCBwb2ludCkge1xuICAgIHRoaXMudHlwZSA9ICd0cmFuc2xhdGUnO1xuICAgIHRoaXMucG9pbnQgPSBudWxsO1xuICAgIHRoaXMucG9pbnQgPSBQb2ludC5wYXJzZShwb2ludCk7XG4gIH1cblxuICBhcHBseShjdHgpIHtcbiAgICB2YXIge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gdGhpcy5wb2ludDtcbiAgICBjdHgudHJhbnNsYXRlKHggfHwgMC4wLCB5IHx8IDAuMCk7XG4gIH1cblxuICB1bmFwcGx5KGN0eCkge1xuICAgIHZhciB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSB0aGlzLnBvaW50O1xuICAgIGN0eC50cmFuc2xhdGUoLTEuMCAqIHggfHwgMC4wLCAtMS4wICogeSB8fCAwLjApO1xuICB9XG5cbiAgYXBwbHlUb1BvaW50KHBvaW50KSB7XG4gICAgdmFyIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHRoaXMucG9pbnQ7XG4gICAgcG9pbnQuYXBwbHlUcmFuc2Zvcm0oWzEsIDAsIDAsIDEsIHggfHwgMC4wLCB5IHx8IDAuMF0pO1xuICB9XG5cbn1cblxuY2xhc3MgUm90YXRlIHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIHJvdGF0ZSwgdHJhbnNmb3JtT3JpZ2luKSB7XG4gICAgdGhpcy50eXBlID0gJ3JvdGF0ZSc7XG4gICAgdGhpcy5hbmdsZSA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5YID0gbnVsbDtcbiAgICB0aGlzLm9yaWdpblkgPSBudWxsO1xuICAgIHRoaXMuY3ggPSAwO1xuICAgIHRoaXMuY3kgPSAwO1xuICAgIHZhciBudW1iZXJzID0gdG9OdW1iZXJzKHJvdGF0ZSk7XG4gICAgdGhpcy5hbmdsZSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ2FuZ2xlJywgbnVtYmVyc1swXSk7XG4gICAgdGhpcy5vcmlnaW5YID0gdHJhbnNmb3JtT3JpZ2luWzBdO1xuICAgIHRoaXMub3JpZ2luWSA9IHRyYW5zZm9ybU9yaWdpblsxXTtcbiAgICB0aGlzLmN4ID0gbnVtYmVyc1sxXSB8fCAwO1xuICAgIHRoaXMuY3kgPSBudW1iZXJzWzJdIHx8IDA7XG4gIH1cblxuICBhcHBseShjdHgpIHtcbiAgICB2YXIge1xuICAgICAgY3gsXG4gICAgICBjeSxcbiAgICAgIG9yaWdpblgsXG4gICAgICBvcmlnaW5ZLFxuICAgICAgYW5nbGVcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgdHggPSBjeCArIG9yaWdpblguZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIHR5ID0gY3kgKyBvcmlnaW5ZLmdldFBpeGVscygneScpO1xuICAgIGN0eC50cmFuc2xhdGUodHgsIHR5KTtcbiAgICBjdHgucm90YXRlKGFuZ2xlLmdldFJhZGlhbnMoKSk7XG4gICAgY3R4LnRyYW5zbGF0ZSgtdHgsIC10eSk7XG4gIH1cblxuICB1bmFwcGx5KGN0eCkge1xuICAgIHZhciB7XG4gICAgICBjeCxcbiAgICAgIGN5LFxuICAgICAgb3JpZ2luWCxcbiAgICAgIG9yaWdpblksXG4gICAgICBhbmdsZVxuICAgIH0gPSB0aGlzO1xuICAgIHZhciB0eCA9IGN4ICsgb3JpZ2luWC5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgdHkgPSBjeSArIG9yaWdpblkuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgY3R4LnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgIGN0eC5yb3RhdGUoLTEuMCAqIGFuZ2xlLmdldFJhZGlhbnMoKSk7XG4gICAgY3R4LnRyYW5zbGF0ZSgtdHgsIC10eSk7XG4gIH1cblxuICBhcHBseVRvUG9pbnQocG9pbnQpIHtcbiAgICB2YXIge1xuICAgICAgY3gsXG4gICAgICBjeSxcbiAgICAgIGFuZ2xlXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHJhZCA9IGFuZ2xlLmdldFJhZGlhbnMoKTtcbiAgICBwb2ludC5hcHBseVRyYW5zZm9ybShbMSwgMCwgMCwgMSwgY3ggfHwgMC4wLCBjeSB8fCAwLjAgLy8gdGhpcy5wLnlcbiAgICBdKTtcbiAgICBwb2ludC5hcHBseVRyYW5zZm9ybShbTWF0aC5jb3MocmFkKSwgTWF0aC5zaW4ocmFkKSwgLU1hdGguc2luKHJhZCksIE1hdGguY29zKHJhZCksIDAsIDBdKTtcbiAgICBwb2ludC5hcHBseVRyYW5zZm9ybShbMSwgMCwgMCwgMSwgLWN4IHx8IDAuMCwgLWN5IHx8IDAuMCAvLyAtdGhpcy5wLnlcbiAgICBdKTtcbiAgfVxuXG59XG5cbmNsYXNzIFNjYWxlIHtcbiAgY29uc3RydWN0b3IoXywgc2NhbGUsIHRyYW5zZm9ybU9yaWdpbikge1xuICAgIHRoaXMudHlwZSA9ICdzY2FsZSc7XG4gICAgdGhpcy5zY2FsZSA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5YID0gbnVsbDtcbiAgICB0aGlzLm9yaWdpblkgPSBudWxsO1xuICAgIHZhciBzY2FsZVNpemUgPSBQb2ludC5wYXJzZVNjYWxlKHNjYWxlKTsgLy8gV29ya2Fyb3VuZCBmb3Igbm9kZS1jYW52YXNcblxuICAgIGlmIChzY2FsZVNpemUueCA9PT0gMCB8fCBzY2FsZVNpemUueSA9PT0gMCkge1xuICAgICAgc2NhbGVTaXplLnggPSBQU0VVRE9fWkVSTztcbiAgICAgIHNjYWxlU2l6ZS55ID0gUFNFVURPX1pFUk87XG4gICAgfVxuXG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlU2l6ZTtcbiAgICB0aGlzLm9yaWdpblggPSB0cmFuc2Zvcm1PcmlnaW5bMF07XG4gICAgdGhpcy5vcmlnaW5ZID0gdHJhbnNmb3JtT3JpZ2luWzFdO1xuICB9XG5cbiAgYXBwbHkoY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIHNjYWxlOiB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0sXG4gICAgICBvcmlnaW5YLFxuICAgICAgb3JpZ2luWVxuICAgIH0gPSB0aGlzO1xuICAgIHZhciB0eCA9IG9yaWdpblguZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIHR5ID0gb3JpZ2luWS5nZXRQaXhlbHMoJ3knKTtcbiAgICBjdHgudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgY3R4LnNjYWxlKHgsIHkgfHwgeCk7XG4gICAgY3R4LnRyYW5zbGF0ZSgtdHgsIC10eSk7XG4gIH1cblxuICB1bmFwcGx5KGN0eCkge1xuICAgIHZhciB7XG4gICAgICBzY2FsZToge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9LFxuICAgICAgb3JpZ2luWCxcbiAgICAgIG9yaWdpbllcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgdHggPSBvcmlnaW5YLmdldFBpeGVscygneCcpO1xuICAgIHZhciB0eSA9IG9yaWdpblkuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgY3R4LnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgIGN0eC5zY2FsZSgxLjAgLyB4LCAxLjAgLyB5IHx8IHgpO1xuICAgIGN0eC50cmFuc2xhdGUoLXR4LCAtdHkpO1xuICB9XG5cbiAgYXBwbHlUb1BvaW50KHBvaW50KSB7XG4gICAgdmFyIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHRoaXMuc2NhbGU7XG4gICAgcG9pbnQuYXBwbHlUcmFuc2Zvcm0oW3ggfHwgMC4wLCAwLCAwLCB5IHx8IDAuMCwgMCwgMF0pO1xuICB9XG5cbn1cblxuY2xhc3MgTWF0cml4IHtcbiAgY29uc3RydWN0b3IoXywgbWF0cml4LCB0cmFuc2Zvcm1PcmlnaW4pIHtcbiAgICB0aGlzLnR5cGUgPSAnbWF0cml4JztcbiAgICB0aGlzLm1hdHJpeCA9IFtdO1xuICAgIHRoaXMub3JpZ2luWCA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5ZID0gbnVsbDtcbiAgICB0aGlzLm1hdHJpeCA9IHRvTnVtYmVycyhtYXRyaXgpO1xuICAgIHRoaXMub3JpZ2luWCA9IHRyYW5zZm9ybU9yaWdpblswXTtcbiAgICB0aGlzLm9yaWdpblkgPSB0cmFuc2Zvcm1PcmlnaW5bMV07XG4gIH1cblxuICBhcHBseShjdHgpIHtcbiAgICB2YXIge1xuICAgICAgb3JpZ2luWCxcbiAgICAgIG9yaWdpblksXG4gICAgICBtYXRyaXhcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgdHggPSBvcmlnaW5YLmdldFBpeGVscygneCcpO1xuICAgIHZhciB0eSA9IG9yaWdpblkuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgY3R4LnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgIGN0eC50cmFuc2Zvcm0obWF0cml4WzBdLCBtYXRyaXhbMV0sIG1hdHJpeFsyXSwgbWF0cml4WzNdLCBtYXRyaXhbNF0sIG1hdHJpeFs1XSk7XG4gICAgY3R4LnRyYW5zbGF0ZSgtdHgsIC10eSk7XG4gIH1cblxuICB1bmFwcGx5KGN0eCkge1xuICAgIHZhciB7XG4gICAgICBvcmlnaW5YLFxuICAgICAgb3JpZ2luWSxcbiAgICAgIG1hdHJpeFxuICAgIH0gPSB0aGlzO1xuICAgIHZhciBhID0gbWF0cml4WzBdO1xuICAgIHZhciBiID0gbWF0cml4WzJdO1xuICAgIHZhciBjID0gbWF0cml4WzRdO1xuICAgIHZhciBkID0gbWF0cml4WzFdO1xuICAgIHZhciBlID0gbWF0cml4WzNdO1xuICAgIHZhciBmID0gbWF0cml4WzVdO1xuICAgIHZhciBnID0gMC4wO1xuICAgIHZhciBoID0gMC4wO1xuICAgIHZhciBpID0gMS4wO1xuICAgIHZhciBkZXQgPSAxIC8gKGEgKiAoZSAqIGkgLSBmICogaCkgLSBiICogKGQgKiBpIC0gZiAqIGcpICsgYyAqIChkICogaCAtIGUgKiBnKSk7XG4gICAgdmFyIHR4ID0gb3JpZ2luWC5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgdHkgPSBvcmlnaW5ZLmdldFBpeGVscygneScpO1xuICAgIGN0eC50cmFuc2xhdGUodHgsIHR5KTtcbiAgICBjdHgudHJhbnNmb3JtKGRldCAqIChlICogaSAtIGYgKiBoKSwgZGV0ICogKGYgKiBnIC0gZCAqIGkpLCBkZXQgKiAoYyAqIGggLSBiICogaSksIGRldCAqIChhICogaSAtIGMgKiBnKSwgZGV0ICogKGIgKiBmIC0gYyAqIGUpLCBkZXQgKiAoYyAqIGQgLSBhICogZikpO1xuICAgIGN0eC50cmFuc2xhdGUoLXR4LCAtdHkpO1xuICB9XG5cbiAgYXBwbHlUb1BvaW50KHBvaW50KSB7XG4gICAgcG9pbnQuYXBwbHlUcmFuc2Zvcm0odGhpcy5tYXRyaXgpO1xuICB9XG5cbn1cblxuY2xhc3MgU2tldyBleHRlbmRzIE1hdHJpeCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBza2V3LCB0cmFuc2Zvcm1PcmlnaW4pIHtcbiAgICBzdXBlcihkb2N1bWVudCwgc2tldywgdHJhbnNmb3JtT3JpZ2luKTtcbiAgICB0aGlzLnR5cGUgPSAnc2tldyc7XG4gICAgdGhpcy5hbmdsZSA9IG51bGw7XG4gICAgdGhpcy5hbmdsZSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ2FuZ2xlJywgc2tldyk7XG4gIH1cblxufVxuXG5jbGFzcyBTa2V3WCBleHRlbmRzIFNrZXcge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgc2tldywgdHJhbnNmb3JtT3JpZ2luKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIHNrZXcsIHRyYW5zZm9ybU9yaWdpbik7XG4gICAgdGhpcy50eXBlID0gJ3NrZXdYJztcbiAgICB0aGlzLm1hdHJpeCA9IFsxLCAwLCBNYXRoLnRhbih0aGlzLmFuZ2xlLmdldFJhZGlhbnMoKSksIDEsIDAsIDBdO1xuICB9XG5cbn1cblxuY2xhc3MgU2tld1kgZXh0ZW5kcyBTa2V3IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIHNrZXcsIHRyYW5zZm9ybU9yaWdpbikge1xuICAgIHN1cGVyKGRvY3VtZW50LCBza2V3LCB0cmFuc2Zvcm1PcmlnaW4pO1xuICAgIHRoaXMudHlwZSA9ICdza2V3WSc7XG4gICAgdGhpcy5tYXRyaXggPSBbMSwgTWF0aC50YW4odGhpcy5hbmdsZS5nZXRSYWRpYW5zKCkpLCAwLCAxLCAwLCAwXTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIHBhcnNlVHJhbnNmb3Jtcyh0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGNvbXByZXNzU3BhY2VzKHRyYW5zZm9ybSkudHJpbSgpLnJlcGxhY2UoL1xcKShbYS16QS1aXSkvZywgJykgJDEnKS5yZXBsYWNlKC9cXCkoXFxzPyxcXHM/KS9nLCAnKSAnKS5zcGxpdCgvXFxzKD89W2Etel0pLyk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuICB2YXIgW3R5cGUsIHZhbHVlXSA9IHRyYW5zZm9ybS5zcGxpdCgnKCcpO1xuICByZXR1cm4gW3R5cGUudHJpbSgpLCB2YWx1ZS50cmltKCkucmVwbGFjZSgnKScsICcnKV07XG59XG5cbmNsYXNzIFRyYW5zZm9ybSB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCB0cmFuc2Zvcm0sIHRyYW5zZm9ybU9yaWdpbikge1xuICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB0aGlzLnRyYW5zZm9ybXMgPSBbXTtcbiAgICB2YXIgZGF0YSA9IHBhcnNlVHJhbnNmb3Jtcyh0cmFuc2Zvcm0pO1xuICAgIGRhdGEuZm9yRWFjaCh0cmFuc2Zvcm0gPT4ge1xuICAgICAgaWYgKHRyYW5zZm9ybSA9PT0gJ25vbmUnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIFt0eXBlLCB2YWx1ZV0gPSBwYXJzZVRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICAgICAgdmFyIFRyYW5zZm9ybVR5cGUgPSBUcmFuc2Zvcm0udHJhbnNmb3JtVHlwZXNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgVHJhbnNmb3JtVHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1zLnB1c2gobmV3IFRyYW5zZm9ybVR5cGUodGhpcy5kb2N1bWVudCwgdmFsdWUsIHRyYW5zZm9ybU9yaWdpbikpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGZyb21FbGVtZW50KGRvY3VtZW50LCBlbGVtZW50KSB7XG4gICAgdmFyIHRyYW5zZm9ybVN0eWxlID0gZWxlbWVudC5nZXRTdHlsZSgndHJhbnNmb3JtJywgZmFsc2UsIHRydWUpO1xuICAgIHZhciBbdHJhbnNmb3JtT3JpZ2luWFByb3BlcnR5LCB0cmFuc2Zvcm1PcmlnaW5ZUHJvcGVydHkgPSB0cmFuc2Zvcm1PcmlnaW5YUHJvcGVydHldID0gZWxlbWVudC5nZXRTdHlsZSgndHJhbnNmb3JtLW9yaWdpbicsIGZhbHNlLCB0cnVlKS5zcGxpdCgpO1xuICAgIHZhciB0cmFuc2Zvcm1PcmlnaW4gPSBbdHJhbnNmb3JtT3JpZ2luWFByb3BlcnR5LCB0cmFuc2Zvcm1PcmlnaW5ZUHJvcGVydHldO1xuXG4gICAgaWYgKHRyYW5zZm9ybVN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKGRvY3VtZW50LCB0cmFuc2Zvcm1TdHlsZS5nZXRTdHJpbmcoKSwgdHJhbnNmb3JtT3JpZ2luKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGFwcGx5KGN0eCkge1xuICAgIHZhciB7XG4gICAgICB0cmFuc2Zvcm1zXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIGxlbiA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdHJhbnNmb3Jtc1tpXS5hcHBseShjdHgpO1xuICAgIH1cbiAgfVxuXG4gIHVuYXBwbHkoY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIHRyYW5zZm9ybXNcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgbGVuID0gdHJhbnNmb3Jtcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRyYW5zZm9ybXNbaV0udW5hcHBseShjdHgpO1xuICAgIH1cbiAgfSAvLyBUT0RPOiBhcHBseVRvUG9pbnQgdW51c2VkIC4uLiByZW1vdmU/XG5cblxuICBhcHBseVRvUG9pbnQocG9pbnQpIHtcbiAgICB2YXIge1xuICAgICAgdHJhbnNmb3Jtc1xuICAgIH0gPSB0aGlzO1xuICAgIHZhciBsZW4gPSB0cmFuc2Zvcm1zLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRyYW5zZm9ybXNbaV0uYXBwbHlUb1BvaW50KHBvaW50KTtcbiAgICB9XG4gIH1cblxufVxuVHJhbnNmb3JtLnRyYW5zZm9ybVR5cGVzID0ge1xuICB0cmFuc2xhdGU6IFRyYW5zbGF0ZSxcbiAgcm90YXRlOiBSb3RhdGUsXG4gIHNjYWxlOiBTY2FsZSxcbiAgbWF0cml4OiBNYXRyaXgsXG4gIHNrZXdYOiBTa2V3WCxcbiAgc2tld1k6IFNrZXdZXG59O1xuXG5jbGFzcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUpIHtcbiAgICB2YXIgY2FwdHVyZVRleHROb2RlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgdGhpcy5jYXB0dXJlVGV4dE5vZGVzID0gY2FwdHVyZVRleHROb2RlcztcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuc3R5bGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnN0eWxlc1NwZWNpZmljaXR5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmFuaW1hdGlvbkZyb3plbiA9IGZhbHNlO1xuICAgIHRoaXMuYW5pbWF0aW9uRnJvemVuVmFsdWUgPSAnJztcbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuXG4gICAgaWYgKCFub2RlIHx8IG5vZGUubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgIC8vIEVMRU1FTlRfTk9ERVxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYWRkIGF0dHJpYnV0ZXNcblxuXG4gICAgQXJyYXkuZnJvbShub2RlLmF0dHJpYnV0ZXMpLmZvckVhY2goYXR0cmlidXRlID0+IHtcbiAgICAgIHZhciBub2RlTmFtZSA9IG5vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUoYXR0cmlidXRlLm5vZGVOYW1lKTtcbiAgICAgIHRoaXMuYXR0cmlidXRlc1tub2RlTmFtZV0gPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsIG5vZGVOYW1lLCBhdHRyaWJ1dGUudmFsdWUpO1xuICAgIH0pO1xuICAgIHRoaXMuYWRkU3R5bGVzRnJvbVN0eWxlRGVmaW5pdGlvbigpOyAvLyBhZGQgaW5saW5lIHN0eWxlc1xuXG4gICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCdzdHlsZScpLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHZhciBzdHlsZXMgPSB0aGlzLmdldEF0dHJpYnV0ZSgnc3R5bGUnKS5nZXRTdHJpbmcoKS5zcGxpdCgnOycpLm1hcChfID0+IF8udHJpbSgpKTtcbiAgICAgIHN0eWxlcy5mb3JFYWNoKHN0eWxlID0+IHtcbiAgICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBbbmFtZSwgdmFsdWVdID0gc3R5bGUuc3BsaXQoJzonKS5tYXAoXyA9PiBfLnRyaW0oKSk7XG4gICAgICAgIHRoaXMuc3R5bGVzW25hbWVdID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCBuYW1lLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIge1xuICAgICAgZGVmaW5pdGlvbnNcbiAgICB9ID0gZG9jdW1lbnQ7XG4gICAgdmFyIGlkID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2lkJyk7IC8vIGFkZCBpZFxuXG4gICAgaWYgKGlkLmhhc1ZhbHVlKCkpIHtcbiAgICAgIGlmICghZGVmaW5pdGlvbnNbaWQuZ2V0U3RyaW5nKCldKSB7XG4gICAgICAgIGRlZmluaXRpb25zW2lkLmdldFN0cmluZygpXSA9IHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgQXJyYXkuZnJvbShub2RlLmNoaWxkTm9kZXMpLmZvckVhY2goY2hpbGROb2RlID0+IHtcbiAgICAgIGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgdGhpcy5hZGRDaGlsZChjaGlsZE5vZGUpOyAvLyBFTEVNRU5UX05PREVcbiAgICAgIH0gZWxzZSBpZiAoY2FwdHVyZVRleHROb2RlcyAmJiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSAzIHx8IGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gNCkpIHtcbiAgICAgICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY2hpbGROb2RlKTtcblxuICAgICAgICBpZiAodGV4dE5vZGUuZ2V0VGV4dCgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLmFkZENoaWxkKHRleHROb2RlKTsgLy8gVEVYVF9OT0RFXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGdldEF0dHJpYnV0ZShuYW1lKSB7XG4gICAgdmFyIGNyZWF0ZUlmTm90RXhpc3RzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICB2YXIgYXR0ciA9IHRoaXMuYXR0cmlidXRlc1tuYW1lXTtcblxuICAgIGlmICghYXR0ciAmJiBjcmVhdGVJZk5vdEV4aXN0cykge1xuICAgICAgdmFyIF9hdHRyID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsIG5hbWUsICcnKTtcblxuICAgICAgdGhpcy5hdHRyaWJ1dGVzW25hbWVdID0gX2F0dHI7XG4gICAgICByZXR1cm4gX2F0dHI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF0dHIgfHwgUHJvcGVydHkuZW1wdHkodGhpcy5kb2N1bWVudCk7XG4gIH1cblxuICBnZXRIcmVmQXR0cmlidXRlKCkge1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdocmVmJyB8fCBrZXkuZW5kc1dpdGgoJzpocmVmJykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1trZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9wZXJ0eS5lbXB0eSh0aGlzLmRvY3VtZW50KTtcbiAgfVxuXG4gIGdldFN0eWxlKG5hbWUpIHtcbiAgICB2YXIgY3JlYXRlSWZOb3RFeGlzdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgIHZhciBza2lwQW5jZXN0b3JzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlc1tuYW1lXTtcblxuICAgIGlmIChzdHlsZSkge1xuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH1cblxuICAgIHZhciBhdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSk7XG5cbiAgICBpZiAoYXR0ciAhPT0gbnVsbCAmJiBhdHRyICE9PSB2b2lkIDAgJiYgYXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICB0aGlzLnN0eWxlc1tuYW1lXSA9IGF0dHI7IC8vIG1vdmUgdXAgdG8gbWUgdG8gY2FjaGVcblxuICAgICAgcmV0dXJuIGF0dHI7XG4gICAgfVxuXG4gICAgaWYgKCFza2lwQW5jZXN0b3JzKSB7XG4gICAgICB2YXIge1xuICAgICAgICBwYXJlbnRcbiAgICAgIH0gPSB0aGlzO1xuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHZhciBwYXJlbnRTdHlsZSA9IHBhcmVudC5nZXRTdHlsZShuYW1lKTtcblxuICAgICAgICBpZiAocGFyZW50U3R5bGUgIT09IG51bGwgJiYgcGFyZW50U3R5bGUgIT09IHZvaWQgMCAmJiBwYXJlbnRTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmVudFN0eWxlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNyZWF0ZUlmTm90RXhpc3RzKSB7XG4gICAgICB2YXIgX3N0eWxlID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsIG5hbWUsICcnKTtcblxuICAgICAgdGhpcy5zdHlsZXNbbmFtZV0gPSBfc3R5bGU7XG4gICAgICByZXR1cm4gX3N0eWxlO1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZSB8fCBQcm9wZXJ0eS5lbXB0eSh0aGlzLmRvY3VtZW50KTtcbiAgfVxuXG4gIHJlbmRlcihjdHgpIHtcbiAgICAvLyBkb24ndCByZW5kZXIgZGlzcGxheT1ub25lXG4gICAgLy8gZG9uJ3QgcmVuZGVyIHZpc2liaWxpdHk9aGlkZGVuXG4gICAgaWYgKHRoaXMuZ2V0U3R5bGUoJ2Rpc3BsYXknKS5nZXRTdHJpbmcoKSA9PT0gJ25vbmUnIHx8IHRoaXMuZ2V0U3R5bGUoJ3Zpc2liaWxpdHknKS5nZXRTdHJpbmcoKSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdHguc2F2ZSgpO1xuXG4gICAgaWYgKHRoaXMuZ2V0U3R5bGUoJ21hc2snKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAvLyBtYXNrXG4gICAgICB2YXIgbWFzayA9IHRoaXMuZ2V0U3R5bGUoJ21hc2snKS5nZXREZWZpbml0aW9uKCk7XG5cbiAgICAgIGlmIChtYXNrKSB7XG4gICAgICAgIHRoaXMuYXBwbHlFZmZlY3RzKGN0eCk7XG4gICAgICAgIG1hc2suYXBwbHkoY3R4LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuZ2V0U3R5bGUoJ2ZpbHRlcicpLmdldFZhbHVlKCdub25lJykgIT09ICdub25lJykge1xuICAgICAgLy8gZmlsdGVyXG4gICAgICB2YXIgZmlsdGVyID0gdGhpcy5nZXRTdHlsZSgnZmlsdGVyJykuZ2V0RGVmaW5pdGlvbigpO1xuXG4gICAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAgIHRoaXMuYXBwbHlFZmZlY3RzKGN0eCk7XG4gICAgICAgIGZpbHRlci5hcHBseShjdHgsIHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldENvbnRleHQoY3R4KTtcbiAgICAgIHRoaXMucmVuZGVyQ2hpbGRyZW4oY3R4KTtcbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0KGN0eCk7XG4gICAgfVxuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG4gIHNldENvbnRleHQoXykgey8vIE5PIFJFTkRFUlxuICB9XG5cbiAgYXBwbHlFZmZlY3RzKGN0eCkge1xuICAgIC8vIHRyYW5zZm9ybVxuICAgIHZhciB0cmFuc2Zvcm0gPSBUcmFuc2Zvcm0uZnJvbUVsZW1lbnQodGhpcy5kb2N1bWVudCwgdGhpcyk7XG5cbiAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICB0cmFuc2Zvcm0uYXBwbHkoY3R4KTtcbiAgICB9IC8vIGNsaXBcblxuXG4gICAgdmFyIGNsaXBQYXRoU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnY2xpcC1wYXRoJywgZmFsc2UsIHRydWUpO1xuXG4gICAgaWYgKGNsaXBQYXRoU3R5bGVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHZhciBjbGlwID0gY2xpcFBhdGhTdHlsZVByb3AuZ2V0RGVmaW5pdGlvbigpO1xuXG4gICAgICBpZiAoY2xpcCkge1xuICAgICAgICBjbGlwLmFwcGx5KGN0eCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2xlYXJDb250ZXh0KF8pIHsvLyBOTyBSRU5ERVJcbiAgfVxuXG4gIHJlbmRlckNoaWxkcmVuKGN0eCkge1xuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICBjaGlsZC5yZW5kZXIoY3R4KTtcbiAgICB9KTtcbiAgfVxuXG4gIGFkZENoaWxkKGNoaWxkTm9kZSkge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkTm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQgPyBjaGlsZE5vZGUgOiB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoY2hpbGROb2RlKTtcbiAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuXG4gICAgaWYgKCFFbGVtZW50Lmlnbm9yZUNoaWxkVHlwZXMuaW5jbHVkZXMoY2hpbGQudHlwZSkpIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG5cbiAgbWF0Y2hlc1NlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgdmFyIF9ub2RlJGdldEF0dHJpYnV0ZTtcblxuICAgIHZhciB7XG4gICAgICBub2RlXG4gICAgfSA9IHRoaXM7XG5cbiAgICBpZiAodHlwZW9mIG5vZGUubWF0Y2hlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG5vZGUubWF0Y2hlcyhzZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlQ2xhc3NlcyA9IChfbm9kZSRnZXRBdHRyaWJ1dGUgPSBub2RlLmdldEF0dHJpYnV0ZSkgPT09IG51bGwgfHwgX25vZGUkZ2V0QXR0cmlidXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZSRnZXRBdHRyaWJ1dGUuY2FsbChub2RlLCAnY2xhc3MnKTtcblxuICAgIGlmICghc3R5bGVDbGFzc2VzIHx8IHN0eWxlQ2xhc3NlcyA9PT0gJycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGVDbGFzc2VzLnNwbGl0KCcgJykuc29tZShzdHlsZUNsYXNzID0+IFwiLlwiLmNvbmNhdChzdHlsZUNsYXNzKSA9PT0gc2VsZWN0b3IpO1xuICB9XG5cbiAgYWRkU3R5bGVzRnJvbVN0eWxlRGVmaW5pdGlvbigpIHtcbiAgICB2YXIge1xuICAgICAgc3R5bGVzLFxuICAgICAgc3R5bGVzU3BlY2lmaWNpdHlcbiAgICB9ID0gdGhpcy5kb2N1bWVudDtcblxuICAgIGZvciAodmFyIHNlbGVjdG9yIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzZWxlY3Rvci5zdGFydHNXaXRoKCdAJykgJiYgdGhpcy5tYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHN0eWxlc1tzZWxlY3Rvcl07XG4gICAgICAgIHZhciBzcGVjaWZpY2l0eSA9IHN0eWxlc1NwZWNpZmljaXR5W3NlbGVjdG9yXTtcblxuICAgICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIHN0eWxlKSB7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdTcGVjaWZpY2l0eSA9IHRoaXMuc3R5bGVzU3BlY2lmaWNpdHlbbmFtZV07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXhpc3RpbmdTcGVjaWZpY2l0eSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgZXhpc3RpbmdTcGVjaWZpY2l0eSA9ICcwMDAnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3BlY2lmaWNpdHkgPj0gZXhpc3RpbmdTcGVjaWZpY2l0eSkge1xuICAgICAgICAgICAgICB0aGlzLnN0eWxlc1tuYW1lXSA9IHN0eWxlW25hbWVdO1xuICAgICAgICAgICAgICB0aGlzLnN0eWxlc1NwZWNpZmljaXR5W25hbWVdID0gc3BlY2lmaWNpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlU3R5bGVzKGVsZW1lbnQsIGlnbm9yZVN0eWxlcykge1xuICAgIHZhciB0b1Jlc3RvcmUgPSBpZ25vcmVTdHlsZXMucmVkdWNlKCh0b1Jlc3RvcmUsIG5hbWUpID0+IHtcbiAgICAgIHZhciBzdHlsZVByb3AgPSBlbGVtZW50LmdldFN0eWxlKG5hbWUpO1xuXG4gICAgICBpZiAoIXN0eWxlUHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHJldHVybiB0b1Jlc3RvcmU7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9IHN0eWxlUHJvcC5nZXRTdHJpbmcoKTtcbiAgICAgIHN0eWxlUHJvcC5zZXRWYWx1ZSgnJyk7XG4gICAgICByZXR1cm4gWy4uLnRvUmVzdG9yZSwgW25hbWUsIHZhbHVlXV07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiB0b1Jlc3RvcmU7XG4gIH1cblxuICByZXN0b3JlU3R5bGVzKGVsZW1lbnQsIHN0eWxlcykge1xuICAgIHN0eWxlcy5mb3JFYWNoKF9yZWYgPT4ge1xuICAgICAgdmFyIFtuYW1lLCB2YWx1ZV0gPSBfcmVmO1xuICAgICAgZWxlbWVudC5nZXRTdHlsZShuYW1lLCB0cnVlKS5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgfSk7XG4gIH1cblxuICBpc0ZpcnN0Q2hpbGQoKSB7XG4gICAgdmFyIF90aGlzJHBhcmVudDtcblxuICAgIHJldHVybiAoKF90aGlzJHBhcmVudCA9IHRoaXMucGFyZW50KSA9PT0gbnVsbCB8fCBfdGhpcyRwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJHBhcmVudC5jaGlsZHJlbi5pbmRleE9mKHRoaXMpKSA9PT0gMDtcbiAgfVxuXG59XG5FbGVtZW50Lmlnbm9yZUNoaWxkVHlwZXMgPSBbJ3RpdGxlJ107XG5cbmNsYXNzIFVua25vd25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gd3JhcEZvbnRGYW1pbHkoZm9udEZhbWlseSkge1xuICB2YXIgdHJpbW1lZCA9IGZvbnRGYW1pbHkudHJpbSgpO1xuICByZXR1cm4gL14oJ3xcIikvLnRlc3QodHJpbW1lZCkgPyB0cmltbWVkIDogXCJcXFwiXCIuY29uY2F0KHRyaW1tZWQsIFwiXFxcIlwiKTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZUZvbnRGYW1pbHkoZm9udEZhbWlseSkge1xuICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnID8gZm9udEZhbWlseSA6IGZvbnRGYW1pbHkudHJpbSgpLnNwbGl0KCcsJykubWFwKHdyYXBGb250RmFtaWx5KS5qb2luKCcsJyk7XG59XG4vKipcclxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2ZvbnQtc3R5bGVcclxuICogQHBhcmFtIGZvbnRTdHlsZVxyXG4gKiBAcmV0dXJucyBDU1MgZm9udCBzdHlsZS5cclxuICovXG5cblxuZnVuY3Rpb24gcHJlcGFyZUZvbnRTdHlsZShmb250U3R5bGUpIHtcbiAgaWYgKCFmb250U3R5bGUpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgdGFyZ2V0Rm9udFN0eWxlID0gZm9udFN0eWxlLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHN3aXRjaCAodGFyZ2V0Rm9udFN0eWxlKSB7XG4gICAgY2FzZSAnbm9ybWFsJzpcbiAgICBjYXNlICdpdGFsaWMnOlxuICAgIGNhc2UgJ29ibGlxdWUnOlxuICAgIGNhc2UgJ2luaGVyaXQnOlxuICAgIGNhc2UgJ2luaXRpYWwnOlxuICAgIGNhc2UgJ3Vuc2V0JzpcbiAgICAgIHJldHVybiB0YXJnZXRGb250U3R5bGU7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKC9eb2JsaXF1ZVxccysoLXwpXFxkK2RlZyQvLnRlc3QodGFyZ2V0Rm9udFN0eWxlKSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0Rm9udFN0eWxlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn1cbi8qKlxyXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZm9udC13ZWlnaHRcclxuICogQHBhcmFtIGZvbnRXZWlnaHRcclxuICogQHJldHVybnMgQ1NTIGZvbnQgd2VpZ2h0LlxyXG4gKi9cblxuXG5mdW5jdGlvbiBwcmVwYXJlRm9udFdlaWdodChmb250V2VpZ2h0KSB7XG4gIGlmICghZm9udFdlaWdodCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciB0YXJnZXRGb250V2VpZ2h0ID0gZm9udFdlaWdodC50cmltKCkudG9Mb3dlckNhc2UoKTtcblxuICBzd2l0Y2ggKHRhcmdldEZvbnRXZWlnaHQpIHtcbiAgICBjYXNlICdub3JtYWwnOlxuICAgIGNhc2UgJ2JvbGQnOlxuICAgIGNhc2UgJ2xpZ2h0ZXInOlxuICAgIGNhc2UgJ2JvbGRlcic6XG4gICAgY2FzZSAnaW5oZXJpdCc6XG4gICAgY2FzZSAnaW5pdGlhbCc6XG4gICAgY2FzZSAndW5zZXQnOlxuICAgICAgcmV0dXJuIHRhcmdldEZvbnRXZWlnaHQ7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKC9eW1xcZC5dKyQvLnRlc3QodGFyZ2V0Rm9udFdlaWdodCkpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldEZvbnRXZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5jbGFzcyBGb250IHtcbiAgY29uc3RydWN0b3IoZm9udFN0eWxlLCBmb250VmFyaWFudCwgZm9udFdlaWdodCwgZm9udFNpemUsIGZvbnRGYW1pbHksIGluaGVyaXQpIHtcbiAgICB2YXIgaW5oZXJpdEZvbnQgPSBpbmhlcml0ID8gdHlwZW9mIGluaGVyaXQgPT09ICdzdHJpbmcnID8gRm9udC5wYXJzZShpbmhlcml0KSA6IGluaGVyaXQgOiB7fTtcbiAgICB0aGlzLmZvbnRGYW1pbHkgPSBmb250RmFtaWx5IHx8IGluaGVyaXRGb250LmZvbnRGYW1pbHk7XG4gICAgdGhpcy5mb250U2l6ZSA9IGZvbnRTaXplIHx8IGluaGVyaXRGb250LmZvbnRTaXplO1xuICAgIHRoaXMuZm9udFN0eWxlID0gZm9udFN0eWxlIHx8IGluaGVyaXRGb250LmZvbnRTdHlsZTtcbiAgICB0aGlzLmZvbnRXZWlnaHQgPSBmb250V2VpZ2h0IHx8IGluaGVyaXRGb250LmZvbnRXZWlnaHQ7XG4gICAgdGhpcy5mb250VmFyaWFudCA9IGZvbnRWYXJpYW50IHx8IGluaGVyaXRGb250LmZvbnRWYXJpYW50O1xuICB9XG5cbiAgc3RhdGljIHBhcnNlKCkge1xuICAgIHZhciBmb250ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnJztcbiAgICB2YXIgaW5oZXJpdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBmb250U3R5bGUgPSAnJztcbiAgICB2YXIgZm9udFZhcmlhbnQgPSAnJztcbiAgICB2YXIgZm9udFdlaWdodCA9ICcnO1xuICAgIHZhciBmb250U2l6ZSA9ICcnO1xuICAgIHZhciBmb250RmFtaWx5ID0gJyc7XG4gICAgdmFyIHBhcnRzID0gY29tcHJlc3NTcGFjZXMoZm9udCkudHJpbSgpLnNwbGl0KCcgJyk7XG4gICAgdmFyIHNldCA9IHtcbiAgICAgIGZvbnRTaXplOiBmYWxzZSxcbiAgICAgIGZvbnRTdHlsZTogZmFsc2UsXG4gICAgICBmb250V2VpZ2h0OiBmYWxzZSxcbiAgICAgIGZvbnRWYXJpYW50OiBmYWxzZVxuICAgIH07XG4gICAgcGFydHMuZm9yRWFjaChwYXJ0ID0+IHtcbiAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICBjYXNlICFzZXQuZm9udFN0eWxlICYmIEZvbnQuc3R5bGVzLmluY2x1ZGVzKHBhcnQpOlxuICAgICAgICAgIGlmIChwYXJ0ICE9PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICAgIGZvbnRTdHlsZSA9IHBhcnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2V0LmZvbnRTdHlsZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAhc2V0LmZvbnRWYXJpYW50ICYmIEZvbnQudmFyaWFudHMuaW5jbHVkZXMocGFydCk6XG4gICAgICAgICAgaWYgKHBhcnQgIT09ICdpbmhlcml0Jykge1xuICAgICAgICAgICAgZm9udFZhcmlhbnQgPSBwYXJ0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldC5mb250U3R5bGUgPSB0cnVlO1xuICAgICAgICAgIHNldC5mb250VmFyaWFudCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAhc2V0LmZvbnRXZWlnaHQgJiYgRm9udC53ZWlnaHRzLmluY2x1ZGVzKHBhcnQpOlxuICAgICAgICAgIGlmIChwYXJ0ICE9PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICAgIGZvbnRXZWlnaHQgPSBwYXJ0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldC5mb250U3R5bGUgPSB0cnVlO1xuICAgICAgICAgIHNldC5mb250VmFyaWFudCA9IHRydWU7XG4gICAgICAgICAgc2V0LmZvbnRXZWlnaHQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgIXNldC5mb250U2l6ZTpcbiAgICAgICAgICBpZiAocGFydCAhPT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgICBbZm9udFNpemVdID0gcGFydC5zcGxpdCgnLycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldC5mb250U3R5bGUgPSB0cnVlO1xuICAgICAgICAgIHNldC5mb250VmFyaWFudCA9IHRydWU7XG4gICAgICAgICAgc2V0LmZvbnRXZWlnaHQgPSB0cnVlO1xuICAgICAgICAgIHNldC5mb250U2l6ZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAocGFydCAhPT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgICBmb250RmFtaWx5ICs9IHBhcnQ7XG4gICAgICAgICAgfVxuXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBGb250KGZvbnRTdHlsZSwgZm9udFZhcmlhbnQsIGZvbnRXZWlnaHQsIGZvbnRTaXplLCBmb250RmFtaWx5LCBpbmhlcml0KTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBbcHJlcGFyZUZvbnRTdHlsZSh0aGlzLmZvbnRTdHlsZSksIHRoaXMuZm9udFZhcmlhbnQsIHByZXBhcmVGb250V2VpZ2h0KHRoaXMuZm9udFdlaWdodCksIHRoaXMuZm9udFNpemUsIC8vIFdyYXAgZm9udEZhbWlseSBvbmx5IG9uIG5vZGVqcyBhbmQgb25seSBmb3IgY2FudmFzLmN0eFxuICAgIHByZXBhcmVGb250RmFtaWx5KHRoaXMuZm9udEZhbWlseSldLmpvaW4oJyAnKS50cmltKCk7XG4gIH1cblxufVxuRm9udC5zdHlsZXMgPSAnbm9ybWFsfGl0YWxpY3xvYmxpcXVlfGluaGVyaXQnO1xuRm9udC52YXJpYW50cyA9ICdub3JtYWx8c21hbGwtY2Fwc3xpbmhlcml0JztcbkZvbnQud2VpZ2h0cyA9ICdub3JtYWx8Ym9sZHxib2xkZXJ8bGlnaHRlcnwxMDB8MjAwfDMwMHw0MDB8NTAwfDYwMHw3MDB8ODAwfDkwMHxpbmhlcml0JztcblxuY2xhc3MgQm91bmRpbmdCb3gge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB2YXIgeDEgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IE51bWJlci5OYU47XG4gICAgdmFyIHkxID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBOdW1iZXIuTmFOO1xuICAgIHZhciB4MiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogTnVtYmVyLk5hTjtcbiAgICB2YXIgeTIgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IE51bWJlci5OYU47XG4gICAgdGhpcy54MSA9IHgxO1xuICAgIHRoaXMueTEgPSB5MTtcbiAgICB0aGlzLngyID0geDI7XG4gICAgdGhpcy55MiA9IHkyO1xuICAgIHRoaXMuYWRkUG9pbnQoeDEsIHkxKTtcbiAgICB0aGlzLmFkZFBvaW50KHgyLCB5Mik7XG4gIH1cblxuICBnZXQgeCgpIHtcbiAgICByZXR1cm4gdGhpcy54MTtcbiAgfVxuXG4gIGdldCB5KCkge1xuICAgIHJldHVybiB0aGlzLnkxO1xuICB9XG5cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLngyIC0gdGhpcy54MTtcbiAgfVxuXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMueTIgLSB0aGlzLnkxO1xuICB9XG5cbiAgYWRkUG9pbnQoeCwgeSkge1xuICAgIGlmICh0eXBlb2YgeCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmIChpc05hTih0aGlzLngxKSB8fCBpc05hTih0aGlzLngyKSkge1xuICAgICAgICB0aGlzLngxID0geDtcbiAgICAgICAgdGhpcy54MiA9IHg7XG4gICAgICB9XG5cbiAgICAgIGlmICh4IDwgdGhpcy54MSkge1xuICAgICAgICB0aGlzLngxID0geDtcbiAgICAgIH1cblxuICAgICAgaWYgKHggPiB0aGlzLngyKSB7XG4gICAgICAgIHRoaXMueDIgPSB4O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgeSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmIChpc05hTih0aGlzLnkxKSB8fCBpc05hTih0aGlzLnkyKSkge1xuICAgICAgICB0aGlzLnkxID0geTtcbiAgICAgICAgdGhpcy55MiA9IHk7XG4gICAgICB9XG5cbiAgICAgIGlmICh5IDwgdGhpcy55MSkge1xuICAgICAgICB0aGlzLnkxID0geTtcbiAgICAgIH1cblxuICAgICAgaWYgKHkgPiB0aGlzLnkyKSB7XG4gICAgICAgIHRoaXMueTIgPSB5O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFkZFgoeCkge1xuICAgIHRoaXMuYWRkUG9pbnQoeCwgbnVsbCk7XG4gIH1cblxuICBhZGRZKHkpIHtcbiAgICB0aGlzLmFkZFBvaW50KG51bGwsIHkpO1xuICB9XG5cbiAgYWRkQm91bmRpbmdCb3goYm91bmRpbmdCb3gpIHtcbiAgICBpZiAoIWJvdW5kaW5nQm94KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIHgxLFxuICAgICAgeTEsXG4gICAgICB4MixcbiAgICAgIHkyXG4gICAgfSA9IGJvdW5kaW5nQm94O1xuICAgIHRoaXMuYWRkUG9pbnQoeDEsIHkxKTtcbiAgICB0aGlzLmFkZFBvaW50KHgyLCB5Mik7XG4gIH1cblxuICBzdW1DdWJpYyh0LCBwMCwgcDEsIHAyLCBwMykge1xuICAgIHJldHVybiBNYXRoLnBvdygxIC0gdCwgMykgKiBwMCArIDMgKiBNYXRoLnBvdygxIC0gdCwgMikgKiB0ICogcDEgKyAzICogKDEgLSB0KSAqIE1hdGgucG93KHQsIDIpICogcDIgKyBNYXRoLnBvdyh0LCAzKSAqIHAzO1xuICB9XG5cbiAgYmV6aWVyQ3VydmVBZGQoZm9yWCwgcDAsIHAxLCBwMiwgcDMpIHtcbiAgICB2YXIgYiA9IDYgKiBwMCAtIDEyICogcDEgKyA2ICogcDI7XG4gICAgdmFyIGEgPSAtMyAqIHAwICsgOSAqIHAxIC0gOSAqIHAyICsgMyAqIHAzO1xuICAgIHZhciBjID0gMyAqIHAxIC0gMyAqIHAwO1xuXG4gICAgaWYgKGEgPT09IDApIHtcbiAgICAgIGlmIChiID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHQgPSAtYyAvIGI7XG5cbiAgICAgIGlmICgwIDwgdCAmJiB0IDwgMSkge1xuICAgICAgICBpZiAoZm9yWCkge1xuICAgICAgICAgIHRoaXMuYWRkWCh0aGlzLnN1bUN1YmljKHQsIHAwLCBwMSwgcDIsIHAzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hZGRZKHRoaXMuc3VtQ3ViaWModCwgcDAsIHAxLCBwMiwgcDMpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGIyYWMgPSBNYXRoLnBvdyhiLCAyKSAtIDQgKiBjICogYTtcblxuICAgIGlmIChiMmFjIDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0MSA9ICgtYiArIE1hdGguc3FydChiMmFjKSkgLyAoMiAqIGEpO1xuXG4gICAgaWYgKDAgPCB0MSAmJiB0MSA8IDEpIHtcbiAgICAgIGlmIChmb3JYKSB7XG4gICAgICAgIHRoaXMuYWRkWCh0aGlzLnN1bUN1YmljKHQxLCBwMCwgcDEsIHAyLCBwMykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hZGRZKHRoaXMuc3VtQ3ViaWModDEsIHAwLCBwMSwgcDIsIHAzKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHQyID0gKC1iIC0gTWF0aC5zcXJ0KGIyYWMpKSAvICgyICogYSk7XG5cbiAgICBpZiAoMCA8IHQyICYmIHQyIDwgMSkge1xuICAgICAgaWYgKGZvclgpIHtcbiAgICAgICAgdGhpcy5hZGRYKHRoaXMuc3VtQ3ViaWModDIsIHAwLCBwMSwgcDIsIHAzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkZFkodGhpcy5zdW1DdWJpYyh0MiwgcDAsIHAxLCBwMiwgcDMpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gZnJvbSBodHRwOi8vYmxvZy5oYWNrZXJzLWNhZmUubmV0LzIwMDkvMDYvaG93LXRvLWNhbGN1bGF0ZS1iZXppZXItY3VydmVzLWJvdW5kaW5nLmh0bWxcblxuXG4gIGFkZEJlemllckN1cnZlKHAweCwgcDB5LCBwMXgsIHAxeSwgcDJ4LCBwMnksIHAzeCwgcDN5KSB7XG4gICAgdGhpcy5hZGRQb2ludChwMHgsIHAweSk7XG4gICAgdGhpcy5hZGRQb2ludChwM3gsIHAzeSk7XG4gICAgdGhpcy5iZXppZXJDdXJ2ZUFkZCh0cnVlLCBwMHgsIHAxeCwgcDJ4LCBwM3gpO1xuICAgIHRoaXMuYmV6aWVyQ3VydmVBZGQoZmFsc2UsIHAweSwgcDF5LCBwMnksIHAzeSk7XG4gIH1cblxuICBhZGRRdWFkcmF0aWNDdXJ2ZShwMHgsIHAweSwgcDF4LCBwMXksIHAyeCwgcDJ5KSB7XG4gICAgdmFyIGNwMXggPSBwMHggKyAyIC8gMyAqIChwMXggLSBwMHgpOyAvLyBDUDEgPSBRUDAgKyAyLzMgKihRUDEtUVAwKVxuXG4gICAgdmFyIGNwMXkgPSBwMHkgKyAyIC8gMyAqIChwMXkgLSBwMHkpOyAvLyBDUDEgPSBRUDAgKyAyLzMgKihRUDEtUVAwKVxuXG4gICAgdmFyIGNwMnggPSBjcDF4ICsgMSAvIDMgKiAocDJ4IC0gcDB4KTsgLy8gQ1AyID0gQ1AxICsgMS8zICooUVAyLVFQMClcblxuICAgIHZhciBjcDJ5ID0gY3AxeSArIDEgLyAzICogKHAyeSAtIHAweSk7IC8vIENQMiA9IENQMSArIDEvMyAqKFFQMi1RUDApXG5cbiAgICB0aGlzLmFkZEJlemllckN1cnZlKHAweCwgcDB5LCBjcDF4LCBjcDJ4LCBjcDF5LCBjcDJ5LCBwMngsIHAyeSk7XG4gIH1cblxuICBpc1BvaW50SW5Cb3goeCwgeSkge1xuICAgIHZhciB7XG4gICAgICB4MSxcbiAgICAgIHkxLFxuICAgICAgeDIsXG4gICAgICB5MlxuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiB4MSA8PSB4ICYmIHggPD0geDIgJiYgeTEgPD0geSAmJiB5IDw9IHkyO1xuICB9XG5cbn1cblxuY2xhc3MgUGF0aFBhcnNlciBleHRlbmRzIFNWR1BhdGhEYXRhIHtcbiAgY29uc3RydWN0b3IocGF0aCkge1xuICAgIHN1cGVyKHBhdGggLy8gRml4IHNwYWNlcyBhZnRlciBzaWducy5cbiAgICAucmVwbGFjZSgvKFsrXFwtLl0pXFxzKy9nbSwgJyQxJykgLy8gUmVtb3ZlIGludmFsaWQgcGFydC5cbiAgICAucmVwbGFjZSgvW15NbVp6TGxIaFZ2Q2NTc1FxVHRBYWVcXGRcXHMuLCstXS4qL2csICcnKSk7XG4gICAgdGhpcy5jb250cm9sID0gbnVsbDtcbiAgICB0aGlzLnN0YXJ0ID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuY29tbWFuZCA9IG51bGw7XG4gICAgdGhpcy5jb21tYW5kcyA9IHRoaXMuY29tbWFuZHM7XG4gICAgdGhpcy5pID0gLTE7XG4gICAgdGhpcy5wcmV2aW91c0NvbW1hbmQgPSBudWxsO1xuICAgIHRoaXMucG9pbnRzID0gW107XG4gICAgdGhpcy5hbmdsZXMgPSBbXTtcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuaSA9IC0xO1xuICAgIHRoaXMuY29tbWFuZCA9IG51bGw7XG4gICAgdGhpcy5wcmV2aW91c0NvbW1hbmQgPSBudWxsO1xuICAgIHRoaXMuc3RhcnQgPSBuZXcgUG9pbnQoMCwgMCk7XG4gICAgdGhpcy5jb250cm9sID0gbmV3IFBvaW50KDAsIDApO1xuICAgIHRoaXMuY3VycmVudCA9IG5ldyBQb2ludCgwLCAwKTtcbiAgICB0aGlzLnBvaW50cyA9IFtdO1xuICAgIHRoaXMuYW5nbGVzID0gW107XG4gIH1cblxuICBpc0VuZCgpIHtcbiAgICB2YXIge1xuICAgICAgaSxcbiAgICAgIGNvbW1hbmRzXG4gICAgfSA9IHRoaXM7XG4gICAgcmV0dXJuIGkgPj0gY29tbWFuZHMubGVuZ3RoIC0gMTtcbiAgfVxuXG4gIG5leHQoKSB7XG4gICAgdmFyIGNvbW1hbmQgPSB0aGlzLmNvbW1hbmRzWysrdGhpcy5pXTtcbiAgICB0aGlzLnByZXZpb3VzQ29tbWFuZCA9IHRoaXMuY29tbWFuZDtcbiAgICB0aGlzLmNvbW1hbmQgPSBjb21tYW5kO1xuICAgIHJldHVybiBjb21tYW5kO1xuICB9XG5cbiAgZ2V0UG9pbnQoKSB7XG4gICAgdmFyIHhQcm9wID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAneCc7XG4gICAgdmFyIHlQcm9wID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAneSc7XG4gICAgdmFyIHBvaW50ID0gbmV3IFBvaW50KHRoaXMuY29tbWFuZFt4UHJvcF0sIHRoaXMuY29tbWFuZFt5UHJvcF0pO1xuICAgIHJldHVybiB0aGlzLm1ha2VBYnNvbHV0ZShwb2ludCk7XG4gIH1cblxuICBnZXRBc0NvbnRyb2xQb2ludCh4UHJvcCwgeVByb3ApIHtcbiAgICB2YXIgcG9pbnQgPSB0aGlzLmdldFBvaW50KHhQcm9wLCB5UHJvcCk7XG4gICAgdGhpcy5jb250cm9sID0gcG9pbnQ7XG4gICAgcmV0dXJuIHBvaW50O1xuICB9XG5cbiAgZ2V0QXNDdXJyZW50UG9pbnQoeFByb3AsIHlQcm9wKSB7XG4gICAgdmFyIHBvaW50ID0gdGhpcy5nZXRQb2ludCh4UHJvcCwgeVByb3ApO1xuICAgIHRoaXMuY3VycmVudCA9IHBvaW50O1xuICAgIHJldHVybiBwb2ludDtcbiAgfVxuXG4gIGdldFJlZmxlY3RlZENvbnRyb2xQb2ludCgpIHtcbiAgICB2YXIgcHJldmlvdXNDb21tYW5kID0gdGhpcy5wcmV2aW91c0NvbW1hbmQudHlwZTtcblxuICAgIGlmIChwcmV2aW91c0NvbW1hbmQgIT09IFNWR1BhdGhEYXRhLkNVUlZFX1RPICYmIHByZXZpb3VzQ29tbWFuZCAhPT0gU1ZHUGF0aERhdGEuU01PT1RIX0NVUlZFX1RPICYmIHByZXZpb3VzQ29tbWFuZCAhPT0gU1ZHUGF0aERhdGEuUVVBRF9UTyAmJiBwcmV2aW91c0NvbW1hbmQgIT09IFNWR1BhdGhEYXRhLlNNT09USF9RVUFEX1RPKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50O1xuICAgIH0gLy8gcmVmbGVjdCBwb2ludFxuXG5cbiAgICB2YXIge1xuICAgICAgY3VycmVudDoge1xuICAgICAgICB4OiBjeCxcbiAgICAgICAgeTogY3lcbiAgICAgIH0sXG4gICAgICBjb250cm9sOiB7XG4gICAgICAgIHg6IG94LFxuICAgICAgICB5OiBveVxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIHZhciBwb2ludCA9IG5ldyBQb2ludCgyICogY3ggLSBveCwgMiAqIGN5IC0gb3kpO1xuICAgIHJldHVybiBwb2ludDtcbiAgfVxuXG4gIG1ha2VBYnNvbHV0ZShwb2ludCkge1xuICAgIGlmICh0aGlzLmNvbW1hbmQucmVsYXRpdmUpIHtcbiAgICAgIHZhciB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSB0aGlzLmN1cnJlbnQ7XG4gICAgICBwb2ludC54ICs9IHg7XG4gICAgICBwb2ludC55ICs9IHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvaW50O1xuICB9XG5cbiAgYWRkTWFya2VyKHBvaW50LCBmcm9tLCBwcmlvclRvKSB7XG4gICAgdmFyIHtcbiAgICAgIHBvaW50cyxcbiAgICAgIGFuZ2xlc1xuICAgIH0gPSB0aGlzOyAvLyBpZiB0aGUgbGFzdCBhbmdsZSBpc24ndCBmaWxsZWQgaW4gYmVjYXVzZSB3ZSBkaWRuJ3QgaGF2ZSB0aGlzIHBvaW50IHlldCAuLi5cblxuICAgIGlmIChwcmlvclRvICYmIGFuZ2xlcy5sZW5ndGggPiAwICYmICFhbmdsZXNbYW5nbGVzLmxlbmd0aCAtIDFdKSB7XG4gICAgICBhbmdsZXNbYW5nbGVzLmxlbmd0aCAtIDFdID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXS5hbmdsZVRvKHByaW9yVG8pO1xuICAgIH1cblxuICAgIHRoaXMuYWRkTWFya2VyQW5nbGUocG9pbnQsIGZyb20gPyBmcm9tLmFuZ2xlVG8ocG9pbnQpIDogbnVsbCk7XG4gIH1cblxuICBhZGRNYXJrZXJBbmdsZShwb2ludCwgYW5nbGUpIHtcbiAgICB0aGlzLnBvaW50cy5wdXNoKHBvaW50KTtcbiAgICB0aGlzLmFuZ2xlcy5wdXNoKGFuZ2xlKTtcbiAgfVxuXG4gIGdldE1hcmtlclBvaW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5wb2ludHM7XG4gIH1cblxuICBnZXRNYXJrZXJBbmdsZXMoKSB7XG4gICAgdmFyIHtcbiAgICAgIGFuZ2xlc1xuICAgIH0gPSB0aGlzO1xuICAgIHZhciBsZW4gPSBhbmdsZXMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKCFhbmdsZXNbaV0pIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICBpZiAoYW5nbGVzW2pdKSB7XG4gICAgICAgICAgICBhbmdsZXNbaV0gPSBhbmdsZXNbal07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYW5nbGVzO1xuICB9XG5cbn1cblxuY2xhc3MgUmVuZGVyZWRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5tb2RpZmllZEVtU2l6ZVN0YWNrID0gZmFsc2U7XG4gIH1cblxuICBjYWxjdWxhdGVPcGFjaXR5KCkge1xuICAgIHZhciBvcGFjaXR5ID0gMS4wOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXMsIGNvbnNpc3RlbnQtdGhpc1xuXG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzO1xuXG4gICAgd2hpbGUgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvcGFjaXR5U3R5bGUgPSBlbGVtZW50LmdldFN0eWxlKCdvcGFjaXR5JywgZmFsc2UsIHRydWUpOyAvLyBubyBhbmNlc3RvcnMgb24gc3R5bGUgY2FsbFxuXG4gICAgICBpZiAob3BhY2l0eVN0eWxlLmhhc1ZhbHVlKHRydWUpKSB7XG4gICAgICAgIG9wYWNpdHkgKj0gb3BhY2l0eVN0eWxlLmdldE51bWJlcigpO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wYWNpdHk7XG4gIH1cblxuICBzZXRDb250ZXh0KGN0eCkge1xuICAgIHZhciBmcm9tTWVhc3VyZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICBpZiAoIWZyb21NZWFzdXJlKSB7XG4gICAgICAvLyBjYXVzZXMgc3RhY2sgb3ZlcmZsb3cgd2hlbiBtZWFzdXJpbmcgdGV4dCB3aXRoIGdyYWRpZW50c1xuICAgICAgLy8gZmlsbFxuICAgICAgdmFyIGZpbGxTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdmaWxsJyk7XG4gICAgICB2YXIgZmlsbE9wYWNpdHlTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdmaWxsLW9wYWNpdHknKTtcbiAgICAgIHZhciBzdHJva2VTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdzdHJva2UnKTtcbiAgICAgIHZhciBzdHJva2VPcGFjaXR5UHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3N0cm9rZS1vcGFjaXR5Jyk7XG5cbiAgICAgIGlmIChmaWxsU3R5bGVQcm9wLmlzVXJsRGVmaW5pdGlvbigpKSB7XG4gICAgICAgIHZhciBmaWxsU3R5bGUgPSBmaWxsU3R5bGVQcm9wLmdldEZpbGxTdHlsZURlZmluaXRpb24odGhpcywgZmlsbE9wYWNpdHlTdHlsZVByb3ApO1xuXG4gICAgICAgIGlmIChmaWxsU3R5bGUpIHtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGZpbGxTdHlsZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICBpZiAoZmlsbFN0eWxlUHJvcC5nZXRTdHJpbmcoKSA9PT0gJ2N1cnJlbnRDb2xvcicpIHtcbiAgICAgICAgICBmaWxsU3R5bGVQcm9wLnNldFZhbHVlKHRoaXMuZ2V0U3R5bGUoJ2NvbG9yJykuZ2V0Q29sb3IoKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX2ZpbGxTdHlsZSA9IGZpbGxTdHlsZVByb3AuZ2V0Q29sb3IoKTtcblxuICAgICAgICBpZiAoX2ZpbGxTdHlsZSAhPT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IF9maWxsU3R5bGUgPT09ICdub25lJyA/ICdyZ2JhKDAsMCwwLDApJyA6IF9maWxsU3R5bGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbGxPcGFjaXR5U3R5bGVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgdmFyIF9maWxsU3R5bGUyID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdmaWxsJywgY3R4LmZpbGxTdHlsZSkuYWRkT3BhY2l0eShmaWxsT3BhY2l0eVN0eWxlUHJvcCkuZ2V0Q29sb3IoKTtcblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gX2ZpbGxTdHlsZTI7XG4gICAgICB9IC8vIHN0cm9rZVxuXG5cbiAgICAgIGlmIChzdHJva2VTdHlsZVByb3AuaXNVcmxEZWZpbml0aW9uKCkpIHtcbiAgICAgICAgdmFyIHN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGVQcm9wLmdldEZpbGxTdHlsZURlZmluaXRpb24odGhpcywgc3Ryb2tlT3BhY2l0eVByb3ApO1xuXG4gICAgICAgIGlmIChzdHJva2VTdHlsZSkge1xuICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHN0cm9rZVN0eWxlUHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGlmIChzdHJva2VTdHlsZVByb3AuZ2V0U3RyaW5nKCkgPT09ICdjdXJyZW50Q29sb3InKSB7XG4gICAgICAgICAgc3Ryb2tlU3R5bGVQcm9wLnNldFZhbHVlKHRoaXMuZ2V0U3R5bGUoJ2NvbG9yJykuZ2V0Q29sb3IoKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3N0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGVQcm9wLmdldFN0cmluZygpO1xuXG4gICAgICAgIGlmIChfc3Ryb2tlU3R5bGUgIT09ICdpbmhlcml0Jykge1xuICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IF9zdHJva2VTdHlsZSA9PT0gJ25vbmUnID8gJ3JnYmEoMCwwLDAsMCknIDogX3N0cm9rZVN0eWxlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHJva2VPcGFjaXR5UHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHZhciBfc3Ryb2tlU3R5bGUyID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdzdHJva2UnLCBjdHguc3Ryb2tlU3R5bGUpLmFkZE9wYWNpdHkoc3Ryb2tlT3BhY2l0eVByb3ApLmdldFN0cmluZygpO1xuXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IF9zdHJva2VTdHlsZTI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdHJva2VXaWR0aFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3N0cm9rZS13aWR0aCcpO1xuXG4gICAgICBpZiAoc3Ryb2tlV2lkdGhTdHlsZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICB2YXIgbmV3TGluZVdpZHRoID0gc3Ryb2tlV2lkdGhTdHlsZVByb3AuZ2V0UGl4ZWxzKCk7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSAhbmV3TGluZVdpZHRoID8gUFNFVURPX1pFUk8gLy8gYnJvd3NlcnMgZG9uJ3QgcmVzcGVjdCAwIChvciBub2RlLWNhbnZhcz8gOi0pXG4gICAgICAgIDogbmV3TGluZVdpZHRoO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3Ryb2tlTGluZWNhcFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3N0cm9rZS1saW5lY2FwJyk7XG4gICAgICB2YXIgc3Ryb2tlTGluZWpvaW5TdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdzdHJva2UtbGluZWpvaW4nKTtcbiAgICAgIHZhciBzdHJva2VNaXRlcmxpbWl0UHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3N0cm9rZS1taXRlcmxpbWl0Jyk7IC8vIE5FRUQgVEVTVFxuICAgICAgLy8gY29uc3QgcG9pbnRPcmRlclN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3BhaW50LW9yZGVyJyk7XG5cbiAgICAgIHZhciBzdHJva2VEYXNoYXJyYXlTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdzdHJva2UtZGFzaGFycmF5Jyk7XG4gICAgICB2YXIgc3Ryb2tlRGFzaG9mZnNldFByb3AgPSB0aGlzLmdldFN0eWxlKCdzdHJva2UtZGFzaG9mZnNldCcpO1xuXG4gICAgICBpZiAoc3Ryb2tlTGluZWNhcFN0eWxlUHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGN0eC5saW5lQ2FwID0gc3Ryb2tlTGluZWNhcFN0eWxlUHJvcC5nZXRTdHJpbmcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0cm9rZUxpbmVqb2luU3R5bGVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgY3R4LmxpbmVKb2luID0gc3Ryb2tlTGluZWpvaW5TdHlsZVByb3AuZ2V0U3RyaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHJva2VNaXRlcmxpbWl0UHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGN0eC5taXRlckxpbWl0ID0gc3Ryb2tlTWl0ZXJsaW1pdFByb3AuZ2V0TnVtYmVyKCk7XG4gICAgICB9IC8vIE5FRUQgVEVTVFxuICAgICAgLy8gaWYgKHBvaW50T3JkZXJTdHlsZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgLy8gXHQvLyA/XG4gICAgICAvLyBcdGN0eC5wYWludE9yZGVyID0gcG9pbnRPcmRlclN0eWxlUHJvcC5nZXRWYWx1ZSgpO1xuICAgICAgLy8gfVxuXG5cbiAgICAgIGlmIChzdHJva2VEYXNoYXJyYXlTdHlsZVByb3AuaGFzVmFsdWUoKSAmJiBzdHJva2VEYXNoYXJyYXlTdHlsZVByb3AuZ2V0U3RyaW5nKCkgIT09ICdub25lJykge1xuICAgICAgICB2YXIgZ2FwcyA9IHRvTnVtYmVycyhzdHJva2VEYXNoYXJyYXlTdHlsZVByb3AuZ2V0U3RyaW5nKCkpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY3R4LnNldExpbmVEYXNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChnYXBzKTtcbiAgICAgICAgfSBlbHNlIC8vIEB0cy1leHBlY3QtZXJyb3IgSGFuZGxlIGJyb3dzZXIgcHJlZml4LlxuICAgICAgICAgIGlmICh0eXBlb2YgY3R4LndlYmtpdExpbmVEYXNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBIYW5kbGUgYnJvd3NlciBwcmVmaXguXG4gICAgICAgICAgICBjdHgud2Via2l0TGluZURhc2ggPSBnYXBzO1xuICAgICAgICAgIH0gZWxzZSAvLyBAdHMtZXhwZWN0LWVycm9yIEhhbmRsZSBicm93c2VyIHByZWZpeC5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3R4Lm1vekRhc2ggIT09ICd1bmRlZmluZWQnICYmICEoZ2Fwcy5sZW5ndGggPT09IDEgJiYgZ2Fwc1swXSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBIYW5kbGUgYnJvd3NlciBwcmVmaXguXG4gICAgICAgICAgICAgIGN0eC5tb3pEYXNoID0gZ2FwcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICB2YXIgb2Zmc2V0ID0gc3Ryb2tlRGFzaG9mZnNldFByb3AuZ2V0UGl4ZWxzKCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjdHgubGluZURhc2hPZmZzZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB9IGVsc2UgLy8gQHRzLWV4cGVjdC1lcnJvciBIYW5kbGUgYnJvd3NlciBwcmVmaXguXG4gICAgICAgICAgaWYgKHR5cGVvZiBjdHgud2Via2l0TGluZURhc2hPZmZzZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEhhbmRsZSBicm93c2VyIHByZWZpeC5cbiAgICAgICAgICAgIGN0eC53ZWJraXRMaW5lRGFzaE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICB9IGVsc2UgLy8gQHRzLWV4cGVjdC1lcnJvciBIYW5kbGUgYnJvd3NlciBwcmVmaXguXG4gICAgICAgICAgICBpZiAodHlwZW9mIGN0eC5tb3pEYXNoT2Zmc2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEhhbmRsZSBicm93c2VyIHByZWZpeC5cbiAgICAgICAgICAgICAgY3R4Lm1vekRhc2hPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBmb250XG5cblxuICAgIHRoaXMubW9kaWZpZWRFbVNpemVTdGFjayA9IGZhbHNlO1xuXG4gICAgaWYgKHR5cGVvZiBjdHguZm9udCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBmb250U3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZm9udCcpO1xuICAgICAgdmFyIGZvbnRTdHlsZVN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ2ZvbnQtc3R5bGUnKTtcbiAgICAgIHZhciBmb250VmFyaWFudFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ2ZvbnQtdmFyaWFudCcpO1xuICAgICAgdmFyIGZvbnRXZWlnaHRTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdmb250LXdlaWdodCcpO1xuICAgICAgdmFyIGZvbnRTaXplU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZm9udC1zaXplJyk7XG4gICAgICB2YXIgZm9udEZhbWlseVN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ2ZvbnQtZmFtaWx5Jyk7XG4gICAgICB2YXIgZm9udCA9IG5ldyBGb250KGZvbnRTdHlsZVN0eWxlUHJvcC5nZXRTdHJpbmcoKSwgZm9udFZhcmlhbnRTdHlsZVByb3AuZ2V0U3RyaW5nKCksIGZvbnRXZWlnaHRTdHlsZVByb3AuZ2V0U3RyaW5nKCksIGZvbnRTaXplU3R5bGVQcm9wLmhhc1ZhbHVlKCkgPyBcIlwiLmNvbmNhdChmb250U2l6ZVN0eWxlUHJvcC5nZXRQaXhlbHModHJ1ZSksIFwicHhcIikgOiAnJywgZm9udEZhbWlseVN0eWxlUHJvcC5nZXRTdHJpbmcoKSwgRm9udC5wYXJzZShmb250U3R5bGVQcm9wLmdldFN0cmluZygpLCBjdHguZm9udCkpO1xuICAgICAgZm9udFN0eWxlU3R5bGVQcm9wLnNldFZhbHVlKGZvbnQuZm9udFN0eWxlKTtcbiAgICAgIGZvbnRWYXJpYW50U3R5bGVQcm9wLnNldFZhbHVlKGZvbnQuZm9udFZhcmlhbnQpO1xuICAgICAgZm9udFdlaWdodFN0eWxlUHJvcC5zZXRWYWx1ZShmb250LmZvbnRXZWlnaHQpO1xuICAgICAgZm9udFNpemVTdHlsZVByb3Auc2V0VmFsdWUoZm9udC5mb250U2l6ZSk7XG4gICAgICBmb250RmFtaWx5U3R5bGVQcm9wLnNldFZhbHVlKGZvbnQuZm9udEZhbWlseSk7XG4gICAgICBjdHguZm9udCA9IGZvbnQudG9TdHJpbmcoKTtcblxuICAgICAgaWYgKGZvbnRTaXplU3R5bGVQcm9wLmlzUGl4ZWxzKCkpIHtcbiAgICAgICAgdGhpcy5kb2N1bWVudC5lbVNpemUgPSBmb250U2l6ZVN0eWxlUHJvcC5nZXRQaXhlbHMoKTtcbiAgICAgICAgdGhpcy5tb2RpZmllZEVtU2l6ZVN0YWNrID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWZyb21NZWFzdXJlKSB7XG4gICAgICAvLyBlZmZlY3RzXG4gICAgICB0aGlzLmFwcGx5RWZmZWN0cyhjdHgpOyAvLyBvcGFjaXR5XG5cbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuY2FsY3VsYXRlT3BhY2l0eSgpO1xuICAgIH1cbiAgfVxuXG4gIGNsZWFyQ29udGV4dChjdHgpIHtcbiAgICBzdXBlci5jbGVhckNvbnRleHQoY3R4KTtcblxuICAgIGlmICh0aGlzLm1vZGlmaWVkRW1TaXplU3RhY2spIHtcbiAgICAgIHRoaXMuZG9jdW1lbnQucG9wRW1TaXplKCk7XG4gICAgfVxuICB9XG5cbn1cblxuY2xhc3MgUGF0aEVsZW1lbnQgZXh0ZW5kcyBSZW5kZXJlZEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLnR5cGUgPSAncGF0aCc7XG4gICAgdGhpcy5wYXRoUGFyc2VyID0gbnVsbDtcbiAgICB0aGlzLnBhdGhQYXJzZXIgPSBuZXcgUGF0aFBhcnNlcih0aGlzLmdldEF0dHJpYnV0ZSgnZCcpLmdldFN0cmluZygpKTtcbiAgfVxuXG4gIHBhdGgoY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIHBhdGhQYXJzZXJcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgYm91bmRpbmdCb3ggPSBuZXcgQm91bmRpbmdCb3goKTtcbiAgICBwYXRoUGFyc2VyLnJlc2V0KCk7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKCFwYXRoUGFyc2VyLmlzRW5kKCkpIHtcbiAgICAgIHN3aXRjaCAocGF0aFBhcnNlci5uZXh0KCkudHlwZSkge1xuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuTU9WRV9UTzpcbiAgICAgICAgICB0aGlzLnBhdGhNKGN0eCwgYm91bmRpbmdCb3gpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5MSU5FX1RPOlxuICAgICAgICAgIHRoaXMucGF0aEwoY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkhPUklaX0xJTkVfVE86XG4gICAgICAgICAgdGhpcy5wYXRoSChjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuVkVSVF9MSU5FX1RPOlxuICAgICAgICAgIHRoaXMucGF0aFYoY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkNVUlZFX1RPOlxuICAgICAgICAgIHRoaXMucGF0aEMoY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlNNT09USF9DVVJWRV9UTzpcbiAgICAgICAgICB0aGlzLnBhdGhTKGN0eCwgYm91bmRpbmdCb3gpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5RVUFEX1RPOlxuICAgICAgICAgIHRoaXMucGF0aFEoY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlNNT09USF9RVUFEX1RPOlxuICAgICAgICAgIHRoaXMucGF0aFQoY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkFSQzpcbiAgICAgICAgICB0aGlzLnBhdGhBKGN0eCwgYm91bmRpbmdCb3gpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5DTE9TRV9QQVRIOlxuICAgICAgICAgIHRoaXMucGF0aFooY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvdW5kaW5nQm94O1xuICB9XG5cbiAgZ2V0Qm91bmRpbmdCb3goXykge1xuICAgIHJldHVybiB0aGlzLnBhdGgoKTtcbiAgfVxuXG4gIGdldE1hcmtlcnMoKSB7XG4gICAgdmFyIHtcbiAgICAgIHBhdGhQYXJzZXJcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgcG9pbnRzID0gcGF0aFBhcnNlci5nZXRNYXJrZXJQb2ludHMoKTtcbiAgICB2YXIgYW5nbGVzID0gcGF0aFBhcnNlci5nZXRNYXJrZXJBbmdsZXMoKTtcbiAgICB2YXIgbWFya2VycyA9IHBvaW50cy5tYXAoKHBvaW50LCBpKSA9PiBbcG9pbnQsIGFuZ2xlc1tpXV0pO1xuICAgIHJldHVybiBtYXJrZXJzO1xuICB9XG5cbiAgcmVuZGVyQ2hpbGRyZW4oY3R4KSB7XG4gICAgdGhpcy5wYXRoKGN0eCk7XG4gICAgdGhpcy5kb2N1bWVudC5zY3JlZW4ubW91c2UuY2hlY2tQYXRoKHRoaXMsIGN0eCk7XG4gICAgdmFyIGZpbGxSdWxlU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZmlsbC1ydWxlJyk7XG5cbiAgICBpZiAoY3R4LmZpbGxTdHlsZSAhPT0gJycpIHtcbiAgICAgIGlmIChmaWxsUnVsZVN0eWxlUHJvcC5nZXRTdHJpbmcoJ2luaGVyaXQnKSAhPT0gJ2luaGVyaXQnKSB7XG4gICAgICAgIGN0eC5maWxsKGZpbGxSdWxlU3R5bGVQcm9wLmdldFN0cmluZygpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGN0eC5zdHJva2VTdHlsZSAhPT0gJycpIHtcbiAgICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgndmVjdG9yLWVmZmVjdCcpLmdldFN0cmluZygpID09PSAnbm9uLXNjYWxpbmctc3Ryb2tlJykge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1hcmtlcnMgPSB0aGlzLmdldE1hcmtlcnMoKTtcblxuICAgIGlmIChtYXJrZXJzKSB7XG4gICAgICB2YXIgbWFya2Vyc0xhc3RJbmRleCA9IG1hcmtlcnMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBtYXJrZXJTdGFydFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ21hcmtlci1zdGFydCcpO1xuICAgICAgdmFyIG1hcmtlck1pZFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ21hcmtlci1taWQnKTtcbiAgICAgIHZhciBtYXJrZXJFbmRTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdtYXJrZXItZW5kJyk7XG5cbiAgICAgIGlmIChtYXJrZXJTdGFydFN0eWxlUHJvcC5pc1VybERlZmluaXRpb24oKSkge1xuICAgICAgICB2YXIgbWFya2VyID0gbWFya2VyU3RhcnRTdHlsZVByb3AuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICB2YXIgW3BvaW50LCBhbmdsZV0gPSBtYXJrZXJzWzBdO1xuICAgICAgICBtYXJrZXIucmVuZGVyKGN0eCwgcG9pbnQsIGFuZ2xlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hcmtlck1pZFN0eWxlUHJvcC5pc1VybERlZmluaXRpb24oKSkge1xuICAgICAgICB2YXIgX21hcmtlciA9IG1hcmtlck1pZFN0eWxlUHJvcC5nZXREZWZpbml0aW9uKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBtYXJrZXJzTGFzdEluZGV4OyBpKyspIHtcbiAgICAgICAgICB2YXIgW19wb2ludCwgX2FuZ2xlXSA9IG1hcmtlcnNbaV07XG5cbiAgICAgICAgICBfbWFya2VyLnJlbmRlcihjdHgsIF9wb2ludCwgX2FuZ2xlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWFya2VyRW5kU3R5bGVQcm9wLmlzVXJsRGVmaW5pdGlvbigpKSB7XG4gICAgICAgIHZhciBfbWFya2VyMiA9IG1hcmtlckVuZFN0eWxlUHJvcC5nZXREZWZpbml0aW9uKCk7XG5cbiAgICAgICAgdmFyIFtfcG9pbnQyLCBfYW5nbGUyXSA9IG1hcmtlcnNbbWFya2Vyc0xhc3RJbmRleF07XG5cbiAgICAgICAgX21hcmtlcjIucmVuZGVyKGN0eCwgX3BvaW50MiwgX2FuZ2xlMik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHBhdGhNKHBhdGhQYXJzZXIpIHtcbiAgICB2YXIgcG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ3VycmVudFBvaW50KCk7XG4gICAgcGF0aFBhcnNlci5zdGFydCA9IHBhdGhQYXJzZXIuY3VycmVudDtcbiAgICByZXR1cm4ge1xuICAgICAgcG9pbnRcbiAgICB9O1xuICB9XG5cbiAgcGF0aE0oY3R4LCBib3VuZGluZ0JveCkge1xuICAgIHZhciB7XG4gICAgICBwYXRoUGFyc2VyXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHtcbiAgICAgIHBvaW50XG4gICAgfSA9IFBhdGhFbGVtZW50LnBhdGhNKHBhdGhQYXJzZXIpO1xuICAgIHZhciB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSBwb2ludDtcbiAgICBwYXRoUGFyc2VyLmFkZE1hcmtlcihwb2ludCk7XG4gICAgYm91bmRpbmdCb3guYWRkUG9pbnQoeCwgeSk7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBwYXRoTChwYXRoUGFyc2VyKSB7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnRcbiAgICB9ID0gcGF0aFBhcnNlcjtcbiAgICB2YXIgcG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ3VycmVudFBvaW50KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBwb2ludFxuICAgIH07XG4gIH1cblxuICBwYXRoTChjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgdmFyIHtcbiAgICAgIHBhdGhQYXJzZXJcbiAgICB9ID0gdGhpcztcbiAgICB2YXIge1xuICAgICAgY3VycmVudCxcbiAgICAgIHBvaW50XG4gICAgfSA9IFBhdGhFbGVtZW50LnBhdGhMKHBhdGhQYXJzZXIpO1xuICAgIHZhciB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSBwb2ludDtcbiAgICBwYXRoUGFyc2VyLmFkZE1hcmtlcihwb2ludCwgY3VycmVudCk7XG4gICAgYm91bmRpbmdCb3guYWRkUG9pbnQoeCwgeSk7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBwYXRoSChwYXRoUGFyc2VyKSB7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBjb21tYW5kXG4gICAgfSA9IHBhdGhQYXJzZXI7XG4gICAgdmFyIHBvaW50ID0gbmV3IFBvaW50KChjb21tYW5kLnJlbGF0aXZlID8gY3VycmVudC54IDogMCkgKyBjb21tYW5kLngsIGN1cnJlbnQueSk7XG4gICAgcGF0aFBhcnNlci5jdXJyZW50ID0gcG9pbnQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBwb2ludFxuICAgIH07XG4gIH1cblxuICBwYXRoSChjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgdmFyIHtcbiAgICAgIHBhdGhQYXJzZXJcbiAgICB9ID0gdGhpcztcbiAgICB2YXIge1xuICAgICAgY3VycmVudCxcbiAgICAgIHBvaW50XG4gICAgfSA9IFBhdGhFbGVtZW50LnBhdGhIKHBhdGhQYXJzZXIpO1xuICAgIHZhciB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSBwb2ludDtcbiAgICBwYXRoUGFyc2VyLmFkZE1hcmtlcihwb2ludCwgY3VycmVudCk7XG4gICAgYm91bmRpbmdCb3guYWRkUG9pbnQoeCwgeSk7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBwYXRoVihwYXRoUGFyc2VyKSB7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBjb21tYW5kXG4gICAgfSA9IHBhdGhQYXJzZXI7XG4gICAgdmFyIHBvaW50ID0gbmV3IFBvaW50KGN1cnJlbnQueCwgKGNvbW1hbmQucmVsYXRpdmUgPyBjdXJyZW50LnkgOiAwKSArIGNvbW1hbmQueSk7XG4gICAgcGF0aFBhcnNlci5jdXJyZW50ID0gcG9pbnQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBwb2ludFxuICAgIH07XG4gIH1cblxuICBwYXRoVihjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgdmFyIHtcbiAgICAgIHBhdGhQYXJzZXJcbiAgICB9ID0gdGhpcztcbiAgICB2YXIge1xuICAgICAgY3VycmVudCxcbiAgICAgIHBvaW50XG4gICAgfSA9IFBhdGhFbGVtZW50LnBhdGhWKHBhdGhQYXJzZXIpO1xuICAgIHZhciB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSBwb2ludDtcbiAgICBwYXRoUGFyc2VyLmFkZE1hcmtlcihwb2ludCwgY3VycmVudCk7XG4gICAgYm91bmRpbmdCb3guYWRkUG9pbnQoeCwgeSk7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBwYXRoQyhwYXRoUGFyc2VyKSB7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnRcbiAgICB9ID0gcGF0aFBhcnNlcjtcbiAgICB2YXIgcG9pbnQgPSBwYXRoUGFyc2VyLmdldFBvaW50KCd4MScsICd5MScpO1xuICAgIHZhciBjb250cm9sUG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ29udHJvbFBvaW50KCd4MicsICd5MicpO1xuICAgIHZhciBjdXJyZW50UG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ3VycmVudFBvaW50KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBwb2ludCxcbiAgICAgIGNvbnRyb2xQb2ludCxcbiAgICAgIGN1cnJlbnRQb2ludFxuICAgIH07XG4gIH1cblxuICBwYXRoQyhjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgdmFyIHtcbiAgICAgIHBhdGhQYXJzZXJcbiAgICB9ID0gdGhpcztcbiAgICB2YXIge1xuICAgICAgY3VycmVudCxcbiAgICAgIHBvaW50LFxuICAgICAgY29udHJvbFBvaW50LFxuICAgICAgY3VycmVudFBvaW50XG4gICAgfSA9IFBhdGhFbGVtZW50LnBhdGhDKHBhdGhQYXJzZXIpO1xuICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKGN1cnJlbnRQb2ludCwgY29udHJvbFBvaW50LCBwb2ludCk7XG4gICAgYm91bmRpbmdCb3guYWRkQmV6aWVyQ3VydmUoY3VycmVudC54LCBjdXJyZW50LnksIHBvaW50LngsIHBvaW50LnksIGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHBvaW50LngsIHBvaW50LnksIGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgcGF0aFMocGF0aFBhcnNlcikge1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50XG4gICAgfSA9IHBhdGhQYXJzZXI7XG4gICAgdmFyIHBvaW50ID0gcGF0aFBhcnNlci5nZXRSZWZsZWN0ZWRDb250cm9sUG9pbnQoKTtcbiAgICB2YXIgY29udHJvbFBvaW50ID0gcGF0aFBhcnNlci5nZXRBc0NvbnRyb2xQb2ludCgneDInLCAneTInKTtcbiAgICB2YXIgY3VycmVudFBvaW50ID0gcGF0aFBhcnNlci5nZXRBc0N1cnJlbnRQb2ludCgpO1xuICAgIHJldHVybiB7XG4gICAgICBjdXJyZW50LFxuICAgICAgcG9pbnQsXG4gICAgICBjb250cm9sUG9pbnQsXG4gICAgICBjdXJyZW50UG9pbnRcbiAgICB9O1xuICB9XG5cbiAgcGF0aFMoY3R4LCBib3VuZGluZ0JveCkge1xuICAgIHZhciB7XG4gICAgICBwYXRoUGFyc2VyXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBwb2ludCxcbiAgICAgIGNvbnRyb2xQb2ludCxcbiAgICAgIGN1cnJlbnRQb2ludFxuICAgIH0gPSBQYXRoRWxlbWVudC5wYXRoUyhwYXRoUGFyc2VyKTtcbiAgICBwYXRoUGFyc2VyLmFkZE1hcmtlcihjdXJyZW50UG9pbnQsIGNvbnRyb2xQb2ludCwgcG9pbnQpO1xuICAgIGJvdW5kaW5nQm94LmFkZEJlemllckN1cnZlKGN1cnJlbnQueCwgY3VycmVudC55LCBwb2ludC54LCBwb2ludC55LCBjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICBjdHguYmV6aWVyQ3VydmVUbyhwb2ludC54LCBwb2ludC55LCBjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHBhdGhRKHBhdGhQYXJzZXIpIHtcbiAgICB2YXIge1xuICAgICAgY3VycmVudFxuICAgIH0gPSBwYXRoUGFyc2VyO1xuICAgIHZhciBjb250cm9sUG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ29udHJvbFBvaW50KCd4MScsICd5MScpO1xuICAgIHZhciBjdXJyZW50UG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ3VycmVudFBvaW50KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBjb250cm9sUG9pbnQsXG4gICAgICBjdXJyZW50UG9pbnRcbiAgICB9O1xuICB9XG5cbiAgcGF0aFEoY3R4LCBib3VuZGluZ0JveCkge1xuICAgIHZhciB7XG4gICAgICBwYXRoUGFyc2VyXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBjb250cm9sUG9pbnQsXG4gICAgICBjdXJyZW50UG9pbnRcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aFEocGF0aFBhcnNlcik7XG4gICAgcGF0aFBhcnNlci5hZGRNYXJrZXIoY3VycmVudFBvaW50LCBjb250cm9sUG9pbnQsIGNvbnRyb2xQb2ludCk7XG4gICAgYm91bmRpbmdCb3guYWRkUXVhZHJhdGljQ3VydmUoY3VycmVudC54LCBjdXJyZW50LnksIGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgcGF0aFQocGF0aFBhcnNlcikge1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50XG4gICAgfSA9IHBhdGhQYXJzZXI7XG4gICAgdmFyIGNvbnRyb2xQb2ludCA9IHBhdGhQYXJzZXIuZ2V0UmVmbGVjdGVkQ29udHJvbFBvaW50KCk7XG4gICAgcGF0aFBhcnNlci5jb250cm9sID0gY29udHJvbFBvaW50O1xuICAgIHZhciBjdXJyZW50UG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ3VycmVudFBvaW50KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBjb250cm9sUG9pbnQsXG4gICAgICBjdXJyZW50UG9pbnRcbiAgICB9O1xuICB9XG5cbiAgcGF0aFQoY3R4LCBib3VuZGluZ0JveCkge1xuICAgIHZhciB7XG4gICAgICBwYXRoUGFyc2VyXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBjb250cm9sUG9pbnQsXG4gICAgICBjdXJyZW50UG9pbnRcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aFQocGF0aFBhcnNlcik7XG4gICAgcGF0aFBhcnNlci5hZGRNYXJrZXIoY3VycmVudFBvaW50LCBjb250cm9sUG9pbnQsIGNvbnRyb2xQb2ludCk7XG4gICAgYm91bmRpbmdCb3guYWRkUXVhZHJhdGljQ3VydmUoY3VycmVudC54LCBjdXJyZW50LnksIGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgcGF0aEEocGF0aFBhcnNlcikge1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50LFxuICAgICAgY29tbWFuZFxuICAgIH0gPSBwYXRoUGFyc2VyO1xuICAgIHZhciB7XG4gICAgICByWCxcbiAgICAgIHJZLFxuICAgICAgeFJvdCxcbiAgICAgIGxBcmNGbGFnLFxuICAgICAgc3dlZXBGbGFnXG4gICAgfSA9IGNvbW1hbmQ7XG4gICAgdmFyIHhBeGlzUm90YXRpb24gPSB4Um90ICogKE1hdGguUEkgLyAxODAuMCk7XG4gICAgdmFyIGN1cnJlbnRQb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDdXJyZW50UG9pbnQoKTsgLy8gQ29udmVyc2lvbiBmcm9tIGVuZHBvaW50IHRvIGNlbnRlciBwYXJhbWV0ZXJpemF0aW9uXG4gICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvaW1wbG5vdGUuaHRtbCNBcmNJbXBsZW1lbnRhdGlvbk5vdGVzXG4gICAgLy8geDEnLCB5MSdcblxuICAgIHZhciBjdXJycCA9IG5ldyBQb2ludChNYXRoLmNvcyh4QXhpc1JvdGF0aW9uKSAqIChjdXJyZW50LnggLSBjdXJyZW50UG9pbnQueCkgLyAyLjAgKyBNYXRoLnNpbih4QXhpc1JvdGF0aW9uKSAqIChjdXJyZW50LnkgLSBjdXJyZW50UG9pbnQueSkgLyAyLjAsIC1NYXRoLnNpbih4QXhpc1JvdGF0aW9uKSAqIChjdXJyZW50LnggLSBjdXJyZW50UG9pbnQueCkgLyAyLjAgKyBNYXRoLmNvcyh4QXhpc1JvdGF0aW9uKSAqIChjdXJyZW50LnkgLSBjdXJyZW50UG9pbnQueSkgLyAyLjApOyAvLyBhZGp1c3QgcmFkaWlcblxuICAgIHZhciBsID0gTWF0aC5wb3coY3VycnAueCwgMikgLyBNYXRoLnBvdyhyWCwgMikgKyBNYXRoLnBvdyhjdXJycC55LCAyKSAvIE1hdGgucG93KHJZLCAyKTtcblxuICAgIGlmIChsID4gMSkge1xuICAgICAgclggKj0gTWF0aC5zcXJ0KGwpO1xuICAgICAgclkgKj0gTWF0aC5zcXJ0KGwpO1xuICAgIH0gLy8gY3gnLCBjeSdcblxuXG4gICAgdmFyIHMgPSAobEFyY0ZsYWcgPT09IHN3ZWVwRmxhZyA/IC0xIDogMSkgKiBNYXRoLnNxcnQoKE1hdGgucG93KHJYLCAyKSAqIE1hdGgucG93KHJZLCAyKSAtIE1hdGgucG93KHJYLCAyKSAqIE1hdGgucG93KGN1cnJwLnksIDIpIC0gTWF0aC5wb3coclksIDIpICogTWF0aC5wb3coY3VycnAueCwgMikpIC8gKE1hdGgucG93KHJYLCAyKSAqIE1hdGgucG93KGN1cnJwLnksIDIpICsgTWF0aC5wb3coclksIDIpICogTWF0aC5wb3coY3VycnAueCwgMikpKTtcblxuICAgIGlmIChpc05hTihzKSkge1xuICAgICAgcyA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGNwcCA9IG5ldyBQb2ludChzICogclggKiBjdXJycC55IC8gclksIHMgKiAtclkgKiBjdXJycC54IC8gclgpOyAvLyBjeCwgY3lcblxuICAgIHZhciBjZW50cCA9IG5ldyBQb2ludCgoY3VycmVudC54ICsgY3VycmVudFBvaW50LngpIC8gMi4wICsgTWF0aC5jb3MoeEF4aXNSb3RhdGlvbikgKiBjcHAueCAtIE1hdGguc2luKHhBeGlzUm90YXRpb24pICogY3BwLnksIChjdXJyZW50LnkgKyBjdXJyZW50UG9pbnQueSkgLyAyLjAgKyBNYXRoLnNpbih4QXhpc1JvdGF0aW9uKSAqIGNwcC54ICsgTWF0aC5jb3MoeEF4aXNSb3RhdGlvbikgKiBjcHAueSk7IC8vIGluaXRpYWwgYW5nbGVcblxuICAgIHZhciBhMSA9IHZlY3RvcnNBbmdsZShbMSwgMF0sIFsoY3VycnAueCAtIGNwcC54KSAvIHJYLCAoY3VycnAueSAtIGNwcC55KSAvIHJZXSk7IC8vIM64MVxuICAgIC8vIGFuZ2xlIGRlbHRhXG5cbiAgICB2YXIgdSA9IFsoY3VycnAueCAtIGNwcC54KSAvIHJYLCAoY3VycnAueSAtIGNwcC55KSAvIHJZXTtcbiAgICB2YXIgdiA9IFsoLWN1cnJwLnggLSBjcHAueCkgLyByWCwgKC1jdXJycC55IC0gY3BwLnkpIC8gclldO1xuICAgIHZhciBhZCA9IHZlY3RvcnNBbmdsZSh1LCB2KTsgLy8gzpTOuFxuXG4gICAgaWYgKHZlY3RvcnNSYXRpbyh1LCB2KSA8PSAtMSkge1xuICAgICAgYWQgPSBNYXRoLlBJO1xuICAgIH1cblxuICAgIGlmICh2ZWN0b3JzUmF0aW8odSwgdikgPj0gMSkge1xuICAgICAgYWQgPSAwO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjdXJyZW50UG9pbnQsXG4gICAgICByWCxcbiAgICAgIHJZLFxuICAgICAgc3dlZXBGbGFnLFxuICAgICAgeEF4aXNSb3RhdGlvbixcbiAgICAgIGNlbnRwLFxuICAgICAgYTEsXG4gICAgICBhZFxuICAgIH07XG4gIH1cblxuICBwYXRoQShjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgdmFyIHtcbiAgICAgIHBhdGhQYXJzZXJcbiAgICB9ID0gdGhpcztcbiAgICB2YXIge1xuICAgICAgY3VycmVudFBvaW50LFxuICAgICAgclgsXG4gICAgICByWSxcbiAgICAgIHN3ZWVwRmxhZyxcbiAgICAgIHhBeGlzUm90YXRpb24sXG4gICAgICBjZW50cCxcbiAgICAgIGExLFxuICAgICAgYWRcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aEEocGF0aFBhcnNlcik7IC8vIGZvciBtYXJrZXJzXG5cbiAgICB2YXIgZGlyID0gMSAtIHN3ZWVwRmxhZyA/IDEuMCA6IC0xLjA7XG4gICAgdmFyIGFoID0gYTEgKyBkaXIgKiAoYWQgLyAyLjApO1xuICAgIHZhciBoYWxmV2F5ID0gbmV3IFBvaW50KGNlbnRwLnggKyByWCAqIE1hdGguY29zKGFoKSwgY2VudHAueSArIHJZICogTWF0aC5zaW4oYWgpKTtcbiAgICBwYXRoUGFyc2VyLmFkZE1hcmtlckFuZ2xlKGhhbGZXYXksIGFoIC0gZGlyICogTWF0aC5QSSAvIDIpO1xuICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyQW5nbGUoY3VycmVudFBvaW50LCBhaCAtIGRpciAqIE1hdGguUEkpO1xuICAgIGJvdW5kaW5nQm94LmFkZFBvaW50KGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7IC8vIFRPRE86IHRoaXMgaXMgdG9vIG5haXZlLCBtYWtlIGl0IGJldHRlclxuXG4gICAgaWYgKGN0eCAmJiAhaXNOYU4oYTEpICYmICFpc05hTihhZCkpIHtcbiAgICAgIHZhciByID0gclggPiByWSA/IHJYIDogclk7XG4gICAgICB2YXIgc3ggPSByWCA+IHJZID8gMSA6IHJYIC8gclk7XG4gICAgICB2YXIgc3kgPSByWCA+IHJZID8gclkgLyByWCA6IDE7XG4gICAgICBjdHgudHJhbnNsYXRlKGNlbnRwLngsIGNlbnRwLnkpO1xuICAgICAgY3R4LnJvdGF0ZSh4QXhpc1JvdGF0aW9uKTtcbiAgICAgIGN0eC5zY2FsZShzeCwgc3kpO1xuICAgICAgY3R4LmFyYygwLCAwLCByLCBhMSwgYTEgKyBhZCwgQm9vbGVhbigxIC0gc3dlZXBGbGFnKSk7XG4gICAgICBjdHguc2NhbGUoMSAvIHN4LCAxIC8gc3kpO1xuICAgICAgY3R4LnJvdGF0ZSgteEF4aXNSb3RhdGlvbik7XG4gICAgICBjdHgudHJhbnNsYXRlKC1jZW50cC54LCAtY2VudHAueSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHBhdGhaKHBhdGhQYXJzZXIpIHtcbiAgICBwYXRoUGFyc2VyLmN1cnJlbnQgPSBwYXRoUGFyc2VyLnN0YXJ0O1xuICB9XG5cbiAgcGF0aFooY3R4LCBib3VuZGluZ0JveCkge1xuICAgIFBhdGhFbGVtZW50LnBhdGhaKHRoaXMucGF0aFBhcnNlcik7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICAvLyBvbmx5IGNsb3NlIHBhdGggaWYgaXQgaXMgbm90IGEgc3RyYWlnaHQgbGluZVxuICAgICAgaWYgKGJvdW5kaW5nQm94LngxICE9PSBib3VuZGluZ0JveC54MiAmJiBib3VuZGluZ0JveC55MSAhPT0gYm91bmRpbmdCb3gueTIpIHtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG5cbmNsYXNzIEdseXBoRWxlbWVudCBleHRlbmRzIFBhdGhFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy50eXBlID0gJ2dseXBoJztcbiAgICB0aGlzLmhvcml6QWR2WCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdob3Jpei1hZHYteCcpLmdldE51bWJlcigpO1xuICAgIHRoaXMudW5pY29kZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCd1bmljb2RlJykuZ2V0U3RyaW5nKCk7XG4gICAgdGhpcy5hcmFiaWNGb3JtID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2FyYWJpYy1mb3JtJykuZ2V0U3RyaW5nKCk7XG4gIH1cblxufVxuXG5jbGFzcyBUZXh0RWxlbWVudCBleHRlbmRzIFJlbmRlcmVkRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIG5ldy50YXJnZXQgPT09IFRleHRFbGVtZW50ID8gdHJ1ZSA6IGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIHRoaXMudHlwZSA9ICd0ZXh0JztcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy5tZWFzdXJlQ2FjaGUgPSAtMTtcbiAgfVxuXG4gIHNldENvbnRleHQoY3R4KSB7XG4gICAgdmFyIGZyb21NZWFzdXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICBzdXBlci5zZXRDb250ZXh0KGN0eCwgZnJvbU1lYXN1cmUpO1xuICAgIHZhciB0ZXh0QmFzZWxpbmUgPSB0aGlzLmdldFN0eWxlKCdkb21pbmFudC1iYXNlbGluZScpLmdldFRleHRCYXNlbGluZSgpIHx8IHRoaXMuZ2V0U3R5bGUoJ2FsaWdubWVudC1iYXNlbGluZScpLmdldFRleHRCYXNlbGluZSgpO1xuXG4gICAgaWYgKHRleHRCYXNlbGluZSkge1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9IHRleHRCYXNlbGluZTtcbiAgICB9XG4gIH1cblxuICBpbml0aWFsaXplQ29vcmRpbmF0ZXMoKSB7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMubGVhZlRleHRzID0gW107XG4gICAgdGhpcy50ZXh0Q2h1bmtTdGFydCA9IDA7XG4gICAgdGhpcy5taW5YID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHRoaXMubWF4WCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgfVxuXG4gIGdldEJvdW5kaW5nQm94KGN0eCkge1xuICAgIGlmICh0aGlzLnR5cGUgIT09ICd0ZXh0Jykge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VEVsZW1lbnRCb3VuZGluZ0JveChjdHgpO1xuICAgIH0gLy8gZmlyc3QsIGNhbGN1bGF0ZSBjaGlsZCBwb3NpdGlvbnNcblxuXG4gICAgdGhpcy5pbml0aWFsaXplQ29vcmRpbmF0ZXMoKTtcbiAgICB0aGlzLmFkanVzdENoaWxkQ29vcmRpbmF0ZXNSZWN1cnNpdmUoY3R4KTtcbiAgICB2YXIgYm91bmRpbmdCb3ggPSBudWxsOyAvLyB0aGVuIGNhbGN1bGF0ZSBib3VuZGluZyBib3hcblxuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgoXywgaSkgPT4ge1xuICAgICAgdmFyIGNoaWxkQm91bmRpbmdCb3ggPSB0aGlzLmdldENoaWxkQm91bmRpbmdCb3goY3R4LCB0aGlzLCB0aGlzLCBpKTtcblxuICAgICAgaWYgKCFib3VuZGluZ0JveCkge1xuICAgICAgICBib3VuZGluZ0JveCA9IGNoaWxkQm91bmRpbmdCb3g7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBib3VuZGluZ0JveC5hZGRCb3VuZGluZ0JveChjaGlsZEJvdW5kaW5nQm94KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYm91bmRpbmdCb3g7XG4gIH1cblxuICBnZXRGb250U2l6ZSgpIHtcbiAgICB2YXIge1xuICAgICAgZG9jdW1lbnQsXG4gICAgICBwYXJlbnRcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgaW5oZXJpdEZvbnRTaXplID0gRm9udC5wYXJzZShkb2N1bWVudC5jdHguZm9udCkuZm9udFNpemU7XG4gICAgdmFyIGZvbnRTaXplID0gcGFyZW50LmdldFN0eWxlKCdmb250LXNpemUnKS5nZXROdW1iZXIoaW5oZXJpdEZvbnRTaXplKTtcbiAgICByZXR1cm4gZm9udFNpemU7XG4gIH1cblxuICBnZXRURWxlbWVudEJvdW5kaW5nQm94KGN0eCkge1xuICAgIHZhciBmb250U2l6ZSA9IHRoaXMuZ2V0Rm9udFNpemUoKTtcbiAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KHRoaXMueCwgdGhpcy55IC0gZm9udFNpemUsIHRoaXMueCArIHRoaXMubWVhc3VyZVRleHQoY3R4KSwgdGhpcy55KTtcbiAgfVxuXG4gIGdldEdseXBoKGZvbnQsIHRleHQsIGkpIHtcbiAgICB2YXIgY2hhciA9IHRleHRbaV07XG4gICAgdmFyIGdseXBoID0gbnVsbDtcblxuICAgIGlmIChmb250LmlzQXJhYmljKSB7XG4gICAgICB2YXIgbGVuID0gdGV4dC5sZW5ndGg7XG4gICAgICB2YXIgcHJldkNoYXIgPSB0ZXh0W2kgLSAxXTtcbiAgICAgIHZhciBuZXh0Q2hhciA9IHRleHRbaSArIDFdO1xuICAgICAgdmFyIGFyYWJpY0Zvcm0gPSAnaXNvbGF0ZWQnO1xuXG4gICAgICBpZiAoKGkgPT09IDAgfHwgcHJldkNoYXIgPT09ICcgJykgJiYgaSA8IGxlbiAtIDEgJiYgbmV4dENoYXIgIT09ICcgJykge1xuICAgICAgICBhcmFiaWNGb3JtID0gJ3Rlcm1pbmFsJztcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPiAwICYmIHByZXZDaGFyICE9PSAnICcgJiYgaSA8IGxlbiAtIDEgJiYgbmV4dENoYXIgIT09ICcgJykge1xuICAgICAgICBhcmFiaWNGb3JtID0gJ21lZGlhbCc7XG4gICAgICB9XG5cbiAgICAgIGlmIChpID4gMCAmJiBwcmV2Q2hhciAhPT0gJyAnICYmIChpID09PSBsZW4gLSAxIHx8IG5leHRDaGFyID09PSAnICcpKSB7XG4gICAgICAgIGFyYWJpY0Zvcm0gPSAnaW5pdGlhbCc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZm9udC5nbHlwaHNbY2hhcl0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIE5FRUQgVEVTVFxuICAgICAgICB2YXIgbWF5YmVHbHlwaCA9IGZvbnQuZ2x5cGhzW2NoYXJdO1xuICAgICAgICBnbHlwaCA9IG1heWJlR2x5cGggaW5zdGFuY2VvZiBHbHlwaEVsZW1lbnQgPyBtYXliZUdseXBoIDogbWF5YmVHbHlwaFthcmFiaWNGb3JtXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZ2x5cGggPSBmb250LmdseXBoc1tjaGFyXTtcbiAgICB9XG5cbiAgICBpZiAoIWdseXBoKSB7XG4gICAgICBnbHlwaCA9IGZvbnQubWlzc2luZ0dseXBoO1xuICAgIH1cblxuICAgIHJldHVybiBnbHlwaDtcbiAgfVxuXG4gIGdldFRleHQoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgZ2V0VGV4dEZyb21Ob2RlKG5vZGUpIHtcbiAgICB2YXIgdGV4dE5vZGUgPSBub2RlIHx8IHRoaXMubm9kZTtcbiAgICB2YXIgY2hpbGROb2RlcyA9IEFycmF5LmZyb20odGV4dE5vZGUucGFyZW50Tm9kZS5jaGlsZE5vZGVzKTtcbiAgICB2YXIgaW5kZXggPSBjaGlsZE5vZGVzLmluZGV4T2YodGV4dE5vZGUpO1xuICAgIHZhciBsYXN0SW5kZXggPSBjaGlsZE5vZGVzLmxlbmd0aCAtIDE7XG4gICAgdmFyIHRleHQgPSBjb21wcmVzc1NwYWNlcyggLy8gdGV4dE5vZGUudmFsdWVcbiAgICAvLyB8fCB0ZXh0Tm9kZS50ZXh0XG4gICAgdGV4dE5vZGUudGV4dENvbnRlbnQgfHwgJycpO1xuXG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICB0ZXh0ID0gdHJpbUxlZnQodGV4dCk7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ID09PSBsYXN0SW5kZXgpIHtcbiAgICAgIHRleHQgPSB0cmltUmlnaHQodGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cblxuICByZW5kZXJDaGlsZHJlbihjdHgpIHtcbiAgICBpZiAodGhpcy50eXBlICE9PSAndGV4dCcpIHtcbiAgICAgIHRoaXMucmVuZGVyVEVsZW1lbnRDaGlsZHJlbihjdHgpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gZmlyc3QsIGNhbGN1bGF0ZSBjaGlsZCBwb3NpdGlvbnNcblxuXG4gICAgdGhpcy5pbml0aWFsaXplQ29vcmRpbmF0ZXMoKTtcbiAgICB0aGlzLmFkanVzdENoaWxkQ29vcmRpbmF0ZXNSZWN1cnNpdmUoY3R4KTsgLy8gdGhlbiByZW5kZXJcblxuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgoXywgaSkgPT4ge1xuICAgICAgdGhpcy5yZW5kZXJDaGlsZChjdHgsIHRoaXMsIHRoaXMsIGkpO1xuICAgIH0pO1xuICAgIHZhciB7XG4gICAgICBtb3VzZVxuICAgIH0gPSB0aGlzLmRvY3VtZW50LnNjcmVlbjsgLy8gRG8gbm90IGNhbGMgYm91bmRpbmcgYm94IGlmIG1vdXNlIGlzIG5vdCB3b3JraW5nLlxuXG4gICAgaWYgKG1vdXNlLmlzV29ya2luZygpKSB7XG4gICAgICBtb3VzZS5jaGVja0JvdW5kaW5nQm94KHRoaXMsIHRoaXMuZ2V0Qm91bmRpbmdCb3goY3R4KSk7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyVEVsZW1lbnRDaGlsZHJlbihjdHgpIHtcbiAgICB2YXIge1xuICAgICAgZG9jdW1lbnQsXG4gICAgICBwYXJlbnRcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgcmVuZGVyVGV4dCA9IHRoaXMuZ2V0VGV4dCgpO1xuICAgIHZhciBjdXN0b21Gb250ID0gcGFyZW50LmdldFN0eWxlKCdmb250LWZhbWlseScpLmdldERlZmluaXRpb24oKTtcblxuICAgIGlmIChjdXN0b21Gb250KSB7XG4gICAgICB2YXIge1xuICAgICAgICB1bml0c1BlckVtXG4gICAgICB9ID0gY3VzdG9tRm9udC5mb250RmFjZTtcbiAgICAgIHZhciBjdHhGb250ID0gRm9udC5wYXJzZShkb2N1bWVudC5jdHguZm9udCk7XG4gICAgICB2YXIgZm9udFNpemUgPSBwYXJlbnQuZ2V0U3R5bGUoJ2ZvbnQtc2l6ZScpLmdldE51bWJlcihjdHhGb250LmZvbnRTaXplKTtcbiAgICAgIHZhciBmb250U3R5bGUgPSBwYXJlbnQuZ2V0U3R5bGUoJ2ZvbnQtc3R5bGUnKS5nZXRTdHJpbmcoY3R4Rm9udC5mb250U3R5bGUpO1xuICAgICAgdmFyIHNjYWxlID0gZm9udFNpemUgLyB1bml0c1BlckVtO1xuICAgICAgdmFyIHRleHQgPSBjdXN0b21Gb250LmlzUlRMID8gcmVuZGVyVGV4dC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpIDogcmVuZGVyVGV4dDtcbiAgICAgIHZhciBkeCA9IHRvTnVtYmVycyhwYXJlbnQuZ2V0QXR0cmlidXRlKCdkeCcpLmdldFN0cmluZygpKTtcbiAgICAgIHZhciBsZW4gPSB0ZXh0Lmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgZ2x5cGggPSB0aGlzLmdldEdseXBoKGN1c3RvbUZvbnQsIHRleHQsIGkpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgY3R4LnNjYWxlKHNjYWxlLCAtc2NhbGUpO1xuICAgICAgICB2YXIgbHcgPSBjdHgubGluZVdpZHRoO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gY3R4LmxpbmVXaWR0aCAqIHVuaXRzUGVyRW0gLyBmb250U2l6ZTtcblxuICAgICAgICBpZiAoZm9udFN0eWxlID09PSAnaXRhbGljJykge1xuICAgICAgICAgIGN0eC50cmFuc2Zvcm0oMSwgMCwgLjQsIDEsIDAsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2x5cGgucmVuZGVyKGN0eCk7XG5cbiAgICAgICAgaWYgKGZvbnRTdHlsZSA9PT0gJ2l0YWxpYycpIHtcbiAgICAgICAgICBjdHgudHJhbnNmb3JtKDEsIDAsIC0uNCwgMSwgMCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHgubGluZVdpZHRoID0gbHc7XG4gICAgICAgIGN0eC5zY2FsZSgxIC8gc2NhbGUsIC0xIC8gc2NhbGUpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKC10aGlzLngsIC10aGlzLnkpO1xuICAgICAgICB0aGlzLnggKz0gZm9udFNpemUgKiAoZ2x5cGguaG9yaXpBZHZYIHx8IGN1c3RvbUZvbnQuaG9yaXpBZHZYKSAvIHVuaXRzUGVyRW07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkeFtpXSAhPT0gJ3VuZGVmaW5lZCcgJiYgIWlzTmFOKGR4W2ldKSkge1xuICAgICAgICAgIHRoaXMueCArPSBkeFtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHRoaXM7IC8vIE5FRUQgVEVTVFxuICAgIC8vIGlmIChjdHgucGFpbnRPcmRlciA9PT0gJ3N0cm9rZScpIHtcbiAgICAvLyBcdGlmIChjdHguc3Ryb2tlU3R5bGUpIHtcbiAgICAvLyBcdFx0Y3R4LnN0cm9rZVRleHQocmVuZGVyVGV4dCwgeCwgeSk7XG4gICAgLy8gXHR9XG4gICAgLy8gXHRpZiAoY3R4LmZpbGxTdHlsZSkge1xuICAgIC8vIFx0XHRjdHguZmlsbFRleHQocmVuZGVyVGV4dCwgeCwgeSk7XG4gICAgLy8gXHR9XG4gICAgLy8gfSBlbHNlIHtcblxuICAgIGlmIChjdHguZmlsbFN0eWxlKSB7XG4gICAgICBjdHguZmlsbFRleHQocmVuZGVyVGV4dCwgeCwgeSk7XG4gICAgfVxuXG4gICAgaWYgKGN0eC5zdHJva2VTdHlsZSkge1xuICAgICAgY3R4LnN0cm9rZVRleHQocmVuZGVyVGV4dCwgeCwgeSk7XG4gICAgfSAvLyB9XG5cbiAgfVxuXG4gIGFwcGx5QW5jaG9yaW5nKCkge1xuICAgIGlmICh0aGlzLnRleHRDaHVua1N0YXJ0ID49IHRoaXMubGVhZlRleHRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gVGhpcyBpcyBiYXNpY2FsbHkgdGhlIFwiQXBwbHkgYW5jaG9yaW5nXCIgcGFydCBvZiBodHRwczovL3d3dy53My5vcmcvVFIvU1ZHMi90ZXh0Lmh0bWwjVGV4dExheW91dEFsZ29yaXRobS5cbiAgICAvLyBUaGUgZGlmZmVyZW5jZSBpcyB0aGF0IHdlIGFwcGx5IHRoZSBhbmNob3JpbmcgYXMgc29vbiBhcyBhIGNodW5rIGlzIGZpbmlzaGVkLiBUaGlzIHNhdmVzIHNvbWUgZXh0cmEgbG9vcGluZy5cbiAgICAvLyBWZXJ0aWNhbCB0ZXh0IGlzIG5vdCBzdXBwb3J0ZWQuXG5cblxuICAgIHZhciBmaXJzdEVsZW1lbnQgPSB0aGlzLmxlYWZUZXh0c1t0aGlzLnRleHRDaHVua1N0YXJ0XTtcbiAgICB2YXIgdGV4dEFuY2hvciA9IGZpcnN0RWxlbWVudC5nZXRTdHlsZSgndGV4dC1hbmNob3InKS5nZXRTdHJpbmcoJ3N0YXJ0Jyk7XG4gICAgdmFyIGlzUlRMID0gZmFsc2U7IC8vIHdlIHRyZWF0IFJUTCBsaWtlIExUUlxuXG4gICAgdmFyIHNoaWZ0ID0gMDtcblxuICAgIGlmICh0ZXh0QW5jaG9yID09PSAnc3RhcnQnICYmICFpc1JUTCB8fCB0ZXh0QW5jaG9yID09PSAnZW5kJyAmJiBpc1JUTCkge1xuICAgICAgc2hpZnQgPSBmaXJzdEVsZW1lbnQueCAtIHRoaXMubWluWDtcbiAgICB9IGVsc2UgaWYgKHRleHRBbmNob3IgPT09ICdlbmQnICYmICFpc1JUTCB8fCB0ZXh0QW5jaG9yID09PSAnc3RhcnQnICYmIGlzUlRMKSB7XG4gICAgICBzaGlmdCA9IGZpcnN0RWxlbWVudC54IC0gdGhpcy5tYXhYO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaGlmdCA9IGZpcnN0RWxlbWVudC54IC0gKHRoaXMubWluWCArIHRoaXMubWF4WCkgLyAyO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSB0aGlzLnRleHRDaHVua1N0YXJ0OyBpIDwgdGhpcy5sZWFmVGV4dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMubGVhZlRleHRzW2ldLnggKz0gc2hpZnQ7XG4gICAgfSAvLyBzdGFydCBuZXcgY2h1bmtcblxuXG4gICAgdGhpcy5taW5YID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHRoaXMubWF4WCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICB0aGlzLnRleHRDaHVua1N0YXJ0ID0gdGhpcy5sZWFmVGV4dHMubGVuZ3RoO1xuICB9XG5cbiAgYWRqdXN0Q2hpbGRDb29yZGluYXRlc1JlY3Vyc2l2ZShjdHgpIHtcbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goKF8sIGkpID0+IHtcbiAgICAgIHRoaXMuYWRqdXN0Q2hpbGRDb29yZGluYXRlc1JlY3Vyc2l2ZUNvcmUoY3R4LCB0aGlzLCB0aGlzLCBpKTtcbiAgICB9KTtcbiAgICB0aGlzLmFwcGx5QW5jaG9yaW5nKCk7XG4gIH1cblxuICBhZGp1c3RDaGlsZENvb3JkaW5hdGVzUmVjdXJzaXZlQ29yZShjdHgsIHRleHRQYXJlbnQsIHBhcmVudCwgaSkge1xuICAgIHZhciBjaGlsZCA9IHBhcmVudC5jaGlsZHJlbltpXTtcblxuICAgIGlmIChjaGlsZC5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICBjaGlsZC5jaGlsZHJlbi5mb3JFYWNoKChfLCBpKSA9PiB7XG4gICAgICAgIHRleHRQYXJlbnQuYWRqdXN0Q2hpbGRDb29yZGluYXRlc1JlY3Vyc2l2ZUNvcmUoY3R4LCB0ZXh0UGFyZW50LCBjaGlsZCwgaSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb25seSBsZWFmcyBhcmUgcmVsZXZhbnRcbiAgICAgIHRoaXMuYWRqdXN0Q2hpbGRDb29yZGluYXRlcyhjdHgsIHRleHRQYXJlbnQsIHBhcmVudCwgaSk7XG4gICAgfVxuICB9XG5cbiAgYWRqdXN0Q2hpbGRDb29yZGluYXRlcyhjdHgsIHRleHRQYXJlbnQsIHBhcmVudCwgaSkge1xuICAgIHZhciBjaGlsZCA9IHBhcmVudC5jaGlsZHJlbltpXTtcblxuICAgIGlmICh0eXBlb2YgY2hpbGQubWVhc3VyZVRleHQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9XG5cbiAgICBjdHguc2F2ZSgpO1xuICAgIGNoaWxkLnNldENvbnRleHQoY3R4LCB0cnVlKTtcbiAgICB2YXIgeEF0dHIgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoJ3gnKTtcbiAgICB2YXIgeUF0dHIgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoJ3knKTtcbiAgICB2YXIgZHhBdHRyID0gY2hpbGQuZ2V0QXR0cmlidXRlKCdkeCcpO1xuICAgIHZhciBkeUF0dHIgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoJ2R5Jyk7XG4gICAgdmFyIGN1c3RvbUZvbnQgPSBjaGlsZC5nZXRTdHlsZSgnZm9udC1mYW1pbHknKS5nZXREZWZpbml0aW9uKCk7XG4gICAgdmFyIGlzUlRMID0gQm9vbGVhbihjdXN0b21Gb250KSAmJiBjdXN0b21Gb250LmlzUlRMO1xuXG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIC8vIEZpcnN0IGNoaWxkcmVuIGluaGVyaXQgYXR0cmlidXRlcyBmcm9tIHBhcmVudChzKS4gUG9zaXRpb25hbCBhdHRyaWJ1dGVzXG4gICAgICAvLyBhcmUgb25seSBpbmhlcml0ZWQgZnJvbSBhIHBhcmVudCB0byBpdCdzIGZpcnN0IGNoaWxkLlxuICAgICAgaWYgKCF4QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHhBdHRyLnNldFZhbHVlKGNoaWxkLmdldEluaGVyaXRlZEF0dHJpYnV0ZSgneCcpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF5QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHlBdHRyLnNldFZhbHVlKGNoaWxkLmdldEluaGVyaXRlZEF0dHJpYnV0ZSgneScpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkeEF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICBkeEF0dHIuc2V0VmFsdWUoY2hpbGQuZ2V0SW5oZXJpdGVkQXR0cmlidXRlKCdkeCcpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkeUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICBkeUF0dHIuc2V0VmFsdWUoY2hpbGQuZ2V0SW5oZXJpdGVkQXR0cmlidXRlKCdkeScpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgd2lkdGggPSBjaGlsZC5tZWFzdXJlVGV4dChjdHgpO1xuXG4gICAgaWYgKGlzUlRMKSB7XG4gICAgICB0ZXh0UGFyZW50LnggLT0gd2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKHhBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgIC8vIGFuIFwieFwiIGF0dHJpYnV0ZSBtYXJrcyB0aGUgc3RhcnQgb2YgYSBuZXcgY2h1bmtcbiAgICAgIHRleHRQYXJlbnQuYXBwbHlBbmNob3JpbmcoKTtcbiAgICAgIGNoaWxkLnggPSB4QXR0ci5nZXRQaXhlbHMoJ3gnKTtcblxuICAgICAgaWYgKGR4QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGNoaWxkLnggKz0gZHhBdHRyLmdldFBpeGVscygneCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZHhBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgdGV4dFBhcmVudC54ICs9IGR4QXR0ci5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQueCA9IHRleHRQYXJlbnQueDtcbiAgICB9XG5cbiAgICB0ZXh0UGFyZW50LnggPSBjaGlsZC54O1xuXG4gICAgaWYgKCFpc1JUTCkge1xuICAgICAgdGV4dFBhcmVudC54ICs9IHdpZHRoO1xuICAgIH1cblxuICAgIGlmICh5QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICBjaGlsZC55ID0geUF0dHIuZ2V0UGl4ZWxzKCd5Jyk7XG5cbiAgICAgIGlmIChkeUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICBjaGlsZC55ICs9IGR5QXR0ci5nZXRQaXhlbHMoJ3knKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGR5QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHRleHRQYXJlbnQueSArPSBkeUF0dHIuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkLnkgPSB0ZXh0UGFyZW50Lnk7XG4gICAgfVxuXG4gICAgdGV4dFBhcmVudC55ID0gY2hpbGQueTsgLy8gdXBkYXRlIHRoZSBjdXJyZW50IGNodW5rIGFuZCBpdCdzIGJvdW5kc1xuXG4gICAgdGV4dFBhcmVudC5sZWFmVGV4dHMucHVzaChjaGlsZCk7XG4gICAgdGV4dFBhcmVudC5taW5YID0gTWF0aC5taW4odGV4dFBhcmVudC5taW5YLCBjaGlsZC54LCBjaGlsZC54ICsgd2lkdGgpO1xuICAgIHRleHRQYXJlbnQubWF4WCA9IE1hdGgubWF4KHRleHRQYXJlbnQubWF4WCwgY2hpbGQueCwgY2hpbGQueCArIHdpZHRoKTtcbiAgICBjaGlsZC5jbGVhckNvbnRleHQoY3R4KTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIHJldHVybiBjaGlsZDtcbiAgfVxuXG4gIGdldENoaWxkQm91bmRpbmdCb3goY3R4LCB0ZXh0UGFyZW50LCBwYXJlbnQsIGkpIHtcbiAgICB2YXIgY2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5baV07IC8vIG5vdCBhIHRleHQgbm9kZT9cblxuICAgIGlmICh0eXBlb2YgY2hpbGQuZ2V0Qm91bmRpbmdCb3ggIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBib3VuZGluZ0JveCA9IGNoaWxkLmdldEJvdW5kaW5nQm94KGN0eCk7XG5cbiAgICBpZiAoIWJvdW5kaW5nQm94KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjaGlsZC5jaGlsZHJlbi5mb3JFYWNoKChfLCBpKSA9PiB7XG4gICAgICB2YXIgY2hpbGRCb3VuZGluZ0JveCA9IHRleHRQYXJlbnQuZ2V0Q2hpbGRCb3VuZGluZ0JveChjdHgsIHRleHRQYXJlbnQsIGNoaWxkLCBpKTtcbiAgICAgIGJvdW5kaW5nQm94LmFkZEJvdW5kaW5nQm94KGNoaWxkQm91bmRpbmdCb3gpO1xuICAgIH0pO1xuICAgIHJldHVybiBib3VuZGluZ0JveDtcbiAgfVxuXG4gIHJlbmRlckNoaWxkKGN0eCwgdGV4dFBhcmVudCwgcGFyZW50LCBpKSB7XG4gICAgdmFyIGNoaWxkID0gcGFyZW50LmNoaWxkcmVuW2ldO1xuICAgIGNoaWxkLnJlbmRlcihjdHgpO1xuICAgIGNoaWxkLmNoaWxkcmVuLmZvckVhY2goKF8sIGkpID0+IHtcbiAgICAgIHRleHRQYXJlbnQucmVuZGVyQ2hpbGQoY3R4LCB0ZXh0UGFyZW50LCBjaGlsZCwgaSk7XG4gICAgfSk7XG4gIH1cblxuICBtZWFzdXJlVGV4dChjdHgpIHtcbiAgICB2YXIge1xuICAgICAgbWVhc3VyZUNhY2hlXG4gICAgfSA9IHRoaXM7XG5cbiAgICBpZiAofm1lYXN1cmVDYWNoZSkge1xuICAgICAgcmV0dXJuIG1lYXN1cmVDYWNoZTtcbiAgICB9XG5cbiAgICB2YXIgcmVuZGVyVGV4dCA9IHRoaXMuZ2V0VGV4dCgpO1xuICAgIHZhciBtZWFzdXJlID0gdGhpcy5tZWFzdXJlVGFyZ2V0VGV4dChjdHgsIHJlbmRlclRleHQpO1xuICAgIHRoaXMubWVhc3VyZUNhY2hlID0gbWVhc3VyZTtcbiAgICByZXR1cm4gbWVhc3VyZTtcbiAgfVxuXG4gIG1lYXN1cmVUYXJnZXRUZXh0KGN0eCwgdGFyZ2V0VGV4dCkge1xuICAgIGlmICghdGFyZ2V0VGV4dC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBwYXJlbnRcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgY3VzdG9tRm9udCA9IHBhcmVudC5nZXRTdHlsZSgnZm9udC1mYW1pbHknKS5nZXREZWZpbml0aW9uKCk7XG5cbiAgICBpZiAoY3VzdG9tRm9udCkge1xuICAgICAgdmFyIGZvbnRTaXplID0gdGhpcy5nZXRGb250U2l6ZSgpO1xuICAgICAgdmFyIHRleHQgPSBjdXN0b21Gb250LmlzUlRMID8gdGFyZ2V0VGV4dC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpIDogdGFyZ2V0VGV4dDtcbiAgICAgIHZhciBkeCA9IHRvTnVtYmVycyhwYXJlbnQuZ2V0QXR0cmlidXRlKCdkeCcpLmdldFN0cmluZygpKTtcbiAgICAgIHZhciBsZW4gPSB0ZXh0Lmxlbmd0aDtcbiAgICAgIHZhciBfbWVhc3VyZSA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGdseXBoID0gdGhpcy5nZXRHbHlwaChjdXN0b21Gb250LCB0ZXh0LCBpKTtcbiAgICAgICAgX21lYXN1cmUgKz0gKGdseXBoLmhvcml6QWR2WCB8fCBjdXN0b21Gb250Lmhvcml6QWR2WCkgKiBmb250U2l6ZSAvIGN1c3RvbUZvbnQuZm9udEZhY2UudW5pdHNQZXJFbTtcblxuICAgICAgICBpZiAodHlwZW9mIGR4W2ldICE9PSAndW5kZWZpbmVkJyAmJiAhaXNOYU4oZHhbaV0pKSB7XG4gICAgICAgICAgX21lYXN1cmUgKz0gZHhbaV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9tZWFzdXJlO1xuICAgIH1cblxuICAgIGlmICghY3R4Lm1lYXN1cmVUZXh0KSB7XG4gICAgICByZXR1cm4gdGFyZ2V0VGV4dC5sZW5ndGggKiAxMDtcbiAgICB9XG5cbiAgICBjdHguc2F2ZSgpO1xuICAgIHRoaXMuc2V0Q29udGV4dChjdHgsIHRydWUpO1xuICAgIHZhciB7XG4gICAgICB3aWR0aDogbWVhc3VyZVxuICAgIH0gPSBjdHgubWVhc3VyZVRleHQodGFyZ2V0VGV4dCk7XG4gICAgdGhpcy5jbGVhckNvbnRleHQoY3R4KTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIHJldHVybiBtZWFzdXJlO1xuICB9XG4gIC8qKlxyXG4gICAqIEluaGVyaXRzIHBvc2l0aW9uYWwgYXR0cmlidXRlcyBmcm9tIHtAbGluayBUZXh0RWxlbWVudH0gcGFyZW50KHMpLiBBdHRyaWJ1dGVzXHJcbiAgICogYXJlIG9ubHkgaW5oZXJpdGVkIGZyb20gYSBwYXJlbnQgdG8gaXRzIGZpcnN0IGNoaWxkLlxyXG4gICAqIEBwYXJhbSBuYW1lIC0gVGhlIGF0dHJpYnV0ZSBuYW1lLlxyXG4gICAqIEByZXR1cm5zIFRoZSBhdHRyaWJ1dGUgdmFsdWUgb3IgbnVsbC5cclxuICAgKi9cblxuXG4gIGdldEluaGVyaXRlZEF0dHJpYnV0ZShuYW1lKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzLGNvbnNpc3RlbnQtdGhpc1xuICAgIHZhciBjdXJyZW50ID0gdGhpcztcblxuICAgIHdoaWxlIChjdXJyZW50IGluc3RhbmNlb2YgVGV4dEVsZW1lbnQgJiYgY3VycmVudC5pc0ZpcnN0Q2hpbGQoKSkge1xuICAgICAgdmFyIHBhcmVudEF0dHIgPSBjdXJyZW50LnBhcmVudC5nZXRBdHRyaWJ1dGUobmFtZSk7XG5cbiAgICAgIGlmIChwYXJlbnRBdHRyLmhhc1ZhbHVlKHRydWUpKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnRBdHRyLmdldFZhbHVlKCcwJyk7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG59XG5cbmNsYXNzIFRTcGFuRWxlbWVudCBleHRlbmRzIFRleHRFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgbmV3LnRhcmdldCA9PT0gVFNwYW5FbGVtZW50ID8gdHJ1ZSA6IGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIHRoaXMudHlwZSA9ICd0c3Bhbic7IC8vIGlmIHRoaXMgbm9kZSBoYXMgY2hpbGRyZW4sIHRoZW4gdGhleSBvd24gdGhlIHRleHRcblxuICAgIHRoaXMudGV4dCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCA/ICcnIDogdGhpcy5nZXRUZXh0RnJvbU5vZGUoKTtcbiAgfVxuXG4gIGdldFRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgfVxuXG59XG5cbmNsYXNzIFRleHROb2RlIGV4dGVuZHMgVFNwYW5FbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAndGV4dE5vZGUnO1xuICB9XG5cbn1cblxuY2xhc3MgU1ZHRWxlbWVudCBleHRlbmRzIFJlbmRlcmVkRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ3N2Zyc7XG4gICAgdGhpcy5yb290ID0gZmFsc2U7XG4gIH1cblxuICBzZXRDb250ZXh0KGN0eCkge1xuICAgIHZhciBfdGhpcyRub2RlJHBhcmVudE5vZGU7XG5cbiAgICB2YXIge1xuICAgICAgZG9jdW1lbnRcbiAgICB9ID0gdGhpcztcbiAgICB2YXIge1xuICAgICAgc2NyZWVuLFxuICAgICAgd2luZG93XG4gICAgfSA9IGRvY3VtZW50O1xuICAgIHZhciBjYW52YXMgPSBjdHguY2FudmFzO1xuICAgIHNjcmVlbi5zZXREZWZhdWx0cyhjdHgpO1xuXG4gICAgaWYgKGNhbnZhcy5zdHlsZSAmJiB0eXBlb2YgY3R4LmZvbnQgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdyAmJiB0eXBlb2Ygd2luZG93LmdldENvbXB1dGVkU3R5bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjdHguZm9udCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGNhbnZhcykuZ2V0UHJvcGVydHlWYWx1ZSgnZm9udCcpO1xuICAgICAgdmFyIGZvbnRTaXplUHJvcCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ2ZvbnRTaXplJywgRm9udC5wYXJzZShjdHguZm9udCkuZm9udFNpemUpO1xuXG4gICAgICBpZiAoZm9udFNpemVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgZG9jdW1lbnQucm9vdEVtU2l6ZSA9IGZvbnRTaXplUHJvcC5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgZG9jdW1lbnQuZW1TaXplID0gZG9jdW1lbnQucm9vdEVtU2l6ZTtcbiAgICAgIH1cbiAgICB9IC8vIGNyZWF0ZSBuZXcgdmlldyBwb3J0XG5cblxuICAgIGlmICghdGhpcy5nZXRBdHRyaWJ1dGUoJ3gnKS5oYXNWYWx1ZSgpKSB7XG4gICAgICB0aGlzLmdldEF0dHJpYnV0ZSgneCcsIHRydWUpLnNldFZhbHVlKDApO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5nZXRBdHRyaWJ1dGUoJ3knKS5oYXNWYWx1ZSgpKSB7XG4gICAgICB0aGlzLmdldEF0dHJpYnV0ZSgneScsIHRydWUpLnNldFZhbHVlKDApO1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBzY3JlZW4udmlld1BvcnQ7XG5cbiAgICBpZiAoIXRoaXMuZ2V0U3R5bGUoJ3dpZHRoJykuaGFzVmFsdWUoKSkge1xuICAgICAgdGhpcy5nZXRTdHlsZSgnd2lkdGgnLCB0cnVlKS5zZXRWYWx1ZSgnMTAwJScpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5nZXRTdHlsZSgnaGVpZ2h0JykuaGFzVmFsdWUoKSkge1xuICAgICAgdGhpcy5nZXRTdHlsZSgnaGVpZ2h0JywgdHJ1ZSkuc2V0VmFsdWUoJzEwMCUnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZ2V0U3R5bGUoJ2NvbG9yJykuaGFzVmFsdWUoKSkge1xuICAgICAgdGhpcy5nZXRTdHlsZSgnY29sb3InLCB0cnVlKS5zZXRWYWx1ZSgnYmxhY2snKTtcbiAgICB9XG5cbiAgICB2YXIgcmVmWEF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgncmVmWCcpO1xuICAgIHZhciByZWZZQXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyZWZZJyk7XG4gICAgdmFyIHZpZXdCb3hBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKTtcbiAgICB2YXIgdmlld0JveCA9IHZpZXdCb3hBdHRyLmhhc1ZhbHVlKCkgPyB0b051bWJlcnModmlld0JveEF0dHIuZ2V0U3RyaW5nKCkpIDogbnVsbDtcbiAgICB2YXIgY2xpcCA9ICF0aGlzLnJvb3QgJiYgdGhpcy5nZXRTdHlsZSgnb3ZlcmZsb3cnKS5nZXRWYWx1ZSgnaGlkZGVuJykgIT09ICd2aXNpYmxlJztcbiAgICB2YXIgbWluWCA9IDA7XG4gICAgdmFyIG1pblkgPSAwO1xuICAgIHZhciBjbGlwWCA9IDA7XG4gICAgdmFyIGNsaXBZID0gMDtcblxuICAgIGlmICh2aWV3Qm94KSB7XG4gICAgICBtaW5YID0gdmlld0JveFswXTtcbiAgICAgIG1pblkgPSB2aWV3Qm94WzFdO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5yb290KSB7XG4gICAgICB3aWR0aCA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICBoZWlnaHQgPSB0aGlzLmdldFN0eWxlKCdoZWlnaHQnKS5nZXRQaXhlbHMoJ3knKTtcblxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ21hcmtlcicpIHtcbiAgICAgICAgY2xpcFggPSBtaW5YO1xuICAgICAgICBjbGlwWSA9IG1pblk7XG4gICAgICAgIG1pblggPSAwO1xuICAgICAgICBtaW5ZID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzY3JlZW4udmlld1BvcnQuc2V0Q3VycmVudCh3aWR0aCwgaGVpZ2h0KTsgLy8gRGVmYXVsdCB2YWx1ZSBvZiB0cmFuc2Zvcm0tb3JpZ2luIGlzIGNlbnRlciBvbmx5IGZvciByb290IFNWRyBlbGVtZW50c1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvdHJhbnNmb3JtLW9yaWdpblxuXG4gICAgaWYgKHRoaXMubm9kZSAvLyBpcyBub3QgdGVtcG9yYXJ5IFNWR0VsZW1lbnRcbiAgICAmJiAoIXRoaXMucGFyZW50IHx8ICgoX3RoaXMkbm9kZSRwYXJlbnROb2RlID0gdGhpcy5ub2RlLnBhcmVudE5vZGUpID09PSBudWxsIHx8IF90aGlzJG5vZGUkcGFyZW50Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkbm9kZSRwYXJlbnROb2RlLm5vZGVOYW1lKSA9PT0gJ2ZvcmVpZ25PYmplY3QnKSAmJiB0aGlzLmdldFN0eWxlKCd0cmFuc2Zvcm0nLCBmYWxzZSwgdHJ1ZSkuaGFzVmFsdWUoKSAmJiAhdGhpcy5nZXRTdHlsZSgndHJhbnNmb3JtLW9yaWdpbicsIGZhbHNlLCB0cnVlKS5oYXNWYWx1ZSgpKSB7XG4gICAgICB0aGlzLmdldFN0eWxlKCd0cmFuc2Zvcm0tb3JpZ2luJywgdHJ1ZSwgdHJ1ZSkuc2V0VmFsdWUoJzUwJSA1MCUnKTtcbiAgICB9XG5cbiAgICBzdXBlci5zZXRDb250ZXh0KGN0eCk7XG4gICAgY3R4LnRyYW5zbGF0ZSh0aGlzLmdldEF0dHJpYnV0ZSgneCcpLmdldFBpeGVscygneCcpLCB0aGlzLmdldEF0dHJpYnV0ZSgneScpLmdldFBpeGVscygneScpKTtcblxuICAgIGlmICh2aWV3Qm94KSB7XG4gICAgICB3aWR0aCA9IHZpZXdCb3hbMl07XG4gICAgICBoZWlnaHQgPSB2aWV3Qm94WzNdO1xuICAgIH1cblxuICAgIGRvY3VtZW50LnNldFZpZXdCb3goe1xuICAgICAgY3R4LFxuICAgICAgYXNwZWN0UmF0aW86IHRoaXMuZ2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJykuZ2V0U3RyaW5nKCksXG4gICAgICB3aWR0aDogc2NyZWVuLnZpZXdQb3J0LndpZHRoLFxuICAgICAgZGVzaXJlZFdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogc2NyZWVuLnZpZXdQb3J0LmhlaWdodCxcbiAgICAgIGRlc2lyZWRIZWlnaHQ6IGhlaWdodCxcbiAgICAgIG1pblgsXG4gICAgICBtaW5ZLFxuICAgICAgcmVmWDogcmVmWEF0dHIuZ2V0VmFsdWUoKSxcbiAgICAgIHJlZlk6IHJlZllBdHRyLmdldFZhbHVlKCksXG4gICAgICBjbGlwLFxuICAgICAgY2xpcFgsXG4gICAgICBjbGlwWVxuICAgIH0pO1xuXG4gICAgaWYgKHZpZXdCb3gpIHtcbiAgICAgIHNjcmVlbi52aWV3UG9ydC5yZW1vdmVDdXJyZW50KCk7XG4gICAgICBzY3JlZW4udmlld1BvcnQuc2V0Q3VycmVudCh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gIH1cblxuICBjbGVhckNvbnRleHQoY3R4KSB7XG4gICAgc3VwZXIuY2xlYXJDb250ZXh0KGN0eCk7XG4gICAgdGhpcy5kb2N1bWVudC5zY3JlZW4udmlld1BvcnQucmVtb3ZlQ3VycmVudCgpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJlc2l6ZSBTVkcgdG8gZml0IGluIGdpdmVuIHNpemUuXHJcbiAgICogQHBhcmFtIHdpZHRoXHJcbiAgICogQHBhcmFtIGhlaWdodFxyXG4gICAqIEBwYXJhbSBwcmVzZXJ2ZUFzcGVjdFJhdGlvXHJcbiAgICovXG5cblxuICByZXNpemUod2lkdGgpIHtcbiAgICB2YXIgaGVpZ2h0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB3aWR0aDtcbiAgICB2YXIgcHJlc2VydmVBc3BlY3RSYXRpbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgdmFyIHdpZHRoQXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcsIHRydWUpO1xuICAgIHZhciBoZWlnaHRBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRydWUpO1xuICAgIHZhciB2aWV3Qm94QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd2aWV3Qm94Jyk7XG4gICAgdmFyIHN0eWxlQXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xuICAgIHZhciBvcmlnaW5XaWR0aCA9IHdpZHRoQXR0ci5nZXROdW1iZXIoMCk7XG4gICAgdmFyIG9yaWdpbkhlaWdodCA9IGhlaWdodEF0dHIuZ2V0TnVtYmVyKDApO1xuXG4gICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW8pIHtcbiAgICAgIGlmICh0eXBlb2YgcHJlc2VydmVBc3BlY3RSYXRpbyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCB0cnVlKS5zZXRWYWx1ZShwcmVzZXJ2ZUFzcGVjdFJhdGlvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJyk7XG5cbiAgICAgICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW9BdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0ci5zZXRWYWx1ZShwcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0ci5nZXRTdHJpbmcoKS5yZXBsYWNlKC9eXFxzKihcXFMuKlxcUylcXHMqJC8sICckMScpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHdpZHRoQXR0ci5zZXRWYWx1ZSh3aWR0aCk7XG4gICAgaGVpZ2h0QXR0ci5zZXRWYWx1ZShoZWlnaHQpO1xuXG4gICAgaWYgKCF2aWV3Qm94QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICB2aWV3Qm94QXR0ci5zZXRWYWx1ZShcIjAgMCBcIi5jb25jYXQob3JpZ2luV2lkdGggfHwgd2lkdGgsIFwiIFwiKS5jb25jYXQob3JpZ2luSGVpZ2h0IHx8IGhlaWdodCkpO1xuICAgIH1cblxuICAgIGlmIChzdHlsZUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgdmFyIHdpZHRoU3R5bGUgPSB0aGlzLmdldFN0eWxlKCd3aWR0aCcpO1xuICAgICAgdmFyIGhlaWdodFN0eWxlID0gdGhpcy5nZXRTdHlsZSgnaGVpZ2h0Jyk7XG5cbiAgICAgIGlmICh3aWR0aFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgd2lkdGhTdHlsZS5zZXRWYWx1ZShcIlwiLmNvbmNhdCh3aWR0aCwgXCJweFwiKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoZWlnaHRTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGhlaWdodFN0eWxlLnNldFZhbHVlKFwiXCIuY29uY2F0KGhlaWdodCwgXCJweFwiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cblxuY2xhc3MgUmVjdEVsZW1lbnQgZXh0ZW5kcyBQYXRoRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ3JlY3QnO1xuICB9XG5cbiAgcGF0aChjdHgpIHtcbiAgICB2YXIgeCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd4JykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIHkgPSB0aGlzLmdldEF0dHJpYnV0ZSgneScpLmdldFBpeGVscygneScpO1xuICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJywgZmFsc2UsIHRydWUpLmdldFBpeGVscygneCcpO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldFN0eWxlKCdoZWlnaHQnLCBmYWxzZSwgdHJ1ZSkuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgdmFyIHJ4QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyeCcpO1xuICAgIHZhciByeUF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgncnknKTtcbiAgICB2YXIgcnggPSByeEF0dHIuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIHJ5ID0gcnlBdHRyLmdldFBpeGVscygneScpO1xuXG4gICAgaWYgKHJ4QXR0ci5oYXNWYWx1ZSgpICYmICFyeUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgcnkgPSByeDtcbiAgICB9XG5cbiAgICBpZiAocnlBdHRyLmhhc1ZhbHVlKCkgJiYgIXJ4QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICByeCA9IHJ5O1xuICAgIH1cblxuICAgIHJ4ID0gTWF0aC5taW4ocngsIHdpZHRoIC8gMi4wKTtcbiAgICByeSA9IE1hdGgubWluKHJ5LCBoZWlnaHQgLyAyLjApO1xuXG4gICAgaWYgKGN0eCkge1xuICAgICAgdmFyIEtBUFBBID0gNCAqICgoTWF0aC5zcXJ0KDIpIC0gMSkgLyAzKTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTsgLy8gYWx3YXlzIHN0YXJ0IHRoZSBwYXRoIHNvIHdlIGRvbid0IGZpbGwgcHJpb3IgcGF0aHNcblxuICAgICAgaWYgKGhlaWdodCA+IDAgJiYgd2lkdGggPiAwKSB7XG4gICAgICAgIGN0eC5tb3ZlVG8oeCArIHJ4LCB5KTtcbiAgICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSByeCwgeSk7XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHggKyB3aWR0aCAtIHJ4ICsgS0FQUEEgKiByeCwgeSwgeCArIHdpZHRoLCB5ICsgcnkgLSBLQVBQQSAqIHJ5LCB4ICsgd2lkdGgsIHkgKyByeSk7XG4gICAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcnkpO1xuICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByeSArIEtBUFBBICogcnksIHggKyB3aWR0aCAtIHJ4ICsgS0FQUEEgKiByeCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcngsIHkgKyBoZWlnaHQpO1xuICAgICAgICBjdHgubGluZVRvKHggKyByeCwgeSArIGhlaWdodCk7XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHggKyByeCAtIEtBUFBBICogcngsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByeSArIEtBUFBBICogcnksIHgsIHkgKyBoZWlnaHQgLSByeSk7XG4gICAgICAgIGN0eC5saW5lVG8oeCwgeSArIHJ5KTtcbiAgICAgICAgY3R4LmJlemllckN1cnZlVG8oeCwgeSArIHJ5IC0gS0FQUEEgKiByeSwgeCArIHJ4IC0gS0FQUEEgKiByeCwgeSwgeCArIHJ4LCB5KTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3goeCwgeSwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgfVxuXG4gIGdldE1hcmtlcnMoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxufVxuXG5jbGFzcyBDaXJjbGVFbGVtZW50IGV4dGVuZHMgUGF0aEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdjaXJjbGUnO1xuICB9XG5cbiAgcGF0aChjdHgpIHtcbiAgICB2YXIgY3ggPSB0aGlzLmdldEF0dHJpYnV0ZSgnY3gnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgY3kgPSB0aGlzLmdldEF0dHJpYnV0ZSgnY3knKS5nZXRQaXhlbHMoJ3knKTtcbiAgICB2YXIgciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyJykuZ2V0UGl4ZWxzKCk7XG5cbiAgICBpZiAoY3R4ICYmIHIgPiAwKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguYXJjKGN4LCBjeSwgciwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KGN4IC0gciwgY3kgLSByLCBjeCArIHIsIGN5ICsgcik7XG4gIH1cblxuICBnZXRNYXJrZXJzKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbn1cblxuY2xhc3MgRWxsaXBzZUVsZW1lbnQgZXh0ZW5kcyBQYXRoRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ2VsbGlwc2UnO1xuICB9XG5cbiAgcGF0aChjdHgpIHtcbiAgICB2YXIgS0FQUEEgPSA0ICogKChNYXRoLnNxcnQoMikgLSAxKSAvIDMpO1xuICAgIHZhciByeCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyeCcpLmdldFBpeGVscygneCcpO1xuICAgIHZhciByeSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyeScpLmdldFBpeGVscygneScpO1xuICAgIHZhciBjeCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdjeCcpLmdldFBpeGVscygneCcpO1xuICAgIHZhciBjeSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdjeScpLmdldFBpeGVscygneScpO1xuXG4gICAgaWYgKGN0eCAmJiByeCA+IDAgJiYgcnkgPiAwKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKGN4ICsgcngsIGN5KTtcbiAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGN4ICsgcngsIGN5ICsgS0FQUEEgKiByeSwgY3ggKyBLQVBQQSAqIHJ4LCBjeSArIHJ5LCBjeCwgY3kgKyByeSk7XG4gICAgICBjdHguYmV6aWVyQ3VydmVUbyhjeCAtIEtBUFBBICogcngsIGN5ICsgcnksIGN4IC0gcngsIGN5ICsgS0FQUEEgKiByeSwgY3ggLSByeCwgY3kpO1xuICAgICAgY3R4LmJlemllckN1cnZlVG8oY3ggLSByeCwgY3kgLSBLQVBQQSAqIHJ5LCBjeCAtIEtBUFBBICogcngsIGN5IC0gcnksIGN4LCBjeSAtIHJ5KTtcbiAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGN4ICsgS0FQUEEgKiByeCwgY3kgLSByeSwgY3ggKyByeCwgY3kgLSBLQVBQQSAqIHJ5LCBjeCArIHJ4LCBjeSk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveChjeCAtIHJ4LCBjeSAtIHJ5LCBjeCArIHJ4LCBjeSArIHJ5KTtcbiAgfVxuXG4gIGdldE1hcmtlcnMoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxufVxuXG5jbGFzcyBMaW5lRWxlbWVudCBleHRlbmRzIFBhdGhFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAnbGluZSc7XG4gIH1cblxuICBnZXRQb2ludHMoKSB7XG4gICAgcmV0dXJuIFtuZXcgUG9pbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3gxJykuZ2V0UGl4ZWxzKCd4JyksIHRoaXMuZ2V0QXR0cmlidXRlKCd5MScpLmdldFBpeGVscygneScpKSwgbmV3IFBvaW50KHRoaXMuZ2V0QXR0cmlidXRlKCd4MicpLmdldFBpeGVscygneCcpLCB0aGlzLmdldEF0dHJpYnV0ZSgneTInKS5nZXRQaXhlbHMoJ3knKSldO1xuICB9XG5cbiAgcGF0aChjdHgpIHtcbiAgICB2YXIgW3tcbiAgICAgIHg6IHgwLFxuICAgICAgeTogeTBcbiAgICB9LCB7XG4gICAgICB4OiB4MSxcbiAgICAgIHk6IHkxXG4gICAgfV0gPSB0aGlzLmdldFBvaW50cygpO1xuXG4gICAgaWYgKGN0eCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyh4MCwgeTApO1xuICAgICAgY3R4LmxpbmVUbyh4MSwgeTEpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3goeDAsIHkwLCB4MSwgeTEpO1xuICB9XG5cbiAgZ2V0TWFya2VycygpIHtcbiAgICB2YXIgW3AwLCBwMV0gPSB0aGlzLmdldFBvaW50cygpO1xuICAgIHZhciBhID0gcDAuYW5nbGVUbyhwMSk7XG4gICAgcmV0dXJuIFtbcDAsIGFdLCBbcDEsIGFdXTtcbiAgfVxuXG59XG5cbmNsYXNzIFBvbHlsaW5lRWxlbWVudCBleHRlbmRzIFBhdGhFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy50eXBlID0gJ3BvbHlsaW5lJztcbiAgICB0aGlzLnBvaW50cyA9IFtdO1xuICAgIHRoaXMucG9pbnRzID0gUG9pbnQucGFyc2VQYXRoKHRoaXMuZ2V0QXR0cmlidXRlKCdwb2ludHMnKS5nZXRTdHJpbmcoKSk7XG4gIH1cblxuICBwYXRoKGN0eCkge1xuICAgIHZhciB7XG4gICAgICBwb2ludHNcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgW3tcbiAgICAgIHg6IHgwLFxuICAgICAgeTogeTBcbiAgICB9XSA9IHBvaW50cztcbiAgICB2YXIgYm91bmRpbmdCb3ggPSBuZXcgQm91bmRpbmdCb3goeDAsIHkwKTtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oeDAsIHkwKTtcbiAgICB9XG5cbiAgICBwb2ludHMuZm9yRWFjaChfcmVmID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgYm91bmRpbmdCb3guYWRkUG9pbnQoeCwgeSk7XG5cbiAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYm91bmRpbmdCb3g7XG4gIH1cblxuICBnZXRNYXJrZXJzKCkge1xuICAgIHZhciB7XG4gICAgICBwb2ludHNcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgbGFzdEluZGV4ID0gcG9pbnRzLmxlbmd0aCAtIDE7XG4gICAgdmFyIG1hcmtlcnMgPSBbXTtcbiAgICBwb2ludHMuZm9yRWFjaCgocG9pbnQsIGkpID0+IHtcbiAgICAgIGlmIChpID09PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBtYXJrZXJzLnB1c2goW3BvaW50LCBwb2ludC5hbmdsZVRvKHBvaW50c1tpICsgMV0pXSk7XG4gICAgfSk7XG5cbiAgICBpZiAobWFya2Vycy5sZW5ndGggPiAwKSB7XG4gICAgICBtYXJrZXJzLnB1c2goW3BvaW50c1twb2ludHMubGVuZ3RoIC0gMV0sIG1hcmtlcnNbbWFya2Vycy5sZW5ndGggLSAxXVsxXV0pO1xuICAgIH1cblxuICAgIHJldHVybiBtYXJrZXJzO1xuICB9XG5cbn1cblxuY2xhc3MgUG9seWdvbkVsZW1lbnQgZXh0ZW5kcyBQb2x5bGluZUVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdwb2x5Z29uJztcbiAgfVxuXG4gIHBhdGgoY3R4KSB7XG4gICAgdmFyIGJvdW5kaW5nQm94ID0gc3VwZXIucGF0aChjdHgpO1xuICAgIHZhciBbe1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9XSA9IHRoaXMucG9pbnRzO1xuXG4gICAgaWYgKGN0eCkge1xuICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYm91bmRpbmdCb3g7XG4gIH1cblxufVxuXG5jbGFzcyBQYXR0ZXJuRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdwYXR0ZXJuJztcbiAgfVxuXG4gIGNyZWF0ZVBhdHRlcm4oY3R4LCBfLCBwYXJlbnRPcGFjaXR5UHJvcCkge1xuICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJykuZ2V0UGl4ZWxzKCd4JywgdHJ1ZSk7XG4gICAgdmFyIGhlaWdodCA9IHRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcpLmdldFBpeGVscygneScsIHRydWUpOyAvLyByZW5kZXIgbWUgdXNpbmcgYSB0ZW1wb3Jhcnkgc3ZnIGVsZW1lbnRcblxuICAgIHZhciBwYXR0ZXJuU3ZnID0gbmV3IFNWR0VsZW1lbnQodGhpcy5kb2N1bWVudCwgbnVsbCk7XG4gICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLnZpZXdCb3ggPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3ZpZXdCb3gnLCB0aGlzLmdldEF0dHJpYnV0ZSgndmlld0JveCcpLmdldFZhbHVlKCkpO1xuICAgIHBhdHRlcm5TdmcuYXR0cmlidXRlcy53aWR0aCA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnd2lkdGgnLCBcIlwiLmNvbmNhdCh3aWR0aCwgXCJweFwiKSk7XG4gICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLmhlaWdodCA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnaGVpZ2h0JywgXCJcIi5jb25jYXQoaGVpZ2h0LCBcInB4XCIpKTtcbiAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMudHJhbnNmb3JtID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICd0cmFuc2Zvcm0nLCB0aGlzLmdldEF0dHJpYnV0ZSgncGF0dGVyblRyYW5zZm9ybScpLmdldFZhbHVlKCkpO1xuICAgIHBhdHRlcm5TdmcuY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIHZhciBwYXR0ZXJuQ2FudmFzID0gdGhpcy5kb2N1bWVudC5jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgdmFyIHBhdHRlcm5DdHggPSBwYXR0ZXJuQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgdmFyIHhBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3gnKTtcbiAgICB2YXIgeUF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgneScpO1xuXG4gICAgaWYgKHhBdHRyLmhhc1ZhbHVlKCkgJiYgeUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgcGF0dGVybkN0eC50cmFuc2xhdGUoeEF0dHIuZ2V0UGl4ZWxzKCd4JywgdHJ1ZSksIHlBdHRyLmdldFBpeGVscygneScsIHRydWUpKTtcbiAgICB9XG5cbiAgICBpZiAocGFyZW50T3BhY2l0eVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgdGhpcy5zdHlsZXNbJ2ZpbGwtb3BhY2l0eSddID0gcGFyZW50T3BhY2l0eVByb3A7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGhpcy5zdHlsZXMsICdmaWxsLW9wYWNpdHknKTtcbiAgICB9IC8vIHJlbmRlciAzeDMgZ3JpZCBzbyB3aGVuIHdlIHRyYW5zZm9ybSB0aGVyZSdzIG5vIHdoaXRlIHNwYWNlIG9uIGVkZ2VzXG5cblxuICAgIGZvciAodmFyIHggPSAtMTsgeCA8PSAxOyB4KyspIHtcbiAgICAgIGZvciAodmFyIHkgPSAtMTsgeSA8PSAxOyB5KyspIHtcbiAgICAgICAgcGF0dGVybkN0eC5zYXZlKCk7XG4gICAgICAgIHBhdHRlcm5TdmcuYXR0cmlidXRlcy54ID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICd4JywgeCAqIHBhdHRlcm5DYW52YXMud2lkdGgpO1xuICAgICAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMueSA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAneScsIHkgKiBwYXR0ZXJuQ2FudmFzLmhlaWdodCk7XG4gICAgICAgIHBhdHRlcm5TdmcucmVuZGVyKHBhdHRlcm5DdHgpO1xuICAgICAgICBwYXR0ZXJuQ3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcGF0dGVybiA9IGN0eC5jcmVhdGVQYXR0ZXJuKHBhdHRlcm5DYW52YXMsICdyZXBlYXQnKTtcbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxuXG59XG5cbmNsYXNzIE1hcmtlckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAnbWFya2VyJztcbiAgfVxuXG4gIHJlbmRlcihjdHgsIHBvaW50LCBhbmdsZSkge1xuICAgIGlmICghcG9pbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gcG9pbnQ7XG4gICAgdmFyIG9yaWVudCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdvcmllbnQnKS5nZXRTdHJpbmcoJ2F1dG8nKTtcbiAgICB2YXIgbWFya2VyVW5pdHMgPSB0aGlzLmdldEF0dHJpYnV0ZSgnbWFya2VyVW5pdHMnKS5nZXRTdHJpbmcoJ3N0cm9rZVdpZHRoJyk7XG4gICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcblxuICAgIGlmIChvcmllbnQgPT09ICdhdXRvJykge1xuICAgICAgY3R4LnJvdGF0ZShhbmdsZSk7XG4gICAgfVxuXG4gICAgaWYgKG1hcmtlclVuaXRzID09PSAnc3Ryb2tlV2lkdGgnKSB7XG4gICAgICBjdHguc2NhbGUoY3R4LmxpbmVXaWR0aCwgY3R4LmxpbmVXaWR0aCk7XG4gICAgfVxuXG4gICAgY3R4LnNhdmUoKTsgLy8gcmVuZGVyIG1lIHVzaW5nIGEgdGVtcG9yYXJ5IHN2ZyBlbGVtZW50XG5cbiAgICB2YXIgbWFya2VyU3ZnID0gbmV3IFNWR0VsZW1lbnQodGhpcy5kb2N1bWVudCwgbnVsbCk7XG4gICAgbWFya2VyU3ZnLnR5cGUgPSB0aGlzLnR5cGU7XG4gICAgbWFya2VyU3ZnLmF0dHJpYnV0ZXMudmlld0JveCA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAndmlld0JveCcsIHRoaXMuZ2V0QXR0cmlidXRlKCd2aWV3Qm94JykuZ2V0VmFsdWUoKSk7XG4gICAgbWFya2VyU3ZnLmF0dHJpYnV0ZXMucmVmWCA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAncmVmWCcsIHRoaXMuZ2V0QXR0cmlidXRlKCdyZWZYJykuZ2V0VmFsdWUoKSk7XG4gICAgbWFya2VyU3ZnLmF0dHJpYnV0ZXMucmVmWSA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAncmVmWScsIHRoaXMuZ2V0QXR0cmlidXRlKCdyZWZZJykuZ2V0VmFsdWUoKSk7XG4gICAgbWFya2VyU3ZnLmF0dHJpYnV0ZXMud2lkdGggPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3dpZHRoJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ21hcmtlcldpZHRoJykuZ2V0VmFsdWUoKSk7XG4gICAgbWFya2VyU3ZnLmF0dHJpYnV0ZXMuaGVpZ2h0ID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdoZWlnaHQnLCB0aGlzLmdldEF0dHJpYnV0ZSgnbWFya2VySGVpZ2h0JykuZ2V0VmFsdWUoKSk7XG4gICAgbWFya2VyU3ZnLmF0dHJpYnV0ZXMub3ZlcmZsb3cgPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ292ZXJmbG93JywgdGhpcy5nZXRBdHRyaWJ1dGUoJ292ZXJmbG93JykuZ2V0VmFsdWUoKSk7XG4gICAgbWFya2VyU3ZnLmF0dHJpYnV0ZXMuZmlsbCA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnZmlsbCcsIHRoaXMuZ2V0QXR0cmlidXRlKCdmaWxsJykuZ2V0Q29sb3IoJ2JsYWNrJykpO1xuICAgIG1hcmtlclN2Zy5hdHRyaWJ1dGVzLnN0cm9rZSA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnc3Ryb2tlJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ3N0cm9rZScpLmdldFZhbHVlKCdub25lJykpO1xuICAgIG1hcmtlclN2Zy5jaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgbWFya2VyU3ZnLnJlbmRlcihjdHgpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICBpZiAobWFya2VyVW5pdHMgPT09ICdzdHJva2VXaWR0aCcpIHtcbiAgICAgIGN0eC5zY2FsZSgxIC8gY3R4LmxpbmVXaWR0aCwgMSAvIGN0eC5saW5lV2lkdGgpO1xuICAgIH1cblxuICAgIGlmIChvcmllbnQgPT09ICdhdXRvJykge1xuICAgICAgY3R4LnJvdGF0ZSgtYW5nbGUpO1xuICAgIH1cblxuICAgIGN0eC50cmFuc2xhdGUoLXgsIC15KTtcbiAgfVxuXG59XG5cbmNsYXNzIERlZnNFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ2RlZnMnO1xuICB9XG5cbiAgcmVuZGVyKCkgey8vIE5PT1BcbiAgfVxuXG59XG5cbmNsYXNzIEdFbGVtZW50IGV4dGVuZHMgUmVuZGVyZWRFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAnZyc7XG4gIH1cblxuICBnZXRCb3VuZGluZ0JveChjdHgpIHtcbiAgICB2YXIgYm91bmRpbmdCb3ggPSBuZXcgQm91bmRpbmdCb3goKTtcbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgYm91bmRpbmdCb3guYWRkQm91bmRpbmdCb3goY2hpbGQuZ2V0Qm91bmRpbmdCb3goY3R4KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGJvdW5kaW5nQm94O1xuICB9XG5cbn1cblxuY2xhc3MgR3JhZGllbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIHRoaXMuYXR0cmlidXRlc1RvSW5oZXJpdCA9IFsnZ3JhZGllbnRVbml0cyddO1xuICAgIHRoaXMuc3RvcHMgPSBbXTtcbiAgICB2YXIge1xuICAgICAgc3RvcHMsXG4gICAgICBjaGlsZHJlblxuICAgIH0gPSB0aGlzO1xuICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICdzdG9wJykge1xuICAgICAgICBzdG9wcy5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGdldEdyYWRpZW50VW5pdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdncmFkaWVudFVuaXRzJykuZ2V0U3RyaW5nKCdvYmplY3RCb3VuZGluZ0JveCcpO1xuICB9XG5cbiAgY3JlYXRlR3JhZGllbnQoY3R4LCBlbGVtZW50LCBwYXJlbnRPcGFjaXR5UHJvcCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhcywgY29uc2lzdGVudC10aGlzXG4gICAgdmFyIHN0b3BzQ29udGFpbmVyID0gdGhpcztcblxuICAgIGlmICh0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5oYXNWYWx1ZSgpKSB7XG4gICAgICBzdG9wc0NvbnRhaW5lciA9IHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmdldERlZmluaXRpb24oKTtcbiAgICAgIHRoaXMuaW5oZXJpdFN0b3BDb250YWluZXIoc3RvcHNDb250YWluZXIpO1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBzdG9wc1xuICAgIH0gPSBzdG9wc0NvbnRhaW5lcjtcbiAgICB2YXIgZ3JhZGllbnQgPSB0aGlzLmdldEdyYWRpZW50KGN0eCwgZWxlbWVudCk7XG5cbiAgICBpZiAoIWdyYWRpZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGRQYXJlbnRPcGFjaXR5KHBhcmVudE9wYWNpdHlQcm9wLCBzdG9wc1tzdG9wcy5sZW5ndGggLSAxXS5jb2xvcik7XG4gICAgfVxuXG4gICAgc3RvcHMuZm9yRWFjaChzdG9wID0+IHtcbiAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcChzdG9wLm9mZnNldCwgdGhpcy5hZGRQYXJlbnRPcGFjaXR5KHBhcmVudE9wYWNpdHlQcm9wLCBzdG9wLmNvbG9yKSk7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoJ2dyYWRpZW50VHJhbnNmb3JtJykuaGFzVmFsdWUoKSkge1xuICAgICAgLy8gcmVuZGVyIGFzIHRyYW5zZm9ybWVkIHBhdHRlcm4gb24gdGVtcG9yYXJ5IGNhbnZhc1xuICAgICAgdmFyIHtcbiAgICAgICAgZG9jdW1lbnRcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgdmFyIHtcbiAgICAgICAgTUFYX1ZJUlRVQUxfUElYRUxTLFxuICAgICAgICB2aWV3UG9ydFxuICAgICAgfSA9IGRvY3VtZW50LnNjcmVlbjtcbiAgICAgIHZhciBbcm9vdFZpZXddID0gdmlld1BvcnQudmlld1BvcnRzO1xuICAgICAgdmFyIHJlY3QgPSBuZXcgUmVjdEVsZW1lbnQoZG9jdW1lbnQsIG51bGwpO1xuICAgICAgcmVjdC5hdHRyaWJ1dGVzLnggPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd4JywgLU1BWF9WSVJUVUFMX1BJWEVMUyAvIDMuMCk7XG4gICAgICByZWN0LmF0dHJpYnV0ZXMueSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3knLCAtTUFYX1ZJUlRVQUxfUElYRUxTIC8gMy4wKTtcbiAgICAgIHJlY3QuYXR0cmlidXRlcy53aWR0aCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3dpZHRoJywgTUFYX1ZJUlRVQUxfUElYRUxTKTtcbiAgICAgIHJlY3QuYXR0cmlidXRlcy5oZWlnaHQgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdoZWlnaHQnLCBNQVhfVklSVFVBTF9QSVhFTFMpO1xuICAgICAgdmFyIGdyb3VwID0gbmV3IEdFbGVtZW50KGRvY3VtZW50LCBudWxsKTtcbiAgICAgIGdyb3VwLmF0dHJpYnV0ZXMudHJhbnNmb3JtID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAndHJhbnNmb3JtJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ2dyYWRpZW50VHJhbnNmb3JtJykuZ2V0VmFsdWUoKSk7XG4gICAgICBncm91cC5jaGlsZHJlbiA9IFtyZWN0XTtcbiAgICAgIHZhciBwYXR0ZXJuU3ZnID0gbmV3IFNWR0VsZW1lbnQoZG9jdW1lbnQsIG51bGwpO1xuICAgICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLnggPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd4JywgMCk7XG4gICAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMueSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3knLCAwKTtcbiAgICAgIHBhdHRlcm5TdmcuYXR0cmlidXRlcy53aWR0aCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3dpZHRoJywgcm9vdFZpZXcud2lkdGgpO1xuICAgICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLmhlaWdodCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ2hlaWdodCcsIHJvb3RWaWV3LmhlaWdodCk7XG4gICAgICBwYXR0ZXJuU3ZnLmNoaWxkcmVuID0gW2dyb3VwXTtcbiAgICAgIHZhciBwYXR0ZXJuQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlQ2FudmFzKHJvb3RWaWV3LndpZHRoLCByb290Vmlldy5oZWlnaHQpO1xuICAgICAgdmFyIHBhdHRlcm5DdHggPSBwYXR0ZXJuQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBwYXR0ZXJuQ3R4LmZpbGxTdHlsZSA9IGdyYWRpZW50O1xuICAgICAgcGF0dGVyblN2Zy5yZW5kZXIocGF0dGVybkN0eCk7XG4gICAgICByZXR1cm4gcGF0dGVybkN0eC5jcmVhdGVQYXR0ZXJuKHBhdHRlcm5DYW52YXMsICduby1yZXBlYXQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ3JhZGllbnQ7XG4gIH1cblxuICBpbmhlcml0U3RvcENvbnRhaW5lcihzdG9wc0NvbnRhaW5lcikge1xuICAgIHRoaXMuYXR0cmlidXRlc1RvSW5oZXJpdC5mb3JFYWNoKGF0dHJpYnV0ZVRvSW5oZXJpdCA9PiB7XG4gICAgICBpZiAoIXRoaXMuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZVRvSW5oZXJpdCkuaGFzVmFsdWUoKSAmJiBzdG9wc0NvbnRhaW5lci5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlVG9Jbmhlcml0KS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZVRvSW5oZXJpdCwgdHJ1ZSkuc2V0VmFsdWUoc3RvcHNDb250YWluZXIuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZVRvSW5oZXJpdCkuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBhZGRQYXJlbnRPcGFjaXR5KHBhcmVudE9wYWNpdHlQcm9wLCBjb2xvcikge1xuICAgIGlmIChwYXJlbnRPcGFjaXR5UHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICB2YXIgY29sb3JQcm9wID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdjb2xvcicsIGNvbG9yKTtcbiAgICAgIHJldHVybiBjb2xvclByb3AuYWRkT3BhY2l0eShwYXJlbnRPcGFjaXR5UHJvcCkuZ2V0Q29sb3IoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29sb3I7XG4gIH1cblxufVxuXG5jbGFzcyBMaW5lYXJHcmFkaWVudEVsZW1lbnQgZXh0ZW5kcyBHcmFkaWVudEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLnR5cGUgPSAnbGluZWFyR3JhZGllbnQnO1xuICAgIHRoaXMuYXR0cmlidXRlc1RvSW5oZXJpdC5wdXNoKCd4MScsICd5MScsICd4MicsICd5MicpO1xuICB9XG5cbiAgZ2V0R3JhZGllbnQoY3R4LCBlbGVtZW50KSB7XG4gICAgdmFyIGlzQm91bmRpbmdCb3hVbml0cyA9IHRoaXMuZ2V0R3JhZGllbnRVbml0cygpID09PSAnb2JqZWN0Qm91bmRpbmdCb3gnO1xuICAgIHZhciBib3VuZGluZ0JveCA9IGlzQm91bmRpbmdCb3hVbml0cyA/IGVsZW1lbnQuZ2V0Qm91bmRpbmdCb3goY3R4KSA6IG51bGw7XG5cbiAgICBpZiAoaXNCb3VuZGluZ0JveFVuaXRzICYmICFib3VuZGluZ0JveCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmdldEF0dHJpYnV0ZSgneDEnKS5oYXNWYWx1ZSgpICYmICF0aGlzLmdldEF0dHJpYnV0ZSgneTEnKS5oYXNWYWx1ZSgpICYmICF0aGlzLmdldEF0dHJpYnV0ZSgneDInKS5oYXNWYWx1ZSgpICYmICF0aGlzLmdldEF0dHJpYnV0ZSgneTInKS5oYXNWYWx1ZSgpKSB7XG4gICAgICB0aGlzLmdldEF0dHJpYnV0ZSgneDEnLCB0cnVlKS5zZXRWYWx1ZSgwKTtcbiAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCd5MScsIHRydWUpLnNldFZhbHVlKDApO1xuICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ3gyJywgdHJ1ZSkuc2V0VmFsdWUoMSk7XG4gICAgICB0aGlzLmdldEF0dHJpYnV0ZSgneTInLCB0cnVlKS5zZXRWYWx1ZSgwKTtcbiAgICB9XG5cbiAgICB2YXIgeDEgPSBpc0JvdW5kaW5nQm94VW5pdHMgPyBib3VuZGluZ0JveC54ICsgYm91bmRpbmdCb3gud2lkdGggKiB0aGlzLmdldEF0dHJpYnV0ZSgneDEnKS5nZXROdW1iZXIoKSA6IHRoaXMuZ2V0QXR0cmlidXRlKCd4MScpLmdldFBpeGVscygneCcpO1xuICAgIHZhciB5MSA9IGlzQm91bmRpbmdCb3hVbml0cyA/IGJvdW5kaW5nQm94LnkgKyBib3VuZGluZ0JveC5oZWlnaHQgKiB0aGlzLmdldEF0dHJpYnV0ZSgneTEnKS5nZXROdW1iZXIoKSA6IHRoaXMuZ2V0QXR0cmlidXRlKCd5MScpLmdldFBpeGVscygneScpO1xuICAgIHZhciB4MiA9IGlzQm91bmRpbmdCb3hVbml0cyA/IGJvdW5kaW5nQm94LnggKyBib3VuZGluZ0JveC53aWR0aCAqIHRoaXMuZ2V0QXR0cmlidXRlKCd4MicpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ3gyJykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIHkyID0gaXNCb3VuZGluZ0JveFVuaXRzID8gYm91bmRpbmdCb3gueSArIGJvdW5kaW5nQm94LmhlaWdodCAqIHRoaXMuZ2V0QXR0cmlidXRlKCd5MicpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ3kyJykuZ2V0UGl4ZWxzKCd5Jyk7XG5cbiAgICBpZiAoeDEgPT09IHgyICYmIHkxID09PSB5Mikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh4MSwgeTEsIHgyLCB5Mik7XG4gIH1cblxufVxuXG5jbGFzcyBSYWRpYWxHcmFkaWVudEVsZW1lbnQgZXh0ZW5kcyBHcmFkaWVudEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLnR5cGUgPSAncmFkaWFsR3JhZGllbnQnO1xuICAgIHRoaXMuYXR0cmlidXRlc1RvSW5oZXJpdC5wdXNoKCdjeCcsICdjeScsICdyJywgJ2Z4JywgJ2Z5JywgJ2ZyJyk7XG4gIH1cblxuICBnZXRHcmFkaWVudChjdHgsIGVsZW1lbnQpIHtcbiAgICB2YXIgaXNCb3VuZGluZ0JveFVuaXRzID0gdGhpcy5nZXRHcmFkaWVudFVuaXRzKCkgPT09ICdvYmplY3RCb3VuZGluZ0JveCc7XG4gICAgdmFyIGJvdW5kaW5nQm94ID0gZWxlbWVudC5nZXRCb3VuZGluZ0JveChjdHgpO1xuXG4gICAgaWYgKGlzQm91bmRpbmdCb3hVbml0cyAmJiAhYm91bmRpbmdCb3gpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5nZXRBdHRyaWJ1dGUoJ2N4JykuaGFzVmFsdWUoKSkge1xuICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ2N4JywgdHJ1ZSkuc2V0VmFsdWUoJzUwJScpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5nZXRBdHRyaWJ1dGUoJ2N5JykuaGFzVmFsdWUoKSkge1xuICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ2N5JywgdHJ1ZSkuc2V0VmFsdWUoJzUwJScpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5nZXRBdHRyaWJ1dGUoJ3InKS5oYXNWYWx1ZSgpKSB7XG4gICAgICB0aGlzLmdldEF0dHJpYnV0ZSgncicsIHRydWUpLnNldFZhbHVlKCc1MCUnKTtcbiAgICB9XG5cbiAgICB2YXIgY3ggPSBpc0JvdW5kaW5nQm94VW5pdHMgPyBib3VuZGluZ0JveC54ICsgYm91bmRpbmdCb3gud2lkdGggKiB0aGlzLmdldEF0dHJpYnV0ZSgnY3gnKS5nZXROdW1iZXIoKSA6IHRoaXMuZ2V0QXR0cmlidXRlKCdjeCcpLmdldFBpeGVscygneCcpO1xuICAgIHZhciBjeSA9IGlzQm91bmRpbmdCb3hVbml0cyA/IGJvdW5kaW5nQm94LnkgKyBib3VuZGluZ0JveC5oZWlnaHQgKiB0aGlzLmdldEF0dHJpYnV0ZSgnY3knKS5nZXROdW1iZXIoKSA6IHRoaXMuZ2V0QXR0cmlidXRlKCdjeScpLmdldFBpeGVscygneScpO1xuICAgIHZhciBmeCA9IGN4O1xuICAgIHZhciBmeSA9IGN5O1xuXG4gICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCdmeCcpLmhhc1ZhbHVlKCkpIHtcbiAgICAgIGZ4ID0gaXNCb3VuZGluZ0JveFVuaXRzID8gYm91bmRpbmdCb3gueCArIGJvdW5kaW5nQm94LndpZHRoICogdGhpcy5nZXRBdHRyaWJ1dGUoJ2Z4JykuZ2V0TnVtYmVyKCkgOiB0aGlzLmdldEF0dHJpYnV0ZSgnZngnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoJ2Z5JykuaGFzVmFsdWUoKSkge1xuICAgICAgZnkgPSBpc0JvdW5kaW5nQm94VW5pdHMgPyBib3VuZGluZ0JveC55ICsgYm91bmRpbmdCb3guaGVpZ2h0ICogdGhpcy5nZXRBdHRyaWJ1dGUoJ2Z5JykuZ2V0TnVtYmVyKCkgOiB0aGlzLmdldEF0dHJpYnV0ZSgnZnknKS5nZXRQaXhlbHMoJ3knKTtcbiAgICB9XG5cbiAgICB2YXIgciA9IGlzQm91bmRpbmdCb3hVbml0cyA/IChib3VuZGluZ0JveC53aWR0aCArIGJvdW5kaW5nQm94LmhlaWdodCkgLyAyLjAgKiB0aGlzLmdldEF0dHJpYnV0ZSgncicpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ3InKS5nZXRQaXhlbHMoKTtcbiAgICB2YXIgZnIgPSB0aGlzLmdldEF0dHJpYnV0ZSgnZnInKS5nZXRQaXhlbHMoKTtcbiAgICByZXR1cm4gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KGZ4LCBmeSwgZnIsIGN4LCBjeSwgcik7XG4gIH1cblxufVxuXG5jbGFzcyBTdG9wRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLnR5cGUgPSAnc3RvcCc7XG4gICAgdmFyIG9mZnNldCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHRoaXMuZ2V0QXR0cmlidXRlKCdvZmZzZXQnKS5nZXROdW1iZXIoKSkpO1xuICAgIHZhciBzdG9wT3BhY2l0eSA9IHRoaXMuZ2V0U3R5bGUoJ3N0b3Atb3BhY2l0eScpO1xuICAgIHZhciBzdG9wQ29sb3IgPSB0aGlzLmdldFN0eWxlKCdzdG9wLWNvbG9yJywgdHJ1ZSk7XG5cbiAgICBpZiAoc3RvcENvbG9yLmdldFN0cmluZygpID09PSAnJykge1xuICAgICAgc3RvcENvbG9yLnNldFZhbHVlKCcjMDAwJyk7XG4gICAgfVxuXG4gICAgaWYgKHN0b3BPcGFjaXR5Lmhhc1ZhbHVlKCkpIHtcbiAgICAgIHN0b3BDb2xvciA9IHN0b3BDb2xvci5hZGRPcGFjaXR5KHN0b3BPcGFjaXR5KTtcbiAgICB9XG5cbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB0aGlzLmNvbG9yID0gc3RvcENvbG9yLmdldENvbG9yKCk7XG4gIH1cblxufVxuXG5jbGFzcyBBbmltYXRlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLnR5cGUgPSAnYW5pbWF0ZSc7XG4gICAgdGhpcy5kdXJhdGlvbiA9IDA7XG4gICAgdGhpcy5pbml0aWFsVmFsdWUgPSBudWxsO1xuICAgIHRoaXMuaW5pdGlhbFVuaXRzID0gJyc7XG4gICAgdGhpcy5yZW1vdmVkID0gZmFsc2U7XG4gICAgdGhpcy5mcm96ZW4gPSBmYWxzZTtcbiAgICBkb2N1bWVudC5zY3JlZW4uYW5pbWF0aW9ucy5wdXNoKHRoaXMpO1xuICAgIHRoaXMuYmVnaW4gPSB0aGlzLmdldEF0dHJpYnV0ZSgnYmVnaW4nKS5nZXRNaWxsaXNlY29uZHMoKTtcbiAgICB0aGlzLm1heER1cmF0aW9uID0gdGhpcy5iZWdpbiArIHRoaXMuZ2V0QXR0cmlidXRlKCdkdXInKS5nZXRNaWxsaXNlY29uZHMoKTtcbiAgICB0aGlzLmZyb20gPSB0aGlzLmdldEF0dHJpYnV0ZSgnZnJvbScpO1xuICAgIHRoaXMudG8gPSB0aGlzLmdldEF0dHJpYnV0ZSgndG8nKTtcbiAgICB0aGlzLnZhbHVlcyA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3ZhbHVlcycsIG51bGwpO1xuICAgIHZhciB2YWx1ZXNBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlcycpO1xuXG4gICAgaWYgKHZhbHVlc0F0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgdGhpcy52YWx1ZXMuc2V0VmFsdWUodmFsdWVzQXR0ci5nZXRTdHJpbmcoKS5zcGxpdCgnOycpKTtcbiAgICB9XG4gIH1cblxuICBnZXRQcm9wZXJ0eSgpIHtcbiAgICB2YXIgYXR0cmlidXRlVHlwZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhdHRyaWJ1dGVUeXBlJykuZ2V0U3RyaW5nKCk7XG4gICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnYXR0cmlidXRlTmFtZScpLmdldFN0cmluZygpO1xuXG4gICAgaWYgKGF0dHJpYnV0ZVR5cGUgPT09ICdDU1MnKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0U3R5bGUoYXR0cmlidXRlTmFtZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGFyZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCB0cnVlKTtcbiAgfVxuXG4gIGNhbGNWYWx1ZSgpIHtcbiAgICB2YXIge1xuICAgICAgaW5pdGlhbFVuaXRzXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHtcbiAgICAgIHByb2dyZXNzLFxuICAgICAgZnJvbSxcbiAgICAgIHRvXG4gICAgfSA9IHRoaXMuZ2V0UHJvZ3Jlc3MoKTsgLy8gdHdlZW4gdmFsdWUgbGluZWFybHlcblxuICAgIHZhciBuZXdWYWx1ZSA9IGZyb20uZ2V0TnVtYmVyKCkgKyAodG8uZ2V0TnVtYmVyKCkgLSBmcm9tLmdldE51bWJlcigpKSAqIHByb2dyZXNzO1xuXG4gICAgaWYgKGluaXRpYWxVbml0cyA9PT0gJyUnKSB7XG4gICAgICBuZXdWYWx1ZSAqPSAxMDAuMDsgLy8gbnVtVmFsdWUoKSByZXR1cm5zIDAtMSB3aGVyZWFzIHByb3BlcnRpZXMgYXJlIDAtMTAwXG4gICAgfVxuXG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KG5ld1ZhbHVlKS5jb25jYXQoaW5pdGlhbFVuaXRzKTtcbiAgfVxuXG4gIHVwZGF0ZShkZWx0YSkge1xuICAgIHZhciB7XG4gICAgICBwYXJlbnRcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgcHJvcCA9IHRoaXMuZ2V0UHJvcGVydHkoKTsgLy8gc2V0IGluaXRpYWwgdmFsdWVcblxuICAgIGlmICghdGhpcy5pbml0aWFsVmFsdWUpIHtcbiAgICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gcHJvcC5nZXRTdHJpbmcoKTtcbiAgICAgIHRoaXMuaW5pdGlhbFVuaXRzID0gcHJvcC5nZXRVbml0cygpO1xuICAgIH0gLy8gaWYgd2UncmUgcGFzdCB0aGUgZW5kIHRpbWVcblxuXG4gICAgaWYgKHRoaXMuZHVyYXRpb24gPiB0aGlzLm1heER1cmF0aW9uKSB7XG4gICAgICB2YXIgZmlsbCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdmaWxsJykuZ2V0U3RyaW5nKCdyZW1vdmUnKTsgLy8gbG9vcCBmb3IgaW5kZWZpbml0ZWx5IHJlcGVhdGluZyBhbmltYXRpb25zXG5cbiAgICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgncmVwZWF0Q291bnQnKS5nZXRTdHJpbmcoKSA9PT0gJ2luZGVmaW5pdGUnIHx8IHRoaXMuZ2V0QXR0cmlidXRlKCdyZXBlYXREdXInKS5nZXRTdHJpbmcoKSA9PT0gJ2luZGVmaW5pdGUnKSB7XG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSAwO1xuICAgICAgfSBlbHNlIGlmIChmaWxsID09PSAnZnJlZXplJyAmJiAhdGhpcy5mcm96ZW4pIHtcbiAgICAgICAgdGhpcy5mcm96ZW4gPSB0cnVlO1xuICAgICAgICBwYXJlbnQuYW5pbWF0aW9uRnJvemVuID0gdHJ1ZTtcbiAgICAgICAgcGFyZW50LmFuaW1hdGlvbkZyb3plblZhbHVlID0gcHJvcC5nZXRTdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAoZmlsbCA9PT0gJ3JlbW92ZScgJiYgIXRoaXMucmVtb3ZlZCkge1xuICAgICAgICB0aGlzLnJlbW92ZWQgPSB0cnVlO1xuICAgICAgICBwcm9wLnNldFZhbHVlKHBhcmVudC5hbmltYXRpb25Gcm96ZW4gPyBwYXJlbnQuYW5pbWF0aW9uRnJvemVuVmFsdWUgOiB0aGlzLmluaXRpYWxWYWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5kdXJhdGlvbiArPSBkZWx0YTsgLy8gaWYgd2UncmUgcGFzdCB0aGUgYmVnaW4gdGltZVxuXG4gICAgdmFyIHVwZGF0ZWQgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLmJlZ2luIDwgdGhpcy5kdXJhdGlvbikge1xuICAgICAgdmFyIG5ld1ZhbHVlID0gdGhpcy5jYWxjVmFsdWUoKTsgLy8gdHdlZW5cblxuICAgICAgdmFyIHR5cGVBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcblxuICAgICAgaWYgKHR5cGVBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgLy8gZm9yIHRyYW5zZm9ybSwgZXRjLlxuICAgICAgICB2YXIgdHlwZSA9IHR5cGVBdHRyLmdldFN0cmluZygpO1xuICAgICAgICBuZXdWYWx1ZSA9IFwiXCIuY29uY2F0KHR5cGUsIFwiKFwiKS5jb25jYXQobmV3VmFsdWUsIFwiKVwiKTtcbiAgICAgIH1cblxuICAgICAgcHJvcC5zZXRWYWx1ZShuZXdWYWx1ZSk7XG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXBkYXRlZDtcbiAgfVxuXG4gIGdldFByb2dyZXNzKCkge1xuICAgIHZhciB7XG4gICAgICBkb2N1bWVudCxcbiAgICAgIHZhbHVlc1xuICAgIH0gPSB0aGlzO1xuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICBwcm9ncmVzczogKHRoaXMuZHVyYXRpb24gLSB0aGlzLmJlZ2luKSAvICh0aGlzLm1heER1cmF0aW9uIC0gdGhpcy5iZWdpbilcbiAgICB9O1xuXG4gICAgaWYgKHZhbHVlcy5oYXNWYWx1ZSgpKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wcm9ncmVzcyAqICh2YWx1ZXMuZ2V0VmFsdWUoKS5sZW5ndGggLSAxKTtcbiAgICAgIHZhciBsYiA9IE1hdGguZmxvb3IocCk7XG4gICAgICB2YXIgdWIgPSBNYXRoLmNlaWwocCk7XG4gICAgICByZXN1bHQuZnJvbSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ2Zyb20nLCBwYXJzZUZsb2F0KHZhbHVlcy5nZXRWYWx1ZSgpW2xiXSkpO1xuICAgICAgcmVzdWx0LnRvID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAndG8nLCBwYXJzZUZsb2F0KHZhbHVlcy5nZXRWYWx1ZSgpW3ViXSkpO1xuICAgICAgcmVzdWx0LnByb2dyZXNzID0gKHAgLSBsYikgLyAodWIgLSBsYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5mcm9tID0gdGhpcy5mcm9tO1xuICAgICAgcmVzdWx0LnRvID0gdGhpcy50bztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbn1cblxuY2xhc3MgQW5pbWF0ZUNvbG9yRWxlbWVudCBleHRlbmRzIEFuaW1hdGVFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAnYW5pbWF0ZUNvbG9yJztcbiAgfVxuXG4gIGNhbGNWYWx1ZSgpIHtcbiAgICB2YXIge1xuICAgICAgcHJvZ3Jlc3MsXG4gICAgICBmcm9tLFxuICAgICAgdG9cbiAgICB9ID0gdGhpcy5nZXRQcm9ncmVzcygpO1xuICAgIHZhciBjb2xvckZyb20gPSBuZXcgUkdCQ29sb3IoZnJvbS5nZXRDb2xvcigpKTtcbiAgICB2YXIgY29sb3JUbyA9IG5ldyBSR0JDb2xvcih0by5nZXRDb2xvcigpKTtcblxuICAgIGlmIChjb2xvckZyb20ub2sgJiYgY29sb3JUby5vaykge1xuICAgICAgLy8gdHdlZW4gY29sb3IgbGluZWFybHlcbiAgICAgIHZhciByID0gY29sb3JGcm9tLnIgKyAoY29sb3JUby5yIC0gY29sb3JGcm9tLnIpICogcHJvZ3Jlc3M7XG4gICAgICB2YXIgZyA9IGNvbG9yRnJvbS5nICsgKGNvbG9yVG8uZyAtIGNvbG9yRnJvbS5nKSAqIHByb2dyZXNzO1xuICAgICAgdmFyIGIgPSBjb2xvckZyb20uYiArIChjb2xvclRvLmIgLSBjb2xvckZyb20uYikgKiBwcm9ncmVzczsgLy8gPyBhbHBoYVxuXG4gICAgICByZXR1cm4gXCJyZ2IoXCIuY29uY2F0KE1hdGguZmxvb3IociksIFwiLCBcIikuY29uY2F0KE1hdGguZmxvb3IoZyksIFwiLCBcIikuY29uY2F0KE1hdGguZmxvb3IoYiksIFwiKVwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2Zyb20nKS5nZXRDb2xvcigpO1xuICB9XG5cbn1cblxuY2xhc3MgQW5pbWF0ZVRyYW5zZm9ybUVsZW1lbnQgZXh0ZW5kcyBBbmltYXRlRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ2FuaW1hdGVUcmFuc2Zvcm0nO1xuICB9XG5cbiAgY2FsY1ZhbHVlKCkge1xuICAgIHZhciB7XG4gICAgICBwcm9ncmVzcyxcbiAgICAgIGZyb20sXG4gICAgICB0b1xuICAgIH0gPSB0aGlzLmdldFByb2dyZXNzKCk7IC8vIHR3ZWVuIHZhbHVlIGxpbmVhcmx5XG5cbiAgICB2YXIgdHJhbnNmb3JtRnJvbSA9IHRvTnVtYmVycyhmcm9tLmdldFN0cmluZygpKTtcbiAgICB2YXIgdHJhbnNmb3JtVG8gPSB0b051bWJlcnModG8uZ2V0U3RyaW5nKCkpO1xuICAgIHZhciBuZXdWYWx1ZSA9IHRyYW5zZm9ybUZyb20ubWFwKChmcm9tLCBpKSA9PiB7XG4gICAgICB2YXIgdG8gPSB0cmFuc2Zvcm1Ub1tpXTtcbiAgICAgIHJldHVybiBmcm9tICsgKHRvIC0gZnJvbSkgKiBwcm9ncmVzcztcbiAgICB9KS5qb2luKCcgJyk7XG4gICAgcmV0dXJuIG5ld1ZhbHVlO1xuICB9XG5cbn1cblxuY2xhc3MgRm9udEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy50eXBlID0gJ2ZvbnQnO1xuICAgIHRoaXMuZ2x5cGhzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmhvcml6QWR2WCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdob3Jpei1hZHYteCcpLmdldE51bWJlcigpO1xuICAgIHZhciB7XG4gICAgICBkZWZpbml0aW9uc1xuICAgIH0gPSBkb2N1bWVudDtcbiAgICB2YXIge1xuICAgICAgY2hpbGRyZW5cbiAgICB9ID0gdGhpcztcblxuICAgIGZvciAodmFyIGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICBzd2l0Y2ggKGNoaWxkLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnZm9udC1mYWNlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmZvbnRGYWNlID0gY2hpbGQ7XG4gICAgICAgICAgICB2YXIgZm9udEZhbWlseVN0eWxlID0gY2hpbGQuZ2V0U3R5bGUoJ2ZvbnQtZmFtaWx5Jyk7XG5cbiAgICAgICAgICAgIGlmIChmb250RmFtaWx5U3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICBkZWZpbml0aW9uc1tmb250RmFtaWx5U3R5bGUuZ2V0U3RyaW5nKCldID0gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ21pc3NpbmctZ2x5cGgnOlxuICAgICAgICAgIHRoaXMubWlzc2luZ0dseXBoID0gY2hpbGQ7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZ2x5cGgnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBnbHlwaCA9IGNoaWxkO1xuXG4gICAgICAgICAgICBpZiAoZ2x5cGguYXJhYmljRm9ybSkge1xuICAgICAgICAgICAgICB0aGlzLmlzUlRMID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdGhpcy5pc0FyYWJpYyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmdseXBoc1tnbHlwaC51bmljb2RlXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdseXBoc1tnbHlwaC51bmljb2RlXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLmdseXBoc1tnbHlwaC51bmljb2RlXVtnbHlwaC5hcmFiaWNGb3JtXSA9IGdseXBoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5nbHlwaHNbZ2x5cGgudW5pY29kZV0gPSBnbHlwaDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJlbmRlcigpIHsvLyBOTyBSRU5ERVJcbiAgfVxuXG59XG5cbmNsYXNzIEZvbnRGYWNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLnR5cGUgPSAnZm9udC1mYWNlJztcbiAgICB0aGlzLmFzY2VudCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhc2NlbnQnKS5nZXROdW1iZXIoKTtcbiAgICB0aGlzLmRlc2NlbnQgPSB0aGlzLmdldEF0dHJpYnV0ZSgnZGVzY2VudCcpLmdldE51bWJlcigpO1xuICAgIHRoaXMudW5pdHNQZXJFbSA9IHRoaXMuZ2V0QXR0cmlidXRlKCd1bml0cy1wZXItZW0nKS5nZXROdW1iZXIoKTtcbiAgfVxuXG59XG5cbmNsYXNzIE1pc3NpbmdHbHlwaEVsZW1lbnQgZXh0ZW5kcyBQYXRoRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ21pc3NpbmctZ2x5cGgnO1xuICAgIHRoaXMuaG9yaXpBZHZYID0gMDtcbiAgfVxuXG59XG5cbmNsYXNzIFRSZWZFbGVtZW50IGV4dGVuZHMgVGV4dEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICd0cmVmJztcbiAgfVxuXG4gIGdldFRleHQoKSB7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXREZWZpbml0aW9uKCk7XG5cbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIGZpcnN0Q2hpbGQgPSBlbGVtZW50LmNoaWxkcmVuWzBdO1xuXG4gICAgICBpZiAoZmlyc3RDaGlsZCkge1xuICAgICAgICByZXR1cm4gZmlyc3RDaGlsZC5nZXRUZXh0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG5cbn1cblxuY2xhc3MgQUVsZW1lbnQgZXh0ZW5kcyBUZXh0RWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIHRoaXMudHlwZSA9ICdhJztcbiAgICB2YXIge1xuICAgICAgY2hpbGROb2Rlc1xuICAgIH0gPSBub2RlO1xuICAgIHZhciBmaXJzdENoaWxkID0gY2hpbGROb2Rlc1swXTtcbiAgICB2YXIgaGFzVGV4dCA9IGNoaWxkTm9kZXMubGVuZ3RoID4gMCAmJiBBcnJheS5mcm9tKGNoaWxkTm9kZXMpLmV2ZXJ5KG5vZGUgPT4gbm9kZS5ub2RlVHlwZSA9PT0gMyk7XG4gICAgdGhpcy5oYXNUZXh0ID0gaGFzVGV4dDtcbiAgICB0aGlzLnRleHQgPSBoYXNUZXh0ID8gdGhpcy5nZXRUZXh0RnJvbU5vZGUoZmlyc3RDaGlsZCkgOiAnJztcbiAgfVxuXG4gIGdldFRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgfVxuXG4gIHJlbmRlckNoaWxkcmVuKGN0eCkge1xuICAgIGlmICh0aGlzLmhhc1RleHQpIHtcbiAgICAgIC8vIHJlbmRlciBhcyB0ZXh0IGVsZW1lbnRcbiAgICAgIHN1cGVyLnJlbmRlckNoaWxkcmVuKGN0eCk7XG4gICAgICB2YXIge1xuICAgICAgICBkb2N1bWVudCxcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IHRoaXM7XG4gICAgICB2YXIge1xuICAgICAgICBtb3VzZVxuICAgICAgfSA9IGRvY3VtZW50LnNjcmVlbjtcbiAgICAgIHZhciBmb250U2l6ZSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ2ZvbnRTaXplJywgRm9udC5wYXJzZShkb2N1bWVudC5jdHguZm9udCkuZm9udFNpemUpOyAvLyBEbyBub3QgY2FsYyBib3VuZGluZyBib3ggaWYgbW91c2UgaXMgbm90IHdvcmtpbmcuXG5cbiAgICAgIGlmIChtb3VzZS5pc1dvcmtpbmcoKSkge1xuICAgICAgICBtb3VzZS5jaGVja0JvdW5kaW5nQm94KHRoaXMsIG5ldyBCb3VuZGluZ0JveCh4LCB5IC0gZm9udFNpemUuZ2V0UGl4ZWxzKCd5JyksIHggKyB0aGlzLm1lYXN1cmVUZXh0KGN0eCksIHkpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgLy8gcmVuZGVyIGFzIHRlbXBvcmFyeSBncm91cFxuICAgICAgdmFyIGcgPSBuZXcgR0VsZW1lbnQodGhpcy5kb2N1bWVudCwgbnVsbCk7XG4gICAgICBnLmNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICAgIGcucGFyZW50ID0gdGhpcztcbiAgICAgIGcucmVuZGVyKGN0eCk7XG4gICAgfVxuICB9XG5cbiAgb25DbGljaygpIHtcbiAgICB2YXIge1xuICAgICAgd2luZG93XG4gICAgfSA9IHRoaXMuZG9jdW1lbnQ7XG5cbiAgICBpZiAod2luZG93KSB7XG4gICAgICB3aW5kb3cub3Blbih0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXRTdHJpbmcoKSk7XG4gICAgfVxuICB9XG5cbiAgb25Nb3VzZU1vdmUoKSB7XG4gICAgdmFyIGN0eCA9IHRoaXMuZG9jdW1lbnQuY3R4O1xuICAgIGN0eC5jYW52YXMuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gb3duS2V5cyQyKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQyKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkMihPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDIoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5jbGFzcyBUZXh0UGF0aEVsZW1lbnQgZXh0ZW5kcyBUZXh0RWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIHRoaXMudHlwZSA9ICd0ZXh0UGF0aCc7XG4gICAgdGhpcy50ZXh0V2lkdGggPSAwO1xuICAgIHRoaXMudGV4dEhlaWdodCA9IDA7XG4gICAgdGhpcy5wYXRoTGVuZ3RoID0gLTE7XG4gICAgdGhpcy5nbHlwaEluZm8gPSBudWxsO1xuICAgIHRoaXMubGV0dGVyU3BhY2luZ0NhY2hlID0gW107XG4gICAgdGhpcy5tZWFzdXJlc0NhY2hlID0gbmV3IE1hcChbWycnLCAwXV0pO1xuICAgIHZhciBwYXRoRWxlbWVudCA9IHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmdldERlZmluaXRpb24oKTtcbiAgICB0aGlzLnRleHQgPSB0aGlzLmdldFRleHRGcm9tTm9kZSgpO1xuICAgIHRoaXMuZGF0YUFycmF5ID0gdGhpcy5wYXJzZVBhdGhEYXRhKHBhdGhFbGVtZW50KTtcbiAgfVxuXG4gIGdldFRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgfVxuXG4gIHBhdGgoY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIGRhdGFBcnJheVxuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKGN0eCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIH1cblxuICAgIGRhdGFBcnJheS5mb3JFYWNoKF9yZWYgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcG9pbnRzXG4gICAgICB9ID0gX3JlZjtcblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5MSU5FX1RPOlxuICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8ocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5NT1ZFX1RPOlxuICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5DVVJWRV9UTzpcbiAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHBvaW50c1s0XSwgcG9pbnRzWzVdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuUVVBRF9UTzpcbiAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5BUkM6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIFtjeCwgY3ksIHJ4LCByeSwgdGhldGEsIGRUaGV0YSwgcHNpLCBmc10gPSBwb2ludHM7XG4gICAgICAgICAgICB2YXIgciA9IHJ4ID4gcnkgPyByeCA6IHJ5O1xuICAgICAgICAgICAgdmFyIHNjYWxlWCA9IHJ4ID4gcnkgPyAxIDogcnggLyByeTtcbiAgICAgICAgICAgIHZhciBzY2FsZVkgPSByeCA+IHJ5ID8gcnkgLyByeCA6IDE7XG5cbiAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjeCwgY3kpO1xuICAgICAgICAgICAgICBjdHgucm90YXRlKHBzaSk7XG4gICAgICAgICAgICAgIGN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgICAgICAgIGN0eC5hcmMoMCwgMCwgciwgdGhldGEsIHRoZXRhICsgZFRoZXRhLCBCb29sZWFuKDEgLSBmcykpO1xuICAgICAgICAgICAgICBjdHguc2NhbGUoMSAvIHNjYWxlWCwgMSAvIHNjYWxlWSk7XG4gICAgICAgICAgICAgIGN0eC5yb3RhdGUoLXBzaSk7XG4gICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLWN4LCAtY3kpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkNMT1NFX1BBVEg6XG4gICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmVuZGVyQ2hpbGRyZW4oY3R4KSB7XG4gICAgdGhpcy5zZXRUZXh0RGF0YShjdHgpO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgdmFyIHRleHREZWNvcmF0aW9uID0gdGhpcy5wYXJlbnQuZ2V0U3R5bGUoJ3RleHQtZGVjb3JhdGlvbicpLmdldFN0cmluZygpO1xuICAgIHZhciBmb250U2l6ZSA9IHRoaXMuZ2V0Rm9udFNpemUoKTtcbiAgICB2YXIge1xuICAgICAgZ2x5cGhJbmZvXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIGZpbGwgPSBjdHguZmlsbFN0eWxlO1xuXG4gICAgaWYgKHRleHREZWNvcmF0aW9uID09PSAndW5kZXJsaW5lJykge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIH1cblxuICAgIGdseXBoSW5mby5mb3JFYWNoKChnbHlwaCwgaSkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgcDAsXG4gICAgICAgIHAxLFxuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgdGV4dDogcGFydGlhbFRleHRcbiAgICAgIH0gPSBnbHlwaDtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKHAwLngsIHAwLnkpO1xuICAgICAgY3R4LnJvdGF0ZShyb3RhdGlvbik7XG5cbiAgICAgIGlmIChjdHguZmlsbFN0eWxlKSB7XG4gICAgICAgIGN0eC5maWxsVGV4dChwYXJ0aWFsVGV4dCwgMCwgMCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdHguc3Ryb2tlU3R5bGUpIHtcbiAgICAgICAgY3R4LnN0cm9rZVRleHQocGFydGlhbFRleHQsIDAsIDApO1xuICAgICAgfVxuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICBpZiAodGV4dERlY29yYXRpb24gPT09ICd1bmRlcmxpbmUnKSB7XG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgY3R4Lm1vdmVUbyhwMC54LCBwMC55ICsgZm9udFNpemUgLyA4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5saW5lVG8ocDEueCwgcDEueSArIGZvbnRTaXplIC8gNSk7XG4gICAgICB9IC8vIC8vIFRvIGFzc2lzdCB3aXRoIGRlYnVnZ2luZyB2aXN1YWxseSwgdW5jb21tZW50IGZvbGxvd2luZ1xuICAgICAgLy9cbiAgICAgIC8vIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIC8vIGlmIChpICUgMilcbiAgICAgIC8vIFx0Y3R4LnN0cm9rZVN0eWxlID0gJ3JlZCc7XG4gICAgICAvLyBlbHNlXG4gICAgICAvLyBcdGN0eC5zdHJva2VTdHlsZSA9ICdncmVlbic7XG4gICAgICAvLyBjdHgubW92ZVRvKHAwLngsIHAwLnkpO1xuICAgICAgLy8gY3R4LmxpbmVUbyhwMS54LCBwMS55KTtcbiAgICAgIC8vIGN0eC5zdHJva2UoKTtcbiAgICAgIC8vIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgIH0pO1xuXG4gICAgaWYgKHRleHREZWNvcmF0aW9uID09PSAndW5kZXJsaW5lJykge1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IGZvbnRTaXplIC8gMjA7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBmaWxsO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cblxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cblxuICBnZXRMZXR0ZXJTcGFjaW5nQXQoKSB7XG4gICAgdmFyIGlkeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICByZXR1cm4gdGhpcy5sZXR0ZXJTcGFjaW5nQ2FjaGVbaWR4XSB8fCAwO1xuICB9XG5cbiAgZmluZFNlZ21lbnRUb0ZpdENoYXIoY3R4LCBhbmNob3IsIHRleHRGdWxsV2lkdGgsIGZ1bGxQYXRoV2lkdGgsIHNwYWNlc051bWJlciwgaW5wdXRPZmZzZXQsIGR5LCBjLCBjaGFySSkge1xuICAgIHZhciBvZmZzZXQgPSBpbnB1dE9mZnNldDtcbiAgICB2YXIgZ2x5cGhXaWR0aCA9IHRoaXMubWVhc3VyZVRleHQoY3R4LCBjKTtcblxuICAgIGlmIChjID09PSAnICcgJiYgYW5jaG9yID09PSAnanVzdGlmeScgJiYgdGV4dEZ1bGxXaWR0aCA8IGZ1bGxQYXRoV2lkdGgpIHtcbiAgICAgIGdseXBoV2lkdGggKz0gKGZ1bGxQYXRoV2lkdGggLSB0ZXh0RnVsbFdpZHRoKSAvIHNwYWNlc051bWJlcjtcbiAgICB9XG5cbiAgICBpZiAoY2hhckkgPiAtMSkge1xuICAgICAgb2Zmc2V0ICs9IHRoaXMuZ2V0TGV0dGVyU3BhY2luZ0F0KGNoYXJJKTtcbiAgICB9XG5cbiAgICB2YXIgc3BsaW5lU3RlcCA9IHRoaXMudGV4dEhlaWdodCAvIDIwO1xuICAgIHZhciBwMCA9IHRoaXMuZ2V0RXF1aWRpc3RhbnRQb2ludE9uUGF0aChvZmZzZXQsIHNwbGluZVN0ZXAsIDApO1xuICAgIHZhciBwMSA9IHRoaXMuZ2V0RXF1aWRpc3RhbnRQb2ludE9uUGF0aChvZmZzZXQgKyBnbHlwaFdpZHRoLCBzcGxpbmVTdGVwLCAwKTtcbiAgICB2YXIgc2VnbWVudCA9IHtcbiAgICAgIHAwLFxuICAgICAgcDFcbiAgICB9O1xuICAgIHZhciByb3RhdGlvbiA9IHAwICYmIHAxID8gTWF0aC5hdGFuMihwMS55IC0gcDAueSwgcDEueCAtIHAwLngpIDogMDtcblxuICAgIGlmIChkeSkge1xuICAgICAgdmFyIGR5WCA9IE1hdGguY29zKE1hdGguUEkgLyAyICsgcm90YXRpb24pICogZHk7XG4gICAgICB2YXIgZHlZID0gTWF0aC5jb3MoLXJvdGF0aW9uKSAqIGR5O1xuICAgICAgc2VnbWVudC5wMCA9IF9vYmplY3RTcHJlYWQkMihfb2JqZWN0U3ByZWFkJDIoe30sIHAwKSwge30sIHtcbiAgICAgICAgeDogcDAueCArIGR5WCxcbiAgICAgICAgeTogcDAueSArIGR5WVxuICAgICAgfSk7XG4gICAgICBzZWdtZW50LnAxID0gX29iamVjdFNwcmVhZCQyKF9vYmplY3RTcHJlYWQkMih7fSwgcDEpLCB7fSwge1xuICAgICAgICB4OiBwMS54ICsgZHlYLFxuICAgICAgICB5OiBwMS55ICsgZHlZXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBvZmZzZXQgKz0gZ2x5cGhXaWR0aDtcbiAgICByZXR1cm4ge1xuICAgICAgb2Zmc2V0LFxuICAgICAgc2VnbWVudCxcbiAgICAgIHJvdGF0aW9uXG4gICAgfTtcbiAgfVxuXG4gIG1lYXN1cmVUZXh0KGN0eCwgdGV4dCkge1xuICAgIHZhciB7XG4gICAgICBtZWFzdXJlc0NhY2hlXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHRhcmdldFRleHQgPSB0ZXh0IHx8IHRoaXMuZ2V0VGV4dCgpO1xuXG4gICAgaWYgKG1lYXN1cmVzQ2FjaGUuaGFzKHRhcmdldFRleHQpKSB7XG4gICAgICByZXR1cm4gbWVhc3VyZXNDYWNoZS5nZXQodGFyZ2V0VGV4dCk7XG4gICAgfVxuXG4gICAgdmFyIG1lYXN1cmUgPSB0aGlzLm1lYXN1cmVUYXJnZXRUZXh0KGN0eCwgdGFyZ2V0VGV4dCk7XG4gICAgbWVhc3VyZXNDYWNoZS5zZXQodGFyZ2V0VGV4dCwgbWVhc3VyZSk7XG4gICAgcmV0dXJuIG1lYXN1cmU7XG4gIH0gLy8gVGhpcyBtZXRob2Qgc3VwcG9zZXMgd2hhdCBhbGwgY3VzdG9tIGZvbnRzIGFscmVhZHkgbG9hZGVkLlxuICAvLyBJZiBzb21lIGZvbnQgd2lsbCBiZSBsb2FkZWQgYWZ0ZXIgdGhpcyBtZXRob2QgY2FsbCwgPHRleHRQYXRoPiB3aWxsIG5vdCBiZSByZW5kZXJlZCBjb3JyZWN0bHkuXG4gIC8vIFlvdSBuZWVkIHRvIGNhbGwgdGhpcyBtZXRob2QgbWFudWFsbHkgdG8gdXBkYXRlIGdseXBocyBjYWNoZS5cblxuXG4gIHNldFRleHREYXRhKGN0eCkge1xuICAgIGlmICh0aGlzLmdseXBoSW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByZW5kZXJUZXh0ID0gdGhpcy5nZXRUZXh0KCk7XG4gICAgdmFyIGNoYXJzID0gcmVuZGVyVGV4dC5zcGxpdCgnJyk7XG4gICAgdmFyIHNwYWNlc051bWJlciA9IHJlbmRlclRleHQuc3BsaXQoJyAnKS5sZW5ndGggLSAxO1xuICAgIHZhciBkeCA9IHRoaXMucGFyZW50LmdldEF0dHJpYnV0ZSgnZHgnKS5zcGxpdCgpLm1hcChfID0+IF8uZ2V0UGl4ZWxzKCd4JykpO1xuICAgIHZhciBkeSA9IHRoaXMucGFyZW50LmdldEF0dHJpYnV0ZSgnZHknKS5nZXRQaXhlbHMoJ3knKTtcbiAgICB2YXIgYW5jaG9yID0gdGhpcy5wYXJlbnQuZ2V0U3R5bGUoJ3RleHQtYW5jaG9yJykuZ2V0U3RyaW5nKCdzdGFydCcpO1xuICAgIHZhciB0aGlzU3BhY2luZyA9IHRoaXMuZ2V0U3R5bGUoJ2xldHRlci1zcGFjaW5nJyk7XG4gICAgdmFyIHBhcmVudFNwYWNpbmcgPSB0aGlzLnBhcmVudC5nZXRTdHlsZSgnbGV0dGVyLXNwYWNpbmcnKTtcbiAgICB2YXIgbGV0dGVyU3BhY2luZyA9IDA7XG5cbiAgICBpZiAoIXRoaXNTcGFjaW5nLmhhc1ZhbHVlKCkgfHwgdGhpc1NwYWNpbmcuZ2V0VmFsdWUoKSA9PT0gJ2luaGVyaXQnKSB7XG4gICAgICBsZXR0ZXJTcGFjaW5nID0gcGFyZW50U3BhY2luZy5nZXRQaXhlbHMoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXNTcGFjaW5nLmhhc1ZhbHVlKCkpIHtcbiAgICAgIGlmICh0aGlzU3BhY2luZy5nZXRWYWx1ZSgpICE9PSAnaW5pdGlhbCcgJiYgdGhpc1NwYWNpbmcuZ2V0VmFsdWUoKSAhPT0gJ3Vuc2V0Jykge1xuICAgICAgICBsZXR0ZXJTcGFjaW5nID0gdGhpc1NwYWNpbmcuZ2V0UGl4ZWxzKCk7XG4gICAgICB9XG4gICAgfSAvLyBmaWxsIGxldHRlci1zcGFjaW5nIGNhY2hlXG5cblxuICAgIHZhciBsZXR0ZXJTcGFjaW5nQ2FjaGUgPSBbXTtcbiAgICB2YXIgdGV4dExlbiA9IHJlbmRlclRleHQubGVuZ3RoO1xuICAgIHRoaXMubGV0dGVyU3BhY2luZ0NhY2hlID0gbGV0dGVyU3BhY2luZ0NhY2hlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0TGVuOyBpKyspIHtcbiAgICAgIGxldHRlclNwYWNpbmdDYWNoZS5wdXNoKHR5cGVvZiBkeFtpXSAhPT0gJ3VuZGVmaW5lZCcgPyBkeFtpXSA6IGxldHRlclNwYWNpbmcpO1xuICAgIH1cblxuICAgIHZhciBkeFN1bSA9IGxldHRlclNwYWNpbmdDYWNoZS5yZWR1Y2UoKGFjYywgY3VyLCBpKSA9PiBpID09PSAwID8gMCA6IGFjYyArIGN1ciB8fCAwLCAwKTtcbiAgICB2YXIgdGV4dFdpZHRoID0gdGhpcy5tZWFzdXJlVGV4dChjdHgpO1xuICAgIHZhciB0ZXh0RnVsbFdpZHRoID0gTWF0aC5tYXgodGV4dFdpZHRoICsgZHhTdW0sIDApO1xuICAgIHRoaXMudGV4dFdpZHRoID0gdGV4dFdpZHRoO1xuICAgIHRoaXMudGV4dEhlaWdodCA9IHRoaXMuZ2V0Rm9udFNpemUoKTtcbiAgICB0aGlzLmdseXBoSW5mbyA9IFtdO1xuICAgIHZhciBmdWxsUGF0aFdpZHRoID0gdGhpcy5nZXRQYXRoTGVuZ3RoKCk7XG4gICAgdmFyIHN0YXJ0T2Zmc2V0ID0gdGhpcy5nZXRTdHlsZSgnc3RhcnRPZmZzZXQnKS5nZXROdW1iZXIoMCkgKiBmdWxsUGF0aFdpZHRoO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuXG4gICAgaWYgKGFuY2hvciA9PT0gJ21pZGRsZScgfHwgYW5jaG9yID09PSAnY2VudGVyJykge1xuICAgICAgb2Zmc2V0ID0gLXRleHRGdWxsV2lkdGggLyAyO1xuICAgIH1cblxuICAgIGlmIChhbmNob3IgPT09ICdlbmQnIHx8IGFuY2hvciA9PT0gJ3JpZ2h0Jykge1xuICAgICAgb2Zmc2V0ID0gLXRleHRGdWxsV2lkdGg7XG4gICAgfVxuXG4gICAgb2Zmc2V0ICs9IHN0YXJ0T2Zmc2V0O1xuICAgIGNoYXJzLmZvckVhY2goKGNoYXIsIGkpID0+IHtcbiAgICAgIC8vIEZpbmQgc3VjaCBzZWdtZW50IHdoYXQgZGlzdGFuY2UgYmV0d2VlbiBwMCBhbmQgcDEgaXMgYXBwcm94LiB3aWR0aCBvZiBnbHlwaFxuICAgICAgdmFyIHtcbiAgICAgICAgb2Zmc2V0OiBuZXh0T2Zmc2V0LFxuICAgICAgICBzZWdtZW50LFxuICAgICAgICByb3RhdGlvblxuICAgICAgfSA9IHRoaXMuZmluZFNlZ21lbnRUb0ZpdENoYXIoY3R4LCBhbmNob3IsIHRleHRGdWxsV2lkdGgsIGZ1bGxQYXRoV2lkdGgsIHNwYWNlc051bWJlciwgb2Zmc2V0LCBkeSwgY2hhciwgaSk7XG4gICAgICBvZmZzZXQgPSBuZXh0T2Zmc2V0O1xuXG4gICAgICBpZiAoIXNlZ21lbnQucDAgfHwgIXNlZ21lbnQucDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0TGluZUxlbmd0aChcbiAgICAgIC8vIFx0c2VnbWVudC5wMC54LFxuICAgICAgLy8gXHRzZWdtZW50LnAwLnksXG4gICAgICAvLyBcdHNlZ21lbnQucDEueCxcbiAgICAgIC8vIFx0c2VnbWVudC5wMS55XG4gICAgICAvLyApO1xuICAgICAgLy8gTm90ZTogU2luY2UgZ2x5cGhzIGFyZSByZW5kZXJlZCBvbmUgYXQgYSB0aW1lLCBhbnkga2VybmluZyBwYWlyIGRhdGEgYnVpbHQgaW50byB0aGUgZm9udCB3aWxsIG5vdCBiZSB1c2VkLlxuICAgICAgLy8gQ2FuIGZvcmVzZWUgaGF2aW5nIGEgcm91Z2ggcGFpciB0YWJsZSBidWlsdCBpbiB0aGF0IHRoZSBkZXZlbG9wZXIgY2FuIG92ZXJyaWRlIGFzIG5lZWRlZC5cbiAgICAgIC8vIE9yIHVzZSBcImR4XCIgYXR0cmlidXRlIG9mIHRoZSA8dGV4dD4gbm9kZSBhcyBhIG5haXZlIHJlcGxhY2VtZW50XG4gICAgICAvLyBjb25zdCBrZXJuID0gMDtcbiAgICAgIC8vIHBsYWNlaG9sZGVyIGZvciBmdXR1cmUgaW1wbGVtZW50YXRpb25cbiAgICAgIC8vIGNvbnN0IG1pZHBvaW50ID0gdGhpcy5nZXRQb2ludE9uTGluZShcbiAgICAgIC8vIFx0a2VybiArIHdpZHRoIC8gMi4wLFxuICAgICAgLy8gXHRzZWdtZW50LnAwLngsIHNlZ21lbnQucDAueSwgc2VnbWVudC5wMS54LCBzZWdtZW50LnAxLnlcbiAgICAgIC8vICk7XG5cblxuICAgICAgdGhpcy5nbHlwaEluZm8ucHVzaCh7XG4gICAgICAgIC8vIHRyYW5zcG9zZVg6IG1pZHBvaW50LngsXG4gICAgICAgIC8vIHRyYW5zcG9zZVk6IG1pZHBvaW50LnksXG4gICAgICAgIHRleHQ6IGNoYXJzW2ldLFxuICAgICAgICBwMDogc2VnbWVudC5wMCxcbiAgICAgICAgcDE6IHNlZ21lbnQucDEsXG4gICAgICAgIHJvdGF0aW9uXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHBhcnNlUGF0aERhdGEocGF0aCkge1xuICAgIHRoaXMucGF0aExlbmd0aCA9IC0xOyAvLyByZXNldCBwYXRoIGxlbmd0aFxuXG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIHBhdGhDb21tYW5kcyA9IFtdO1xuICAgIHZhciB7XG4gICAgICBwYXRoUGFyc2VyXG4gICAgfSA9IHBhdGg7XG4gICAgcGF0aFBhcnNlci5yZXNldCgpOyAvLyBjb252ZXJ0IGwsIEgsIGgsIFYsIGFuZCB2IHRvIExcblxuICAgIHdoaWxlICghcGF0aFBhcnNlci5pc0VuZCgpKSB7XG4gICAgICB2YXIge1xuICAgICAgICBjdXJyZW50XG4gICAgICB9ID0gcGF0aFBhcnNlcjtcbiAgICAgIHZhciBzdGFydFggPSBjdXJyZW50ID8gY3VycmVudC54IDogMDtcbiAgICAgIHZhciBzdGFydFkgPSBjdXJyZW50ID8gY3VycmVudC55IDogMDtcbiAgICAgIHZhciBjb21tYW5kID0gcGF0aFBhcnNlci5uZXh0KCk7XG4gICAgICB2YXIgbmV4dENvbW1hbmRUeXBlID0gY29tbWFuZC50eXBlO1xuICAgICAgdmFyIHBvaW50cyA9IFtdO1xuXG4gICAgICBzd2l0Y2ggKGNvbW1hbmQudHlwZSkge1xuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuTU9WRV9UTzpcbiAgICAgICAgICB0aGlzLnBhdGhNKHBhdGhQYXJzZXIsIHBvaW50cyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkxJTkVfVE86XG4gICAgICAgICAgbmV4dENvbW1hbmRUeXBlID0gdGhpcy5wYXRoTChwYXRoUGFyc2VyLCBwb2ludHMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5IT1JJWl9MSU5FX1RPOlxuICAgICAgICAgIG5leHRDb21tYW5kVHlwZSA9IHRoaXMucGF0aEgocGF0aFBhcnNlciwgcG9pbnRzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuVkVSVF9MSU5FX1RPOlxuICAgICAgICAgIG5leHRDb21tYW5kVHlwZSA9IHRoaXMucGF0aFYocGF0aFBhcnNlciwgcG9pbnRzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQ1VSVkVfVE86XG4gICAgICAgICAgdGhpcy5wYXRoQyhwYXRoUGFyc2VyLCBwb2ludHMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5TTU9PVEhfQ1VSVkVfVE86XG4gICAgICAgICAgbmV4dENvbW1hbmRUeXBlID0gdGhpcy5wYXRoUyhwYXRoUGFyc2VyLCBwb2ludHMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5RVUFEX1RPOlxuICAgICAgICAgIHRoaXMucGF0aFEocGF0aFBhcnNlciwgcG9pbnRzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuU01PT1RIX1FVQURfVE86XG4gICAgICAgICAgbmV4dENvbW1hbmRUeXBlID0gdGhpcy5wYXRoVChwYXRoUGFyc2VyLCBwb2ludHMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5BUkM6XG4gICAgICAgICAgcG9pbnRzID0gdGhpcy5wYXRoQShwYXRoUGFyc2VyKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQ0xPU0VfUEFUSDpcbiAgICAgICAgICBQYXRoRWxlbWVudC5wYXRoWihwYXRoUGFyc2VyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbW1hbmQudHlwZSAhPT0gUGF0aFBhcnNlci5DTE9TRV9QQVRIKSB7XG4gICAgICAgIHBhdGhDb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBuZXh0Q29tbWFuZFR5cGUsXG4gICAgICAgICAgcG9pbnRzLFxuICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICB4OiBzdGFydFgsXG4gICAgICAgICAgICB5OiBzdGFydFlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBhdGhMZW5ndGg6IHRoaXMuY2FsY0xlbmd0aChzdGFydFgsIHN0YXJ0WSwgbmV4dENvbW1hbmRUeXBlLCBwb2ludHMpXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0aENvbW1hbmRzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFBhdGhQYXJzZXIuQ0xPU0VfUEFUSCxcbiAgICAgICAgICBwb2ludHM6IFtdLFxuICAgICAgICAgIHBhdGhMZW5ndGg6IDBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhDb21tYW5kcztcbiAgfVxuXG4gIHBhdGhNKHBhdGhQYXJzZXIsIHBvaW50cykge1xuICAgIHZhciB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSBQYXRoRWxlbWVudC5wYXRoTShwYXRoUGFyc2VyKS5wb2ludDtcbiAgICBwb2ludHMucHVzaCh4LCB5KTtcbiAgfVxuXG4gIHBhdGhMKHBhdGhQYXJzZXIsIHBvaW50cykge1xuICAgIHZhciB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSBQYXRoRWxlbWVudC5wYXRoTChwYXRoUGFyc2VyKS5wb2ludDtcbiAgICBwb2ludHMucHVzaCh4LCB5KTtcbiAgICByZXR1cm4gUGF0aFBhcnNlci5MSU5FX1RPO1xuICB9XG5cbiAgcGF0aEgocGF0aFBhcnNlciwgcG9pbnRzKSB7XG4gICAgdmFyIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IFBhdGhFbGVtZW50LnBhdGhIKHBhdGhQYXJzZXIpLnBvaW50O1xuICAgIHBvaW50cy5wdXNoKHgsIHkpO1xuICAgIHJldHVybiBQYXRoUGFyc2VyLkxJTkVfVE87XG4gIH1cblxuICBwYXRoVihwYXRoUGFyc2VyLCBwb2ludHMpIHtcbiAgICB2YXIge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aFYocGF0aFBhcnNlcikucG9pbnQ7XG4gICAgcG9pbnRzLnB1c2goeCwgeSk7XG4gICAgcmV0dXJuIFBhdGhQYXJzZXIuTElORV9UTztcbiAgfVxuXG4gIHBhdGhDKHBhdGhQYXJzZXIsIHBvaW50cykge1xuICAgIHZhciB7XG4gICAgICBwb2ludCxcbiAgICAgIGNvbnRyb2xQb2ludCxcbiAgICAgIGN1cnJlbnRQb2ludFxuICAgIH0gPSBQYXRoRWxlbWVudC5wYXRoQyhwYXRoUGFyc2VyKTtcbiAgICBwb2ludHMucHVzaChwb2ludC54LCBwb2ludC55LCBjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gIH1cblxuICBwYXRoUyhwYXRoUGFyc2VyLCBwb2ludHMpIHtcbiAgICB2YXIge1xuICAgICAgcG9pbnQsXG4gICAgICBjb250cm9sUG9pbnQsXG4gICAgICBjdXJyZW50UG9pbnRcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aFMocGF0aFBhcnNlcik7XG4gICAgcG9pbnRzLnB1c2gocG9pbnQueCwgcG9pbnQueSwgY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICAgIHJldHVybiBQYXRoUGFyc2VyLkNVUlZFX1RPO1xuICB9XG5cbiAgcGF0aFEocGF0aFBhcnNlciwgcG9pbnRzKSB7XG4gICAgdmFyIHtcbiAgICAgIGNvbnRyb2xQb2ludCxcbiAgICAgIGN1cnJlbnRQb2ludFxuICAgIH0gPSBQYXRoRWxlbWVudC5wYXRoUShwYXRoUGFyc2VyKTtcbiAgICBwb2ludHMucHVzaChjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gIH1cblxuICBwYXRoVChwYXRoUGFyc2VyLCBwb2ludHMpIHtcbiAgICB2YXIge1xuICAgICAgY29udHJvbFBvaW50LFxuICAgICAgY3VycmVudFBvaW50XG4gICAgfSA9IFBhdGhFbGVtZW50LnBhdGhUKHBhdGhQYXJzZXIpO1xuICAgIHBvaW50cy5wdXNoKGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICByZXR1cm4gUGF0aFBhcnNlci5RVUFEX1RPO1xuICB9XG5cbiAgcGF0aEEocGF0aFBhcnNlcikge1xuICAgIHZhciB7XG4gICAgICByWCxcbiAgICAgIHJZLFxuICAgICAgc3dlZXBGbGFnLFxuICAgICAgeEF4aXNSb3RhdGlvbixcbiAgICAgIGNlbnRwLFxuICAgICAgYTEsXG4gICAgICBhZFxuICAgIH0gPSBQYXRoRWxlbWVudC5wYXRoQShwYXRoUGFyc2VyKTtcblxuICAgIGlmIChzd2VlcEZsYWcgPT09IDAgJiYgYWQgPiAwKSB7XG4gICAgICBhZCAtPSAyICogTWF0aC5QSTtcbiAgICB9XG5cbiAgICBpZiAoc3dlZXBGbGFnID09PSAxICYmIGFkIDwgMCkge1xuICAgICAgYWQgKz0gMiAqIE1hdGguUEk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtjZW50cC54LCBjZW50cC55LCByWCwgclksIGExLCBhZCwgeEF4aXNSb3RhdGlvbiwgc3dlZXBGbGFnXTtcbiAgfVxuXG4gIGNhbGNMZW5ndGgoeCwgeSwgY29tbWFuZFR5cGUsIHBvaW50cykge1xuICAgIHZhciBsZW4gPSAwO1xuICAgIHZhciBwMSA9IG51bGw7XG4gICAgdmFyIHAyID0gbnVsbDtcbiAgICB2YXIgdCA9IDA7XG5cbiAgICBzd2l0Y2ggKGNvbW1hbmRUeXBlKSB7XG4gICAgICBjYXNlIFBhdGhQYXJzZXIuTElORV9UTzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGluZUxlbmd0aCh4LCB5LCBwb2ludHNbMF0sIHBvaW50c1sxXSk7XG5cbiAgICAgIGNhc2UgUGF0aFBhcnNlci5DVVJWRV9UTzpcbiAgICAgICAgLy8gQXBwcm94aW1hdGVzIGJ5IGJyZWFraW5nIGN1cnZlIGludG8gMTAwIGxpbmUgc2VnbWVudHNcbiAgICAgICAgbGVuID0gMC4wO1xuICAgICAgICBwMSA9IHRoaXMuZ2V0UG9pbnRPbkN1YmljQmV6aWVyKDAsIHgsIHksIHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgcG9pbnRzWzRdLCBwb2ludHNbNV0pO1xuXG4gICAgICAgIGZvciAodCA9IDAuMDE7IHQgPD0gMTsgdCArPSAwLjAxKSB7XG4gICAgICAgICAgcDIgPSB0aGlzLmdldFBvaW50T25DdWJpY0Jlemllcih0LCB4LCB5LCBwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHBvaW50c1s0XSwgcG9pbnRzWzVdKTtcbiAgICAgICAgICBsZW4gKz0gdGhpcy5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xuICAgICAgICAgIHAxID0gcDI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGVuO1xuXG4gICAgICBjYXNlIFBhdGhQYXJzZXIuUVVBRF9UTzpcbiAgICAgICAgLy8gQXBwcm94aW1hdGVzIGJ5IGJyZWFraW5nIGN1cnZlIGludG8gMTAwIGxpbmUgc2VnbWVudHNcbiAgICAgICAgbGVuID0gMC4wO1xuICAgICAgICBwMSA9IHRoaXMuZ2V0UG9pbnRPblF1YWRyYXRpY0JlemllcigwLCB4LCB5LCBwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10pO1xuXG4gICAgICAgIGZvciAodCA9IDAuMDE7IHQgPD0gMTsgdCArPSAwLjAxKSB7XG4gICAgICAgICAgcDIgPSB0aGlzLmdldFBvaW50T25RdWFkcmF0aWNCZXppZXIodCwgeCwgeSwgcG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdKTtcbiAgICAgICAgICBsZW4gKz0gdGhpcy5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xuICAgICAgICAgIHAxID0gcDI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGVuO1xuXG4gICAgICBjYXNlIFBhdGhQYXJzZXIuQVJDOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gQXBwcm94aW1hdGVzIGJ5IGJyZWFraW5nIGN1cnZlIGludG8gbGluZSBzZWdtZW50c1xuICAgICAgICAgIGxlbiA9IDAuMDtcbiAgICAgICAgICB2YXIgc3RhcnQgPSBwb2ludHNbNF07IC8vIDQgPSB0aGV0YVxuXG4gICAgICAgICAgdmFyIGRUaGV0YSA9IHBvaW50c1s1XTsgLy8gNSA9IGRUaGV0YVxuXG4gICAgICAgICAgdmFyIGVuZCA9IHBvaW50c1s0XSArIGRUaGV0YTtcbiAgICAgICAgICB2YXIgaW5jID0gTWF0aC5QSSAvIDE4MC4wOyAvLyAxIGRlZ3JlZSByZXNvbHV0aW9uXG5cbiAgICAgICAgICBpZiAoTWF0aC5hYnMoc3RhcnQgLSBlbmQpIDwgaW5jKSB7XG4gICAgICAgICAgICBpbmMgPSBNYXRoLmFicyhzdGFydCAtIGVuZCk7XG4gICAgICAgICAgfSAvLyBOb3RlOiBmb3IgcHVycG9zZSBvZiBjYWxjdWxhdGluZyBhcmMgbGVuZ3RoLCBub3QgZ29pbmcgdG8gd29ycnkgYWJvdXQgcm90YXRpbmcgWC1heGlzIGJ5IGFuZ2xlIHBzaVxuXG5cbiAgICAgICAgICBwMSA9IHRoaXMuZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCBzdGFydCwgMCk7XG5cbiAgICAgICAgICBpZiAoZFRoZXRhIDwgMCkge1xuICAgICAgICAgICAgLy8gY2xvY2t3aXNlXG4gICAgICAgICAgICBmb3IgKHQgPSBzdGFydCAtIGluYzsgdCA+IGVuZDsgdCAtPSBpbmMpIHtcbiAgICAgICAgICAgICAgcDIgPSB0aGlzLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgdCwgMCk7XG4gICAgICAgICAgICAgIGxlbiArPSB0aGlzLmdldExpbmVMZW5ndGgocDEueCwgcDEueSwgcDIueCwgcDIueSk7XG4gICAgICAgICAgICAgIHAxID0gcDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNvdW50ZXItY2xvY2t3aXNlXG4gICAgICAgICAgICBmb3IgKHQgPSBzdGFydCArIGluYzsgdCA8IGVuZDsgdCArPSBpbmMpIHtcbiAgICAgICAgICAgICAgcDIgPSB0aGlzLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgdCwgMCk7XG4gICAgICAgICAgICAgIGxlbiArPSB0aGlzLmdldExpbmVMZW5ndGgocDEueCwgcDEueSwgcDIueCwgcDIueSk7XG4gICAgICAgICAgICAgIHAxID0gcDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcDIgPSB0aGlzLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgZW5kLCAwKTtcbiAgICAgICAgICBsZW4gKz0gdGhpcy5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xuICAgICAgICAgIHJldHVybiBsZW47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGdldFBvaW50T25MaW5lKGRpc3QsIHAxeCwgcDF5LCBwMngsIHAyeSkge1xuICAgIHZhciBmcm9tWCA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogcDF4O1xuICAgIHZhciBmcm9tWSA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIGFyZ3VtZW50c1s2XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzZdIDogcDF5O1xuICAgIHZhciBtID0gKHAyeSAtIHAxeSkgLyAocDJ4IC0gcDF4ICsgUFNFVURPX1pFUk8pO1xuICAgIHZhciBydW4gPSBNYXRoLnNxcnQoZGlzdCAqIGRpc3QgLyAoMSArIG0gKiBtKSk7XG5cbiAgICBpZiAocDJ4IDwgcDF4KSB7XG4gICAgICBydW4gKj0gLTE7XG4gICAgfVxuXG4gICAgdmFyIHJpc2UgPSBtICogcnVuO1xuICAgIHZhciBwdCA9IG51bGw7XG5cbiAgICBpZiAocDJ4ID09PSBwMXgpIHtcbiAgICAgIC8vIHZlcnRpY2FsIGxpbmVcbiAgICAgIHB0ID0ge1xuICAgICAgICB4OiBmcm9tWCxcbiAgICAgICAgeTogZnJvbVkgKyByaXNlXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoKGZyb21ZIC0gcDF5KSAvIChmcm9tWCAtIHAxeCArIFBTRVVET19aRVJPKSA9PT0gbSkge1xuICAgICAgcHQgPSB7XG4gICAgICAgIHg6IGZyb21YICsgcnVuLFxuICAgICAgICB5OiBmcm9tWSArIHJpc2VcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpeCA9IDA7XG4gICAgICB2YXIgaXkgPSAwO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuZ2V0TGluZUxlbmd0aChwMXgsIHAxeSwgcDJ4LCBwMnkpO1xuXG4gICAgICBpZiAobGVuIDwgUFNFVURPX1pFUk8pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciB1ID0gKGZyb21YIC0gcDF4KSAqIChwMnggLSBwMXgpICsgKGZyb21ZIC0gcDF5KSAqIChwMnkgLSBwMXkpO1xuICAgICAgdSAvPSBsZW4gKiBsZW47XG4gICAgICBpeCA9IHAxeCArIHUgKiAocDJ4IC0gcDF4KTtcbiAgICAgIGl5ID0gcDF5ICsgdSAqIChwMnkgLSBwMXkpO1xuICAgICAgdmFyIHBSaXNlID0gdGhpcy5nZXRMaW5lTGVuZ3RoKGZyb21YLCBmcm9tWSwgaXgsIGl5KTtcbiAgICAgIHZhciBwUnVuID0gTWF0aC5zcXJ0KGRpc3QgKiBkaXN0IC0gcFJpc2UgKiBwUmlzZSk7XG4gICAgICBydW4gPSBNYXRoLnNxcnQocFJ1biAqIHBSdW4gLyAoMSArIG0gKiBtKSk7XG5cbiAgICAgIGlmIChwMnggPCBwMXgpIHtcbiAgICAgICAgcnVuICo9IC0xO1xuICAgICAgfVxuXG4gICAgICByaXNlID0gbSAqIHJ1bjtcbiAgICAgIHB0ID0ge1xuICAgICAgICB4OiBpeCArIHJ1bixcbiAgICAgICAgeTogaXkgKyByaXNlXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBwdDtcbiAgfVxuXG4gIGdldFBvaW50T25QYXRoKGRpc3RhbmNlKSB7XG4gICAgdmFyIGZ1bGxMZW4gPSB0aGlzLmdldFBhdGhMZW5ndGgoKTtcbiAgICB2YXIgY3VtdWxhdGl2ZVBhdGhMZW5ndGggPSAwO1xuICAgIHZhciBwID0gbnVsbDtcblxuICAgIGlmIChkaXN0YW5jZSA8IC0wLjAwMDA1IHx8IGRpc3RhbmNlIC0gMC4wMDAwNSA+IGZ1bGxMZW4pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBkYXRhQXJyYXlcbiAgICB9ID0gdGhpcztcblxuICAgIGZvciAodmFyIGNvbW1hbmQgb2YgZGF0YUFycmF5KSB7XG4gICAgICBpZiAoY29tbWFuZCAmJiAoY29tbWFuZC5wYXRoTGVuZ3RoIDwgMC4wMDAwNSB8fCBjdW11bGF0aXZlUGF0aExlbmd0aCArIGNvbW1hbmQucGF0aExlbmd0aCArIDAuMDAwMDUgPCBkaXN0YW5jZSkpIHtcbiAgICAgICAgY3VtdWxhdGl2ZVBhdGhMZW5ndGggKz0gY29tbWFuZC5wYXRoTGVuZ3RoO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlbHRhID0gZGlzdGFuY2UgLSBjdW11bGF0aXZlUGF0aExlbmd0aDtcbiAgICAgIHZhciBjdXJyZW50VCA9IDA7XG5cbiAgICAgIHN3aXRjaCAoY29tbWFuZC50eXBlKSB7XG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5MSU5FX1RPOlxuICAgICAgICAgIHAgPSB0aGlzLmdldFBvaW50T25MaW5lKGRlbHRhLCBjb21tYW5kLnN0YXJ0LngsIGNvbW1hbmQuc3RhcnQueSwgY29tbWFuZC5wb2ludHNbMF0sIGNvbW1hbmQucG9pbnRzWzFdLCBjb21tYW5kLnN0YXJ0LngsIGNvbW1hbmQuc3RhcnQueSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkFSQzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBjb21tYW5kLnBvaW50c1s0XTsgLy8gNCA9IHRoZXRhXG5cbiAgICAgICAgICAgIHZhciBkVGhldGEgPSBjb21tYW5kLnBvaW50c1s1XTsgLy8gNSA9IGRUaGV0YVxuXG4gICAgICAgICAgICB2YXIgZW5kID0gY29tbWFuZC5wb2ludHNbNF0gKyBkVGhldGE7XG4gICAgICAgICAgICBjdXJyZW50VCA9IHN0YXJ0ICsgZGVsdGEgLyBjb21tYW5kLnBhdGhMZW5ndGggKiBkVGhldGE7XG5cbiAgICAgICAgICAgIGlmIChkVGhldGEgPCAwICYmIGN1cnJlbnRUIDwgZW5kIHx8IGRUaGV0YSA+PSAwICYmIGN1cnJlbnRUID4gZW5kKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwID0gdGhpcy5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhjb21tYW5kLnBvaW50c1swXSwgY29tbWFuZC5wb2ludHNbMV0sIGNvbW1hbmQucG9pbnRzWzJdLCBjb21tYW5kLnBvaW50c1szXSwgY3VycmVudFQsIGNvbW1hbmQucG9pbnRzWzZdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQ1VSVkVfVE86XG4gICAgICAgICAgY3VycmVudFQgPSBkZWx0YSAvIGNvbW1hbmQucGF0aExlbmd0aDtcblxuICAgICAgICAgIGlmIChjdXJyZW50VCA+IDEpIHtcbiAgICAgICAgICAgIGN1cnJlbnRUID0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwID0gdGhpcy5nZXRQb2ludE9uQ3ViaWNCZXppZXIoY3VycmVudFQsIGNvbW1hbmQuc3RhcnQueCwgY29tbWFuZC5zdGFydC55LCBjb21tYW5kLnBvaW50c1swXSwgY29tbWFuZC5wb2ludHNbMV0sIGNvbW1hbmQucG9pbnRzWzJdLCBjb21tYW5kLnBvaW50c1szXSwgY29tbWFuZC5wb2ludHNbNF0sIGNvbW1hbmQucG9pbnRzWzVdKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuUVVBRF9UTzpcbiAgICAgICAgICBjdXJyZW50VCA9IGRlbHRhIC8gY29tbWFuZC5wYXRoTGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnRUID4gMSkge1xuICAgICAgICAgICAgY3VycmVudFQgPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHAgPSB0aGlzLmdldFBvaW50T25RdWFkcmF0aWNCZXppZXIoY3VycmVudFQsIGNvbW1hbmQuc3RhcnQueCwgY29tbWFuZC5zdGFydC55LCBjb21tYW5kLnBvaW50c1swXSwgY29tbWFuZC5wb2ludHNbMV0sIGNvbW1hbmQucG9pbnRzWzJdLCBjb21tYW5kLnBvaW50c1szXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChwKSB7XG4gICAgICAgIHJldHVybiBwO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldExpbmVMZW5ndGgoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KCh4MiAtIHgxKSAqICh4MiAtIHgxKSArICh5MiAtIHkxKSAqICh5MiAtIHkxKSk7XG4gIH1cblxuICBnZXRQYXRoTGVuZ3RoKCkge1xuICAgIGlmICh0aGlzLnBhdGhMZW5ndGggPT09IC0xKSB7XG4gICAgICB0aGlzLnBhdGhMZW5ndGggPSB0aGlzLmRhdGFBcnJheS5yZWR1Y2UoKGxlbmd0aCwgY29tbWFuZCkgPT4gY29tbWFuZC5wYXRoTGVuZ3RoID4gMCA/IGxlbmd0aCArIGNvbW1hbmQucGF0aExlbmd0aCA6IGxlbmd0aCwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGF0aExlbmd0aDtcbiAgfVxuXG4gIGdldFBvaW50T25DdWJpY0JlemllcihwY3QsIHAxeCwgcDF5LCBwMngsIHAyeSwgcDN4LCBwM3ksIHA0eCwgcDR5KSB7XG4gICAgdmFyIHggPSBwNHggKiBDQjEocGN0KSArIHAzeCAqIENCMihwY3QpICsgcDJ4ICogQ0IzKHBjdCkgKyBwMXggKiBDQjQocGN0KTtcbiAgICB2YXIgeSA9IHA0eSAqIENCMShwY3QpICsgcDN5ICogQ0IyKHBjdCkgKyBwMnkgKiBDQjMocGN0KSArIHAxeSAqIENCNChwY3QpO1xuICAgIHJldHVybiB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH07XG4gIH1cblxuICBnZXRQb2ludE9uUXVhZHJhdGljQmV6aWVyKHBjdCwgcDF4LCBwMXksIHAyeCwgcDJ5LCBwM3gsIHAzeSkge1xuICAgIHZhciB4ID0gcDN4ICogUUIxKHBjdCkgKyBwMnggKiBRQjIocGN0KSArIHAxeCAqIFFCMyhwY3QpO1xuICAgIHZhciB5ID0gcDN5ICogUUIxKHBjdCkgKyBwMnkgKiBRQjIocGN0KSArIHAxeSAqIFFCMyhwY3QpO1xuICAgIHJldHVybiB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH07XG4gIH1cblxuICBnZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhjeCwgY3ksIHJ4LCByeSwgdGhldGEsIHBzaSkge1xuICAgIHZhciBjb3NQc2kgPSBNYXRoLmNvcyhwc2kpO1xuICAgIHZhciBzaW5Qc2kgPSBNYXRoLnNpbihwc2kpO1xuICAgIHZhciBwdCA9IHtcbiAgICAgIHg6IHJ4ICogTWF0aC5jb3ModGhldGEpLFxuICAgICAgeTogcnkgKiBNYXRoLnNpbih0aGV0YSlcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICB4OiBjeCArIChwdC54ICogY29zUHNpIC0gcHQueSAqIHNpblBzaSksXG4gICAgICB5OiBjeSArIChwdC54ICogc2luUHNpICsgcHQueSAqIGNvc1BzaSlcbiAgICB9O1xuICB9IC8vIFRPRE8gbmVlZCBzb21lIG9wdGltaXNhdGlvbnMuIHBvc3NpYmx5IGJ1aWxkIGNhY2hlIG9ubHkgZm9yIGN1cnZlZCBzZWdtZW50cz9cblxuXG4gIGJ1aWxkRXF1aWRpc3RhbnRDYWNoZShpbnB1dFN0ZXAsIGlucHV0UHJlY2lzaW9uKSB7XG4gICAgdmFyIGZ1bGxMZW4gPSB0aGlzLmdldFBhdGhMZW5ndGgoKTtcbiAgICB2YXIgcHJlY2lzaW9uID0gaW5wdXRQcmVjaXNpb24gfHwgMC4yNTsgLy8gYWNjdXJhY3kgdnMgcGVyZm9ybWFuY2VcblxuICAgIHZhciBzdGVwID0gaW5wdXRTdGVwIHx8IGZ1bGxMZW4gLyAxMDA7XG5cbiAgICBpZiAoIXRoaXMuZXF1aWRpc3RhbnRDYWNoZSB8fCB0aGlzLmVxdWlkaXN0YW50Q2FjaGUuc3RlcCAhPT0gc3RlcCB8fCB0aGlzLmVxdWlkaXN0YW50Q2FjaGUucHJlY2lzaW9uICE9PSBwcmVjaXNpb24pIHtcbiAgICAgIC8vIFByZXBhcmUgY2FjaGVcbiAgICAgIHRoaXMuZXF1aWRpc3RhbnRDYWNoZSA9IHtcbiAgICAgICAgc3RlcCxcbiAgICAgICAgcHJlY2lzaW9uLFxuICAgICAgICBwb2ludHM6IFtdXG4gICAgICB9OyAvLyBDYWxjdWxhdGUgcG9pbnRzXG5cbiAgICAgIHZhciBzID0gMDtcblxuICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPD0gZnVsbExlbjsgbCArPSBwcmVjaXNpb24pIHtcbiAgICAgICAgdmFyIHAwID0gdGhpcy5nZXRQb2ludE9uUGF0aChsKTtcbiAgICAgICAgdmFyIHAxID0gdGhpcy5nZXRQb2ludE9uUGF0aChsICsgcHJlY2lzaW9uKTtcblxuICAgICAgICBpZiAoIXAwIHx8ICFwMSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcyArPSB0aGlzLmdldExpbmVMZW5ndGgocDAueCwgcDAueSwgcDEueCwgcDEueSk7XG5cbiAgICAgICAgaWYgKHMgPj0gc3RlcCkge1xuICAgICAgICAgIHRoaXMuZXF1aWRpc3RhbnRDYWNoZS5wb2ludHMucHVzaCh7XG4gICAgICAgICAgICB4OiBwMC54LFxuICAgICAgICAgICAgeTogcDAueSxcbiAgICAgICAgICAgIGRpc3RhbmNlOiBsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcyAtPSBzdGVwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0RXF1aWRpc3RhbnRQb2ludE9uUGF0aCh0YXJnZXREaXN0YW5jZSwgc3RlcCwgcHJlY2lzaW9uKSB7XG4gICAgdGhpcy5idWlsZEVxdWlkaXN0YW50Q2FjaGUoc3RlcCwgcHJlY2lzaW9uKTtcblxuICAgIGlmICh0YXJnZXREaXN0YW5jZSA8IDAgfHwgdGFyZ2V0RGlzdGFuY2UgLSB0aGlzLmdldFBhdGhMZW5ndGgoKSA+IDAuMDAwMDUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBpZHggPSBNYXRoLnJvdW5kKHRhcmdldERpc3RhbmNlIC8gdGhpcy5nZXRQYXRoTGVuZ3RoKCkgKiAodGhpcy5lcXVpZGlzdGFudENhY2hlLnBvaW50cy5sZW5ndGggLSAxKSk7XG4gICAgcmV0dXJuIHRoaXMuZXF1aWRpc3RhbnRDYWNoZS5wb2ludHNbaWR4XSB8fCBudWxsO1xuICB9XG5cbn1cblxudmFyIGRhdGFVcmlSZWdleCA9IC9eXFxzKmRhdGE6KChbXi8sO10rXFwvW14vLDtdKykoPzo7KFteLDs9XSs9W14sOz1dKykpPyk/KD86OyhiYXNlNjQpKT8sKC4qKSQvaTtcbmNsYXNzIEltYWdlRWxlbWVudCBleHRlbmRzIFJlbmRlcmVkRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIHRoaXMudHlwZSA9ICdpbWFnZSc7XG4gICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcbiAgICB2YXIgaHJlZiA9IHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmdldFN0cmluZygpO1xuXG4gICAgaWYgKCFocmVmKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGlzU3ZnID0gaHJlZi5lbmRzV2l0aCgnLnN2ZycpIHx8IC9eXFxzKmRhdGE6aW1hZ2VcXC9zdmdcXCt4bWwvaS50ZXN0KGhyZWYpO1xuICAgIGRvY3VtZW50LmltYWdlcy5wdXNoKHRoaXMpO1xuXG4gICAgaWYgKCFpc1N2Zykge1xuICAgICAgdm9pZCB0aGlzLmxvYWRJbWFnZShocmVmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm9pZCB0aGlzLmxvYWRTdmcoaHJlZik7XG4gICAgfVxuXG4gICAgdGhpcy5pc1N2ZyA9IGlzU3ZnO1xuICB9XG5cbiAgbG9hZEltYWdlKGhyZWYpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgaW1hZ2UgPSB5aWVsZCBfdGhpcy5kb2N1bWVudC5jcmVhdGVJbWFnZShocmVmKTtcbiAgICAgICAgX3RoaXMuaW1hZ2UgPSBpbWFnZTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igd2hpbGUgbG9hZGluZyBpbWFnZSBcXFwiXCIuY29uY2F0KGhyZWYsIFwiXFxcIjpcIiksIGVycik7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmxvYWRlZCA9IHRydWU7XG4gICAgfSkoKTtcbiAgfVxuXG4gIGxvYWRTdmcoaHJlZikge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBkYXRhVXJpUmVnZXguZXhlYyhocmVmKTtcblxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHZhciBkYXRhID0gbWF0Y2hbNV07XG5cbiAgICAgICAgaWYgKG1hdGNoWzRdID09PSAnYmFzZTY0Jykge1xuICAgICAgICAgIF90aGlzMi5pbWFnZSA9IGF0b2IoZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMyLmltYWdlID0gZGVjb2RlVVJJQ29tcG9uZW50KGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciByZXNwb25zZSA9IHlpZWxkIF90aGlzMi5kb2N1bWVudC5mZXRjaChocmVmKTtcbiAgICAgICAgICB2YXIgc3ZnID0geWllbGQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgIF90aGlzMi5pbWFnZSA9IHN2ZztcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHdoaWxlIGxvYWRpbmcgaW1hZ2UgXFxcIlwiLmNvbmNhdChocmVmLCBcIlxcXCI6XCIpLCBlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF90aGlzMi5sb2FkZWQgPSB0cnVlO1xuICAgIH0pKCk7XG4gIH1cblxuICByZW5kZXJDaGlsZHJlbihjdHgpIHtcbiAgICB2YXIge1xuICAgICAgZG9jdW1lbnQsXG4gICAgICBpbWFnZSxcbiAgICAgIGxvYWRlZFxuICAgIH0gPSB0aGlzO1xuICAgIHZhciB4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3gnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgeSA9IHRoaXMuZ2V0QXR0cmlidXRlKCd5JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgdmFyIHdpZHRoID0gdGhpcy5nZXRTdHlsZSgnd2lkdGgnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXRTdHlsZSgnaGVpZ2h0JykuZ2V0UGl4ZWxzKCd5Jyk7XG5cbiAgICBpZiAoIWxvYWRlZCB8fCAhaW1hZ2UgfHwgIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XG5cbiAgICBpZiAodGhpcy5pc1N2Zykge1xuICAgICAgdmFyIHN1YkRvY3VtZW50ID0gZG9jdW1lbnQuY2FudmcuZm9ya1N0cmluZyhjdHgsIHRoaXMuaW1hZ2UsIHtcbiAgICAgICAgaWdub3JlTW91c2U6IHRydWUsXG4gICAgICAgIGlnbm9yZUFuaW1hdGlvbjogdHJ1ZSxcbiAgICAgICAgaWdub3JlRGltZW5zaW9uczogdHJ1ZSxcbiAgICAgICAgaWdub3JlQ2xlYXI6IHRydWUsXG4gICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgIHNjYWxlV2lkdGg6IHdpZHRoLFxuICAgICAgICBzY2FsZUhlaWdodDogaGVpZ2h0XG4gICAgICB9KTtcbiAgICAgIHN1YkRvY3VtZW50LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5wYXJlbnQgPSB0aGlzO1xuICAgICAgdm9pZCBzdWJEb2N1bWVudC5yZW5kZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9pbWFnZSA9IHRoaXMuaW1hZ2U7XG4gICAgICBkb2N1bWVudC5zZXRWaWV3Qm94KHtcbiAgICAgICAgY3R4LFxuICAgICAgICBhc3BlY3RSYXRpbzogdGhpcy5nZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nKS5nZXRTdHJpbmcoKSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGRlc2lyZWRXaWR0aDogX2ltYWdlLndpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGRlc2lyZWRIZWlnaHQ6IF9pbWFnZS5oZWlnaHRcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5sb2FkZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBfaW1hZ2UuY29tcGxldGUgPT09ICd1bmRlZmluZWQnIHx8IF9pbWFnZS5jb21wbGV0ZSkge1xuICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoX2ltYWdlLCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cblxuICBnZXRCb3VuZGluZ0JveCgpIHtcbiAgICB2YXIgeCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd4JykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIHkgPSB0aGlzLmdldEF0dHJpYnV0ZSgneScpLmdldFBpeGVscygneScpO1xuICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIGhlaWdodCA9IHRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcpLmdldFBpeGVscygneScpO1xuICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3goeCwgeSwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgfVxuXG59XG5cbmNsYXNzIFN5bWJvbEVsZW1lbnQgZXh0ZW5kcyBSZW5kZXJlZEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdzeW1ib2wnO1xuICB9XG5cbiAgcmVuZGVyKF8pIHsvLyBOTyBSRU5ERVJcbiAgfVxuXG59XG5cbmNsYXNzIFNWR0ZvbnRMb2FkZXIge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCkge1xuICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuICAgIGRvY3VtZW50LmZvbnRzLnB1c2godGhpcyk7XG4gIH1cblxuICBsb2FkKGZvbnRGYW1pbHksIHVybCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgZG9jdW1lbnRcbiAgICAgICAgfSA9IF90aGlzO1xuICAgICAgICB2YXIgc3ZnRG9jdW1lbnQgPSB5aWVsZCBkb2N1bWVudC5jYW52Zy5wYXJzZXIubG9hZCh1cmwpO1xuICAgICAgICB2YXIgZm9udHMgPSBzdmdEb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZm9udCcpO1xuICAgICAgICBBcnJheS5mcm9tKGZvbnRzKS5mb3JFYWNoKGZvbnROb2RlID0+IHtcbiAgICAgICAgICB2YXIgZm9udCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZm9udE5vZGUpO1xuICAgICAgICAgIGRvY3VtZW50LmRlZmluaXRpb25zW2ZvbnRGYW1pbHldID0gZm9udDtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHdoaWxlIGxvYWRpbmcgZm9udCBcXFwiXCIuY29uY2F0KHVybCwgXCJcXFwiOlwiKSwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMubG9hZGVkID0gdHJ1ZTtcbiAgICB9KSgpO1xuICB9XG5cbn1cblxuY2xhc3MgU3R5bGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIHRoaXMudHlwZSA9ICdzdHlsZSc7XG4gICAgdmFyIGNzcyA9IGNvbXByZXNzU3BhY2VzKEFycmF5LmZyb20obm9kZS5jaGlsZE5vZGVzKSAvLyBORUVEIFRFU1RcbiAgICAubWFwKF8gPT4gXy50ZXh0Q29udGVudCkuam9pbignJykucmVwbGFjZSgvKFxcL1xcKihbXipdfFtcXHJcXG5dfChcXCorKFteKi9dfFtcXHJcXG5dKSkpKlxcKitcXC8pfCheW1xcc10qXFwvXFwvLiopL2dtLCAnJykgLy8gcmVtb3ZlIGNvbW1lbnRzXG4gICAgLnJlcGxhY2UoL0BpbXBvcnQuKjsvZywgJycpIC8vIHJlbW92ZSBpbXBvcnRzXG4gICAgKTtcbiAgICB2YXIgY3NzRGVmcyA9IGNzcy5zcGxpdCgnfScpO1xuICAgIGNzc0RlZnMuZm9yRWFjaChfID0+IHtcbiAgICAgIHZhciBkZWYgPSBfLnRyaW0oKTtcblxuICAgICAgaWYgKCFkZWYpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3NzUGFydHMgPSBkZWYuc3BsaXQoJ3snKTtcbiAgICAgIHZhciBjc3NDbGFzc2VzID0gY3NzUGFydHNbMF0uc3BsaXQoJywnKTtcbiAgICAgIHZhciBjc3NQcm9wcyA9IGNzc1BhcnRzWzFdLnNwbGl0KCc7Jyk7XG4gICAgICBjc3NDbGFzc2VzLmZvckVhY2goXyA9PiB7XG4gICAgICAgIHZhciBjc3NDbGFzcyA9IF8udHJpbSgpO1xuXG4gICAgICAgIGlmICghY3NzQ2xhc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJvcHMgPSBkb2N1bWVudC5zdHlsZXNbY3NzQ2xhc3NdIHx8IHt9O1xuICAgICAgICBjc3NQcm9wcy5mb3JFYWNoKGNzc1Byb3AgPT4ge1xuICAgICAgICAgIHZhciBwcm9wID0gY3NzUHJvcC5pbmRleE9mKCc6Jyk7XG4gICAgICAgICAgdmFyIG5hbWUgPSBjc3NQcm9wLnN1YnN0cigwLCBwcm9wKS50cmltKCk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gY3NzUHJvcC5zdWJzdHIocHJvcCArIDEsIGNzc1Byb3AubGVuZ3RoIC0gcHJvcCkudHJpbSgpO1xuXG4gICAgICAgICAgaWYgKG5hbWUgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIHByb3BzW25hbWVdID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZG9jdW1lbnQuc3R5bGVzW2Nzc0NsYXNzXSA9IHByb3BzO1xuICAgICAgICBkb2N1bWVudC5zdHlsZXNTcGVjaWZpY2l0eVtjc3NDbGFzc10gPSBnZXRTZWxlY3RvclNwZWNpZmljaXR5KGNzc0NsYXNzKTtcblxuICAgICAgICBpZiAoY3NzQ2xhc3MgPT09ICdAZm9udC1mYWNlJykge1xuICAgICAgICAgIC8vICAmJiAhbm9kZUVudlxuICAgICAgICAgIHZhciBmb250RmFtaWx5ID0gcHJvcHNbJ2ZvbnQtZmFtaWx5J10uZ2V0U3RyaW5nKCkucmVwbGFjZSgvXCJ8Jy9nLCAnJyk7XG4gICAgICAgICAgdmFyIHNyY3MgPSBwcm9wcy5zcmMuZ2V0U3RyaW5nKCkuc3BsaXQoJywnKTtcbiAgICAgICAgICBzcmNzLmZvckVhY2goc3JjID0+IHtcbiAgICAgICAgICAgIGlmIChzcmMuaW5kZXhPZignZm9ybWF0KFwic3ZnXCIpJykgPiAwKSB7XG4gICAgICAgICAgICAgIHZhciB1cmwgPSBwYXJzZUV4dGVybmFsVXJsKHNyYyk7XG5cbiAgICAgICAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgICAgICAgIHZvaWQgbmV3IFNWR0ZvbnRMb2FkZXIoZG9jdW1lbnQpLmxvYWQoZm9udEZhbWlseSwgdXJsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG59XG5TdHlsZUVsZW1lbnQucGFyc2VFeHRlcm5hbFVybCA9IHBhcnNlRXh0ZXJuYWxVcmw7XG5cbmNsYXNzIFVzZUVsZW1lbnQgZXh0ZW5kcyBSZW5kZXJlZEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICd1c2UnO1xuICB9XG5cbiAgc2V0Q29udGV4dChjdHgpIHtcbiAgICBzdXBlci5zZXRDb250ZXh0KGN0eCk7XG4gICAgdmFyIHhBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3gnKTtcbiAgICB2YXIgeUF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgneScpO1xuXG4gICAgaWYgKHhBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgIGN0eC50cmFuc2xhdGUoeEF0dHIuZ2V0UGl4ZWxzKCd4JyksIDApO1xuICAgIH1cblxuICAgIGlmICh5QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICBjdHgudHJhbnNsYXRlKDAsIHlBdHRyLmdldFBpeGVscygneScpKTtcbiAgICB9XG4gIH1cblxuICBwYXRoKGN0eCkge1xuICAgIHZhciB7XG4gICAgICBlbGVtZW50XG4gICAgfSA9IHRoaXM7XG5cbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgZWxlbWVudC5wYXRoKGN0eCk7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyQ2hpbGRyZW4oY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIGRvY3VtZW50LFxuICAgICAgZWxlbWVudFxuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciB0ZW1wU3ZnID0gZWxlbWVudDtcblxuICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgLy8gcmVuZGVyIG1lIHVzaW5nIGEgdGVtcG9yYXJ5IHN2ZyBlbGVtZW50IGluIHN5bWJvbCBjYXNlcyAoaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3N0cnVjdC5odG1sI1VzZUVsZW1lbnQpXG4gICAgICAgIHRlbXBTdmcgPSBuZXcgU1ZHRWxlbWVudChkb2N1bWVudCwgbnVsbCk7XG4gICAgICAgIHRlbXBTdmcuYXR0cmlidXRlcy52aWV3Qm94ID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAndmlld0JveCcsIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd2aWV3Qm94JykuZ2V0U3RyaW5nKCkpO1xuICAgICAgICB0ZW1wU3ZnLmF0dHJpYnV0ZXMucHJlc2VydmVBc3BlY3RSYXRpbyA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCBlbGVtZW50LmdldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycpLmdldFN0cmluZygpKTtcbiAgICAgICAgdGVtcFN2Zy5hdHRyaWJ1dGVzLm92ZXJmbG93ID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnb3ZlcmZsb3cnLCBlbGVtZW50LmdldEF0dHJpYnV0ZSgnb3ZlcmZsb3cnKS5nZXRTdHJpbmcoKSk7XG4gICAgICAgIHRlbXBTdmcuY2hpbGRyZW4gPSBlbGVtZW50LmNoaWxkcmVuOyAvLyBlbGVtZW50IGlzIHN0aWxsIHRoZSBwYXJlbnQgb2YgdGhlIGNoaWxkcmVuXG5cbiAgICAgICAgZWxlbWVudC5zdHlsZXMub3BhY2l0eSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ29wYWNpdHknLCB0aGlzLmNhbGN1bGF0ZU9wYWNpdHkoKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZW1wU3ZnLnR5cGUgPT09ICdzdmcnKSB7XG4gICAgICAgIHZhciB3aWR0aFN0eWxlID0gdGhpcy5nZXRTdHlsZSgnd2lkdGgnLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIHZhciBoZWlnaHRTdHlsZSA9IHRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcsIGZhbHNlLCB0cnVlKTsgLy8gaWYgc3ltYm9sIG9yIHN2ZywgaW5oZXJpdCB3aWR0aC9oZWlnaHQgZnJvbSBtZVxuXG4gICAgICAgIGlmICh3aWR0aFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICB0ZW1wU3ZnLmF0dHJpYnV0ZXMud2lkdGggPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd3aWR0aCcsIHdpZHRoU3R5bGUuZ2V0U3RyaW5nKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhlaWdodFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICB0ZW1wU3ZnLmF0dHJpYnV0ZXMuaGVpZ2h0ID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnaGVpZ2h0JywgaGVpZ2h0U3R5bGUuZ2V0U3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBvbGRQYXJlbnQgPSB0ZW1wU3ZnLnBhcmVudDtcbiAgICAgIHRlbXBTdmcucGFyZW50ID0gdGhpcztcbiAgICAgIHRlbXBTdmcucmVuZGVyKGN0eCk7XG4gICAgICB0ZW1wU3ZnLnBhcmVudCA9IG9sZFBhcmVudDtcbiAgICB9XG4gIH1cblxuICBnZXRCb3VuZGluZ0JveChjdHgpIHtcbiAgICB2YXIge1xuICAgICAgZWxlbWVudFxuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50LmdldEJvdW5kaW5nQm94KGN0eCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBlbGVtZW50VHJhbnNmb3JtKCkge1xuICAgIHZhciB7XG4gICAgICBkb2N1bWVudCxcbiAgICAgIGVsZW1lbnRcbiAgICB9ID0gdGhpcztcbiAgICByZXR1cm4gVHJhbnNmb3JtLmZyb21FbGVtZW50KGRvY3VtZW50LCBlbGVtZW50KTtcbiAgfVxuXG4gIGdldCBlbGVtZW50KCkge1xuICAgIGlmICghdGhpcy5jYWNoZWRFbGVtZW50KSB7XG4gICAgICB0aGlzLmNhY2hlZEVsZW1lbnQgPSB0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXREZWZpbml0aW9uKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2FjaGVkRWxlbWVudDtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGltR2V0KGltZywgeCwgeSwgd2lkdGgsIF9oZWlnaHQsIHJnYmEpIHtcbiAgcmV0dXJuIGltZ1t5ICogd2lkdGggKiA0ICsgeCAqIDQgKyByZ2JhXTtcbn1cblxuZnVuY3Rpb24gaW1TZXQoaW1nLCB4LCB5LCB3aWR0aCwgX2hlaWdodCwgcmdiYSwgdmFsKSB7XG4gIGltZ1t5ICogd2lkdGggKiA0ICsgeCAqIDQgKyByZ2JhXSA9IHZhbDtcbn1cblxuZnVuY3Rpb24gbShtYXRyaXgsIGksIHYpIHtcbiAgdmFyIG1pID0gbWF0cml4W2ldO1xuICByZXR1cm4gbWkgKiB2O1xufVxuXG5mdW5jdGlvbiBjKGEsIG0xLCBtMiwgbTMpIHtcbiAgcmV0dXJuIG0xICsgTWF0aC5jb3MoYSkgKiBtMiArIE1hdGguc2luKGEpICogbTM7XG59XG5cbmNsYXNzIEZlQ29sb3JNYXRyaXhFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIHRoaXMudHlwZSA9ICdmZUNvbG9yTWF0cml4JztcbiAgICB2YXIgbWF0cml4ID0gdG9OdW1iZXJzKHRoaXMuZ2V0QXR0cmlidXRlKCd2YWx1ZXMnKS5nZXRTdHJpbmcoKSk7XG5cbiAgICBzd2l0Y2ggKHRoaXMuZ2V0QXR0cmlidXRlKCd0eXBlJykuZ2V0U3RyaW5nKCdtYXRyaXgnKSkge1xuICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2ZpbHRlcnMuaHRtbCNmZUNvbG9yTWF0cml4RWxlbWVudFxuICAgICAgY2FzZSAnc2F0dXJhdGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHMgPSBtYXRyaXhbMF07XG4gICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgYXJyYXktZWxlbWVudC1uZXdsaW5lICovXG5cbiAgICAgICAgICBtYXRyaXggPSBbMC4yMTMgKyAwLjc4NyAqIHMsIDAuNzE1IC0gMC43MTUgKiBzLCAwLjA3MiAtIDAuMDcyICogcywgMCwgMCwgMC4yMTMgLSAwLjIxMyAqIHMsIDAuNzE1ICsgMC4yODUgKiBzLCAwLjA3MiAtIDAuMDcyICogcywgMCwgMCwgMC4yMTMgLSAwLjIxMyAqIHMsIDAuNzE1IC0gMC43MTUgKiBzLCAwLjA3MiArIDAuOTI4ICogcywgMCwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMCwgMV07XG4gICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBhcnJheS1lbGVtZW50LW5ld2xpbmUgKi9cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2h1ZVJvdGF0ZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgYSA9IG1hdHJpeFswXSAqIE1hdGguUEkgLyAxODAuMDtcbiAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBhcnJheS1lbGVtZW50LW5ld2xpbmUgKi9cblxuICAgICAgICAgIG1hdHJpeCA9IFtjKGEsIDAuMjEzLCAwLjc4NywgLTAuMjEzKSwgYyhhLCAwLjcxNSwgLTAuNzE1LCAtMC43MTUpLCBjKGEsIDAuMDcyLCAtMC4wNzIsIDAuOTI4KSwgMCwgMCwgYyhhLCAwLjIxMywgLTAuMjEzLCAwLjE0MyksIGMoYSwgMC43MTUsIDAuMjg1LCAwLjE0MCksIGMoYSwgMC4wNzIsIC0wLjA3MiwgLTAuMjgzKSwgMCwgMCwgYyhhLCAwLjIxMywgLTAuMjEzLCAtMC43ODcpLCBjKGEsIDAuNzE1LCAtMC43MTUsIDAuNzE1KSwgYyhhLCAwLjA3MiwgMC45MjgsIDAuMDcyKSwgMCwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMCwgMV07XG4gICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBhcnJheS1lbGVtZW50LW5ld2xpbmUgKi9cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2x1bWluYW5jZVRvQWxwaGEnOlxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBhcnJheS1lbGVtZW50LW5ld2xpbmUgKi9cbiAgICAgICAgbWF0cml4ID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAuMjEyNSwgMC43MTU0LCAwLjA3MjEsIDAsIDAsIDAsIDAsIDAsIDAsIDFdO1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIGFycmF5LWVsZW1lbnQtbmV3bGluZSAqL1xuXG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMubWF0cml4ID0gbWF0cml4O1xuICAgIHRoaXMuaW5jbHVkZU9wYWNpdHkgPSB0aGlzLmdldEF0dHJpYnV0ZSgnaW5jbHVkZU9wYWNpdHknKS5oYXNWYWx1ZSgpO1xuICB9XG5cbiAgYXBwbHkoY3R4LCBfeCwgX3ksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAvLyBhc3N1bWluZyB4PT0wICYmIHk9PTAgZm9yIG5vd1xuICAgIHZhciB7XG4gICAgICBpbmNsdWRlT3BhY2l0eSxcbiAgICAgIG1hdHJpeFxuICAgIH0gPSB0aGlzO1xuICAgIHZhciBzcmNEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICB2YXIgciA9IGltR2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMCk7XG4gICAgICAgIHZhciBnID0gaW1HZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAxKTtcbiAgICAgICAgdmFyIGIgPSBpbUdldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDIpO1xuICAgICAgICB2YXIgYSA9IGltR2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMyk7XG4gICAgICAgIHZhciBuciA9IG0obWF0cml4LCAwLCByKSArIG0obWF0cml4LCAxLCBnKSArIG0obWF0cml4LCAyLCBiKSArIG0obWF0cml4LCAzLCBhKSArIG0obWF0cml4LCA0LCAxKTtcbiAgICAgICAgdmFyIG5nID0gbShtYXRyaXgsIDUsIHIpICsgbShtYXRyaXgsIDYsIGcpICsgbShtYXRyaXgsIDcsIGIpICsgbShtYXRyaXgsIDgsIGEpICsgbShtYXRyaXgsIDksIDEpO1xuICAgICAgICB2YXIgbmIgPSBtKG1hdHJpeCwgMTAsIHIpICsgbShtYXRyaXgsIDExLCBnKSArIG0obWF0cml4LCAxMiwgYikgKyBtKG1hdHJpeCwgMTMsIGEpICsgbShtYXRyaXgsIDE0LCAxKTtcbiAgICAgICAgdmFyIG5hID0gbShtYXRyaXgsIDE1LCByKSArIG0obWF0cml4LCAxNiwgZykgKyBtKG1hdHJpeCwgMTcsIGIpICsgbShtYXRyaXgsIDE4LCBhKSArIG0obWF0cml4LCAxOSwgMSk7XG5cbiAgICAgICAgaWYgKGluY2x1ZGVPcGFjaXR5KSB7XG4gICAgICAgICAgbnIgPSAwO1xuICAgICAgICAgIG5nID0gMDtcbiAgICAgICAgICBuYiA9IDA7XG4gICAgICAgICAgbmEgKj0gYSAvIDI1NTtcbiAgICAgICAgfVxuXG4gICAgICAgIGltU2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMCwgbnIpO1xuICAgICAgICBpbVNldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDEsIG5nKTtcbiAgICAgICAgaW1TZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAyLCBuYik7XG4gICAgICAgIGltU2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMywgbmEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgY3R4LnB1dEltYWdlRGF0YShzcmNEYXRhLCAwLCAwKTtcbiAgfVxuXG59XG5cbmNsYXNzIE1hc2tFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ21hc2snO1xuICB9XG5cbiAgYXBwbHkoY3R4LCBlbGVtZW50KSB7XG4gICAgdmFyIHtcbiAgICAgIGRvY3VtZW50XG4gICAgfSA9IHRoaXM7IC8vIHJlbmRlciBhcyB0ZW1wIHN2Z1xuXG4gICAgdmFyIHggPSB0aGlzLmdldEF0dHJpYnV0ZSgneCcpLmdldFBpeGVscygneCcpO1xuICAgIHZhciB5ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3knKS5nZXRQaXhlbHMoJ3knKTtcbiAgICB2YXIgd2lkdGggPSB0aGlzLmdldFN0eWxlKCd3aWR0aCcpLmdldFBpeGVscygneCcpO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldFN0eWxlKCdoZWlnaHQnKS5nZXRQaXhlbHMoJ3knKTtcblxuICAgIGlmICghd2lkdGggJiYgIWhlaWdodCkge1xuICAgICAgdmFyIGJvdW5kaW5nQm94ID0gbmV3IEJvdW5kaW5nQm94KCk7XG4gICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICBib3VuZGluZ0JveC5hZGRCb3VuZGluZ0JveChjaGlsZC5nZXRCb3VuZGluZ0JveChjdHgpKTtcbiAgICAgIH0pO1xuICAgICAgeCA9IE1hdGguZmxvb3IoYm91bmRpbmdCb3gueDEpO1xuICAgICAgeSA9IE1hdGguZmxvb3IoYm91bmRpbmdCb3gueTEpO1xuICAgICAgd2lkdGggPSBNYXRoLmZsb29yKGJvdW5kaW5nQm94LndpZHRoKTtcbiAgICAgIGhlaWdodCA9IE1hdGguZmxvb3IoYm91bmRpbmdCb3guaGVpZ2h0KTtcbiAgICB9XG5cbiAgICB2YXIgaWdub3JlZFN0eWxlcyA9IHRoaXMucmVtb3ZlU3R5bGVzKGVsZW1lbnQsIE1hc2tFbGVtZW50Lmlnbm9yZVN0eWxlcyk7XG4gICAgdmFyIG1hc2tDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVDYW52YXMoeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICB2YXIgbWFza0N0eCA9IG1hc2tDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBkb2N1bWVudC5zY3JlZW4uc2V0RGVmYXVsdHMobWFza0N0eCk7XG4gICAgdGhpcy5yZW5kZXJDaGlsZHJlbihtYXNrQ3R4KTsgLy8gY29udmVydCBtYXNrIHRvIGFscGhhIHdpdGggYSBmYWtlIG5vZGVcbiAgICAvLyBUT0RPOiByZWZhY3RvciBvdXQgYXBwbHkgZnJvbSBmZUNvbG9yTWF0cml4XG5cbiAgICBuZXcgRmVDb2xvck1hdHJpeEVsZW1lbnQoZG9jdW1lbnQsIHtcbiAgICAgIG5vZGVUeXBlOiAxLFxuICAgICAgY2hpbGROb2RlczogW10sXG4gICAgICBhdHRyaWJ1dGVzOiBbe1xuICAgICAgICBub2RlTmFtZTogJ3R5cGUnLFxuICAgICAgICB2YWx1ZTogJ2x1bWluYW5jZVRvQWxwaGEnXG4gICAgICB9LCB7XG4gICAgICAgIG5vZGVOYW1lOiAnaW5jbHVkZU9wYWNpdHknLFxuICAgICAgICB2YWx1ZTogJ3RydWUnXG4gICAgICB9XVxuICAgIH0pLmFwcGx5KG1hc2tDdHgsIDAsIDAsIHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgdmFyIHRtcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUNhbnZhcyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgIHZhciB0bXBDdHggPSB0bXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBkb2N1bWVudC5zY3JlZW4uc2V0RGVmYXVsdHModG1wQ3R4KTtcbiAgICBlbGVtZW50LnJlbmRlcih0bXBDdHgpO1xuICAgIHRtcEN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24taW4nO1xuICAgIHRtcEN0eC5maWxsU3R5bGUgPSBtYXNrQ3R4LmNyZWF0ZVBhdHRlcm4obWFza0NhbnZhcywgJ25vLXJlcGVhdCcpO1xuICAgIHRtcEN0eC5maWxsUmVjdCgwLCAwLCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgIGN0eC5maWxsU3R5bGUgPSB0bXBDdHguY3JlYXRlUGF0dGVybih0bXBDYW52YXMsICduby1yZXBlYXQnKTtcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTsgLy8gcmVhc3NpZ24gbWFza1xuXG4gICAgdGhpcy5yZXN0b3JlU3R5bGVzKGVsZW1lbnQsIGlnbm9yZWRTdHlsZXMpO1xuICB9XG5cbiAgcmVuZGVyKF8pIHsvLyBOTyBSRU5ERVJcbiAgfVxuXG59XG5NYXNrRWxlbWVudC5pZ25vcmVTdHlsZXMgPSBbJ21hc2snLCAndHJhbnNmb3JtJywgJ2NsaXAtcGF0aCddO1xuXG52YXIgbm9vcCA9ICgpID0+IHsvLyBOT09QXG59O1xuXG5jbGFzcyBDbGlwUGF0aEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAnY2xpcFBhdGgnO1xuICB9XG5cbiAgYXBwbHkoY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIGRvY3VtZW50XG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIGNvbnRleHRQcm90byA9IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YoY3R4KTtcbiAgICB2YXIge1xuICAgICAgYmVnaW5QYXRoLFxuICAgICAgY2xvc2VQYXRoXG4gICAgfSA9IGN0eDtcblxuICAgIGlmIChjb250ZXh0UHJvdG8pIHtcbiAgICAgIGNvbnRleHRQcm90by5iZWdpblBhdGggPSBub29wO1xuICAgICAgY29udGV4dFByb3RvLmNsb3NlUGF0aCA9IG5vb3A7XG4gICAgfVxuXG4gICAgUmVmbGVjdC5hcHBseShiZWdpblBhdGgsIGN0eCwgW10pO1xuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICBpZiAodHlwZW9mIGNoaWxkLnBhdGggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHRyYW5zZm9ybSA9IHR5cGVvZiBjaGlsZC5lbGVtZW50VHJhbnNmb3JtICE9PSAndW5kZWZpbmVkJyA/IGNoaWxkLmVsZW1lbnRUcmFuc2Zvcm0oKSA6IG51bGw7IC8vIGhhbmRsZSA8dXNlIC8+XG5cbiAgICAgIGlmICghdHJhbnNmb3JtKSB7XG4gICAgICAgIHRyYW5zZm9ybSA9IFRyYW5zZm9ybS5mcm9tRWxlbWVudChkb2N1bWVudCwgY2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIHRyYW5zZm9ybS5hcHBseShjdHgpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZC5wYXRoKGN0eCk7XG5cbiAgICAgIGlmIChjb250ZXh0UHJvdG8pIHtcbiAgICAgICAgY29udGV4dFByb3RvLmNsb3NlUGF0aCA9IGNsb3NlUGF0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICB0cmFuc2Zvcm0udW5hcHBseShjdHgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFJlZmxlY3QuYXBwbHkoY2xvc2VQYXRoLCBjdHgsIFtdKTtcbiAgICBjdHguY2xpcCgpO1xuXG4gICAgaWYgKGNvbnRleHRQcm90bykge1xuICAgICAgY29udGV4dFByb3RvLmJlZ2luUGF0aCA9IGJlZ2luUGF0aDtcbiAgICAgIGNvbnRleHRQcm90by5jbG9zZVBhdGggPSBjbG9zZVBhdGg7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyKF8pIHsvLyBOTyBSRU5ERVJcbiAgfVxuXG59XG5cbmNsYXNzIEZpbHRlckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAnZmlsdGVyJztcbiAgfVxuXG4gIGFwcGx5KGN0eCwgZWxlbWVudCkge1xuICAgIC8vIHJlbmRlciBhcyB0ZW1wIHN2Z1xuICAgIHZhciB7XG4gICAgICBkb2N1bWVudCxcbiAgICAgIGNoaWxkcmVuXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIGJvdW5kaW5nQm94ID0gZWxlbWVudC5nZXRCb3VuZGluZ0JveChjdHgpO1xuXG4gICAgaWYgKCFib3VuZGluZ0JveCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBweCA9IDA7XG4gICAgdmFyIHB5ID0gMDtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIHZhciBlZmQgPSBjaGlsZC5leHRyYUZpbHRlckRpc3RhbmNlIHx8IDA7XG4gICAgICBweCA9IE1hdGgubWF4KHB4LCBlZmQpO1xuICAgICAgcHkgPSBNYXRoLm1heChweSwgZWZkKTtcbiAgICB9KTtcbiAgICB2YXIgd2lkdGggPSBNYXRoLmZsb29yKGJvdW5kaW5nQm94LndpZHRoKTtcbiAgICB2YXIgaGVpZ2h0ID0gTWF0aC5mbG9vcihib3VuZGluZ0JveC5oZWlnaHQpO1xuICAgIHZhciB0bXBDYW52YXNXaWR0aCA9IHdpZHRoICsgMiAqIHB4O1xuICAgIHZhciB0bXBDYW52YXNIZWlnaHQgPSBoZWlnaHQgKyAyICogcHk7XG5cbiAgICBpZiAodG1wQ2FudmFzV2lkdGggPCAxIHx8IHRtcENhbnZhc0hlaWdodCA8IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgeCA9IE1hdGguZmxvb3IoYm91bmRpbmdCb3gueCk7XG4gICAgdmFyIHkgPSBNYXRoLmZsb29yKGJvdW5kaW5nQm94LnkpO1xuICAgIHZhciBpZ25vcmVkU3R5bGVzID0gdGhpcy5yZW1vdmVTdHlsZXMoZWxlbWVudCwgRmlsdGVyRWxlbWVudC5pZ25vcmVTdHlsZXMpO1xuICAgIHZhciB0bXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVDYW52YXModG1wQ2FudmFzV2lkdGgsIHRtcENhbnZhc0hlaWdodCk7XG4gICAgdmFyIHRtcEN0eCA9IHRtcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGRvY3VtZW50LnNjcmVlbi5zZXREZWZhdWx0cyh0bXBDdHgpO1xuICAgIHRtcEN0eC50cmFuc2xhdGUoLXggKyBweCwgLXkgKyBweSk7XG4gICAgZWxlbWVudC5yZW5kZXIodG1wQ3R4KTsgLy8gYXBwbHkgZmlsdGVyc1xuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICBpZiAodHlwZW9mIGNoaWxkLmFwcGx5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNoaWxkLmFwcGx5KHRtcEN0eCwgMCwgMCwgdG1wQ2FudmFzV2lkdGgsIHRtcENhbnZhc0hlaWdodCk7XG4gICAgICB9XG4gICAgfSk7IC8vIHJlbmRlciBvbiBtZVxuXG4gICAgY3R4LmRyYXdJbWFnZSh0bXBDYW52YXMsIDAsIDAsIHRtcENhbnZhc1dpZHRoLCB0bXBDYW52YXNIZWlnaHQsIHggLSBweCwgeSAtIHB5LCB0bXBDYW52YXNXaWR0aCwgdG1wQ2FudmFzSGVpZ2h0KTtcbiAgICB0aGlzLnJlc3RvcmVTdHlsZXMoZWxlbWVudCwgaWdub3JlZFN0eWxlcyk7XG4gIH1cblxuICByZW5kZXIoXykgey8vIE5PIFJFTkRFUlxuICB9XG5cbn1cbkZpbHRlckVsZW1lbnQuaWdub3JlU3R5bGVzID0gWydmaWx0ZXInLCAndHJhbnNmb3JtJywgJ2NsaXAtcGF0aCddO1xuXG5jbGFzcyBGZURyb3BTaGFkb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIHRoaXMudHlwZSA9ICdmZURyb3BTaGFkb3cnO1xuICAgIHRoaXMuYWRkU3R5bGVzRnJvbVN0eWxlRGVmaW5pdGlvbigpO1xuICB9XG5cbiAgYXBwbHkoXywgX3gsIF95LCBfd2lkdGgsIF9oZWlnaHQpIHsvLyBUT0RPOiBpbXBsZW1lbnRcbiAgfVxuXG59XG5cbmNsYXNzIEZlTW9ycGhvbG9neUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAnZmVNb3JwaG9sb2d5JztcbiAgfVxuXG4gIGFwcGx5KF8sIF94LCBfeSwgX3dpZHRoLCBfaGVpZ2h0KSB7Ly8gVE9ETzogaW1wbGVtZW50XG4gIH1cblxufVxuXG5jbGFzcyBGZUNvbXBvc2l0ZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAnZmVDb21wb3NpdGUnO1xuICB9XG5cbiAgYXBwbHkoXywgX3gsIF95LCBfd2lkdGgsIF9oZWlnaHQpIHsvLyBUT0RPOiBpbXBsZW1lbnRcbiAgfVxuXG59XG5cbmNsYXNzIEZlR2F1c3NpYW5CbHVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLnR5cGUgPSAnZmVHYXVzc2lhbkJsdXInO1xuICAgIHRoaXMuYmx1clJhZGl1cyA9IE1hdGguZmxvb3IodGhpcy5nZXRBdHRyaWJ1dGUoJ3N0ZERldmlhdGlvbicpLmdldE51bWJlcigpKTtcbiAgICB0aGlzLmV4dHJhRmlsdGVyRGlzdGFuY2UgPSB0aGlzLmJsdXJSYWRpdXM7XG4gIH1cblxuICBhcHBseShjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIge1xuICAgICAgZG9jdW1lbnQsXG4gICAgICBibHVyUmFkaXVzXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIGJvZHkgPSBkb2N1bWVudC53aW5kb3cgPyBkb2N1bWVudC53aW5kb3cuZG9jdW1lbnQuYm9keSA6IG51bGw7XG4gICAgdmFyIGNhbnZhcyA9IGN0eC5jYW52YXM7IC8vIFN0YWNrQmx1ciByZXF1aXJlcyBjYW52YXMgYmUgb24gZG9jdW1lbnRcblxuICAgIGNhbnZhcy5pZCA9IGRvY3VtZW50LmdldFVuaXF1ZUlkKCk7XG5cbiAgICBpZiAoYm9keSkge1xuICAgICAgY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICBib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgfVxuXG4gICAgY2FudmFzUkdCQShjYW52YXMsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGJsdXJSYWRpdXMpO1xuXG4gICAgaWYgKGJvZHkpIHtcbiAgICAgIGJvZHkucmVtb3ZlQ2hpbGQoY2FudmFzKTtcbiAgICB9XG4gIH1cblxufVxuXG5jbGFzcyBUaXRsZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAndGl0bGUnO1xuICB9XG5cbn1cblxuY2xhc3MgRGVzY0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAnZGVzYyc7XG4gIH1cblxufVxuXG52YXIgZWxlbWVudHMgPSB7XG4gICdzdmcnOiBTVkdFbGVtZW50LFxuICAncmVjdCc6IFJlY3RFbGVtZW50LFxuICAnY2lyY2xlJzogQ2lyY2xlRWxlbWVudCxcbiAgJ2VsbGlwc2UnOiBFbGxpcHNlRWxlbWVudCxcbiAgJ2xpbmUnOiBMaW5lRWxlbWVudCxcbiAgJ3BvbHlsaW5lJzogUG9seWxpbmVFbGVtZW50LFxuICAncG9seWdvbic6IFBvbHlnb25FbGVtZW50LFxuICAncGF0aCc6IFBhdGhFbGVtZW50LFxuICAncGF0dGVybic6IFBhdHRlcm5FbGVtZW50LFxuICAnbWFya2VyJzogTWFya2VyRWxlbWVudCxcbiAgJ2RlZnMnOiBEZWZzRWxlbWVudCxcbiAgJ2xpbmVhckdyYWRpZW50JzogTGluZWFyR3JhZGllbnRFbGVtZW50LFxuICAncmFkaWFsR3JhZGllbnQnOiBSYWRpYWxHcmFkaWVudEVsZW1lbnQsXG4gICdzdG9wJzogU3RvcEVsZW1lbnQsXG4gICdhbmltYXRlJzogQW5pbWF0ZUVsZW1lbnQsXG4gICdhbmltYXRlQ29sb3InOiBBbmltYXRlQ29sb3JFbGVtZW50LFxuICAnYW5pbWF0ZVRyYW5zZm9ybSc6IEFuaW1hdGVUcmFuc2Zvcm1FbGVtZW50LFxuICAnZm9udCc6IEZvbnRFbGVtZW50LFxuICAnZm9udC1mYWNlJzogRm9udEZhY2VFbGVtZW50LFxuICAnbWlzc2luZy1nbHlwaCc6IE1pc3NpbmdHbHlwaEVsZW1lbnQsXG4gICdnbHlwaCc6IEdseXBoRWxlbWVudCxcbiAgJ3RleHQnOiBUZXh0RWxlbWVudCxcbiAgJ3RzcGFuJzogVFNwYW5FbGVtZW50LFxuICAndHJlZic6IFRSZWZFbGVtZW50LFxuICAnYSc6IEFFbGVtZW50LFxuICAndGV4dFBhdGgnOiBUZXh0UGF0aEVsZW1lbnQsXG4gICdpbWFnZSc6IEltYWdlRWxlbWVudCxcbiAgJ2cnOiBHRWxlbWVudCxcbiAgJ3N5bWJvbCc6IFN5bWJvbEVsZW1lbnQsXG4gICdzdHlsZSc6IFN0eWxlRWxlbWVudCxcbiAgJ3VzZSc6IFVzZUVsZW1lbnQsXG4gICdtYXNrJzogTWFza0VsZW1lbnQsXG4gICdjbGlwUGF0aCc6IENsaXBQYXRoRWxlbWVudCxcbiAgJ2ZpbHRlcic6IEZpbHRlckVsZW1lbnQsXG4gICdmZURyb3BTaGFkb3cnOiBGZURyb3BTaGFkb3dFbGVtZW50LFxuICAnZmVNb3JwaG9sb2d5JzogRmVNb3JwaG9sb2d5RWxlbWVudCxcbiAgJ2ZlQ29tcG9zaXRlJzogRmVDb21wb3NpdGVFbGVtZW50LFxuICAnZmVDb2xvck1hdHJpeCc6IEZlQ29sb3JNYXRyaXhFbGVtZW50LFxuICAnZmVHYXVzc2lhbkJsdXInOiBGZUdhdXNzaWFuQmx1ckVsZW1lbnQsXG4gICd0aXRsZSc6IFRpdGxlRWxlbWVudCxcbiAgJ2Rlc2MnOiBEZXNjRWxlbWVudFxufTtcblxuZnVuY3Rpb24gb3duS2V5cyQxKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQxKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkMShPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDEoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIHJldHVybiBjYW52YXM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUltYWdlKF94KSB7XG4gIHJldHVybiBfY3JlYXRlSW1hZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUltYWdlKCkge1xuICBfY3JlYXRlSW1hZ2UgPSBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKHNyYykge1xuICAgIHZhciBhbm9ueW1vdXNDcm9zc09yaWdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgdmFyIGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG5cbiAgICBpZiAoYW5vbnltb3VzQ3Jvc3NPcmlnaW4pIHtcbiAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gJ0Fub255bW91cyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGltYWdlLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgcmVzb2x2ZShpbWFnZSk7XG4gICAgICB9O1xuXG4gICAgICBpbWFnZS5vbmVycm9yID0gKF9ldmVudCwgX3NvdXJjZSwgX2xpbmVubywgX2NvbG5vLCBlcnJvcikgPT4ge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfTtcblxuICAgICAgaW1hZ2Uuc3JjID0gc3JjO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIF9jcmVhdGVJbWFnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5jbGFzcyBEb2N1bWVudCB7XG4gIGNvbnN0cnVjdG9yKGNhbnZnKSB7XG4gICAgdmFyIHtcbiAgICAgIHJvb3RFbVNpemUgPSAxMixcbiAgICAgIGVtU2l6ZSA9IDEyLFxuICAgICAgY3JlYXRlQ2FudmFzID0gRG9jdW1lbnQuY3JlYXRlQ2FudmFzLFxuICAgICAgY3JlYXRlSW1hZ2UgPSBEb2N1bWVudC5jcmVhdGVJbWFnZSxcbiAgICAgIGFub255bW91c0Nyb3NzT3JpZ2luXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdGhpcy5jYW52ZyA9IGNhbnZnO1xuICAgIHRoaXMuZGVmaW5pdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuc3R5bGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnN0eWxlc1NwZWNpZmljaXR5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmltYWdlcyA9IFtdO1xuICAgIHRoaXMuZm9udHMgPSBbXTtcbiAgICB0aGlzLmVtU2l6ZVN0YWNrID0gW107XG4gICAgdGhpcy51bmlxdWVJZCA9IDA7XG4gICAgdGhpcy5zY3JlZW4gPSBjYW52Zy5zY3JlZW47XG4gICAgdGhpcy5yb290RW1TaXplID0gcm9vdEVtU2l6ZTtcbiAgICB0aGlzLmVtU2l6ZSA9IGVtU2l6ZTtcbiAgICB0aGlzLmNyZWF0ZUNhbnZhcyA9IGNyZWF0ZUNhbnZhcztcbiAgICB0aGlzLmNyZWF0ZUltYWdlID0gdGhpcy5iaW5kQ3JlYXRlSW1hZ2UoY3JlYXRlSW1hZ2UsIGFub255bW91c0Nyb3NzT3JpZ2luKTtcbiAgICB0aGlzLnNjcmVlbi53YWl0KHRoaXMuaXNJbWFnZXNMb2FkZWQuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5zY3JlZW4ud2FpdCh0aGlzLmlzRm9udHNMb2FkZWQuYmluZCh0aGlzKSk7XG4gIH1cblxuICBiaW5kQ3JlYXRlSW1hZ2UoY3JlYXRlSW1hZ2UsIGFub255bW91c0Nyb3NzT3JpZ2luKSB7XG4gICAgaWYgKHR5cGVvZiBhbm9ueW1vdXNDcm9zc09yaWdpbiA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICByZXR1cm4gKHNvdXJjZSwgZm9yY2VBbm9ueW1vdXNDcm9zc09yaWdpbikgPT4gY3JlYXRlSW1hZ2Uoc291cmNlLCB0eXBlb2YgZm9yY2VBbm9ueW1vdXNDcm9zc09yaWdpbiA9PT0gJ2Jvb2xlYW4nID8gZm9yY2VBbm9ueW1vdXNDcm9zc09yaWdpbiA6IGFub255bW91c0Nyb3NzT3JpZ2luKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlSW1hZ2U7XG4gIH1cblxuICBnZXQgd2luZG93KCkge1xuICAgIHJldHVybiB0aGlzLnNjcmVlbi53aW5kb3c7XG4gIH1cblxuICBnZXQgZmV0Y2goKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NyZWVuLmZldGNoO1xuICB9XG5cbiAgZ2V0IGN0eCgpIHtcbiAgICByZXR1cm4gdGhpcy5zY3JlZW4uY3R4O1xuICB9XG5cbiAgZ2V0IGVtU2l6ZSgpIHtcbiAgICB2YXIge1xuICAgICAgZW1TaXplU3RhY2tcbiAgICB9ID0gdGhpcztcbiAgICByZXR1cm4gZW1TaXplU3RhY2tbZW1TaXplU3RhY2subGVuZ3RoIC0gMV07XG4gIH1cblxuICBzZXQgZW1TaXplKHZhbHVlKSB7XG4gICAgdmFyIHtcbiAgICAgIGVtU2l6ZVN0YWNrXG4gICAgfSA9IHRoaXM7XG4gICAgZW1TaXplU3RhY2sucHVzaCh2YWx1ZSk7XG4gIH1cblxuICBwb3BFbVNpemUoKSB7XG4gICAgdmFyIHtcbiAgICAgIGVtU2l6ZVN0YWNrXG4gICAgfSA9IHRoaXM7XG4gICAgZW1TaXplU3RhY2sucG9wKCk7XG4gIH1cblxuICBnZXRVbmlxdWVJZCgpIHtcbiAgICByZXR1cm4gXCJjYW52Z1wiLmNvbmNhdCgrK3RoaXMudW5pcXVlSWQpO1xuICB9XG5cbiAgaXNJbWFnZXNMb2FkZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1hZ2VzLmV2ZXJ5KF8gPT4gXy5sb2FkZWQpO1xuICB9XG5cbiAgaXNGb250c0xvYWRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5mb250cy5ldmVyeShfID0+IF8ubG9hZGVkKTtcbiAgfVxuXG4gIGNyZWF0ZURvY3VtZW50RWxlbWVudChkb2N1bWVudCkge1xuICAgIHZhciBkb2N1bWVudEVsZW1lbnQgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcbiAgICBkb2N1bWVudEVsZW1lbnQucm9vdCA9IHRydWU7XG4gICAgZG9jdW1lbnRFbGVtZW50LmFkZFN0eWxlc0Zyb21TdHlsZURlZmluaXRpb24oKTtcbiAgICB0aGlzLmRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50RWxlbWVudDtcbiAgICByZXR1cm4gZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgY3JlYXRlRWxlbWVudChub2RlKSB7XG4gICAgdmFyIGVsZW1lbnRUeXBlID0gbm9kZS5ub2RlTmFtZS5yZXBsYWNlKC9eW146XSs6LywgJycpO1xuICAgIHZhciBFbGVtZW50VHlwZSA9IERvY3VtZW50LmVsZW1lbnRUeXBlc1tlbGVtZW50VHlwZV07XG5cbiAgICBpZiAodHlwZW9mIEVsZW1lbnRUeXBlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIG5ldyBFbGVtZW50VHlwZSh0aGlzLCBub2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFVua25vd25FbGVtZW50KHRoaXMsIG5vZGUpO1xuICB9XG5cbiAgY3JlYXRlVGV4dE5vZGUobm9kZSkge1xuICAgIHJldHVybiBuZXcgVGV4dE5vZGUodGhpcywgbm9kZSk7XG4gIH1cblxuICBzZXRWaWV3Qm94KGNvbmZpZykge1xuICAgIHRoaXMuc2NyZWVuLnNldFZpZXdCb3goX29iamVjdFNwcmVhZCQxKHtcbiAgICAgIGRvY3VtZW50OiB0aGlzXG4gICAgfSwgY29uZmlnKSk7XG4gIH1cblxufVxuRG9jdW1lbnQuY3JlYXRlQ2FudmFzID0gY3JlYXRlQ2FudmFzO1xuRG9jdW1lbnQuY3JlYXRlSW1hZ2UgPSBjcmVhdGVJbWFnZTtcbkRvY3VtZW50LmVsZW1lbnRUeXBlcyA9IGVsZW1lbnRzO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG4vKipcclxuICogU1ZHIHJlbmRlcmVyIG9uIGNhbnZhcy5cclxuICovXG5cbmNsYXNzIENhbnZnIHtcbiAgLyoqXHJcbiAgICogTWFpbiBjb25zdHJ1Y3Rvci5cclxuICAgKiBAcGFyYW0gY3R4IC0gUmVuZGVyaW5nIGNvbnRleHQuXHJcbiAgICogQHBhcmFtIHN2ZyAtIFNWRyBEb2N1bWVudC5cclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlbmRlcmluZyBvcHRpb25zLlxyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjdHgsIHN2Zykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB0aGlzLnBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucyk7XG4gICAgdGhpcy5zY3JlZW4gPSBuZXcgU2NyZWVuKGN0eCwgb3B0aW9ucyk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB2YXIgZG9jdW1lbnQgPSBuZXcgRG9jdW1lbnQodGhpcywgb3B0aW9ucyk7XG4gICAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RWxlbWVudChzdmcpO1xuICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB0aGlzLmRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50RWxlbWVudDtcbiAgfVxuICAvKipcclxuICAgKiBDcmVhdGUgQ2FudmcgaW5zdGFuY2UgZnJvbSBTVkcgc291cmNlIHN0cmluZyBvciBVUkwuXHJcbiAgICogQHBhcmFtIGN0eCAtIFJlbmRlcmluZyBjb250ZXh0LlxyXG4gICAqIEBwYXJhbSBzdmcgLSBTVkcgc291cmNlIHN0cmluZyBvciBVUkwuXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZW5kZXJpbmcgb3B0aW9ucy5cclxuICAgKiBAcmV0dXJucyBDYW52ZyBpbnN0YW5jZS5cclxuICAgKi9cblxuXG4gIHN0YXRpYyBmcm9tKGN0eCwgc3ZnKSB7XG4gICAgdmFyIF9hcmd1bWVudHMgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IF9hcmd1bWVudHMubGVuZ3RoID4gMiAmJiBfYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBfYXJndW1lbnRzWzJdIDoge307XG4gICAgICB2YXIgcGFyc2VyID0gbmV3IFBhcnNlcihvcHRpb25zKTtcbiAgICAgIHZhciBzdmdEb2N1bWVudCA9IHlpZWxkIHBhcnNlci5wYXJzZShzdmcpO1xuICAgICAgcmV0dXJuIG5ldyBDYW52ZyhjdHgsIHN2Z0RvY3VtZW50LCBvcHRpb25zKTtcbiAgICB9KSgpO1xuICB9XG4gIC8qKlxyXG4gICAqIENyZWF0ZSBDYW52ZyBpbnN0YW5jZSBmcm9tIFNWRyBzb3VyY2Ugc3RyaW5nLlxyXG4gICAqIEBwYXJhbSBjdHggLSBSZW5kZXJpbmcgY29udGV4dC5cclxuICAgKiBAcGFyYW0gc3ZnIC0gU1ZHIHNvdXJjZSBzdHJpbmcuXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZW5kZXJpbmcgb3B0aW9ucy5cclxuICAgKiBAcmV0dXJucyBDYW52ZyBpbnN0YW5jZS5cclxuICAgKi9cblxuXG4gIHN0YXRpYyBmcm9tU3RyaW5nKGN0eCwgc3ZnKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuICAgIHZhciBzdmdEb2N1bWVudCA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoc3ZnKTtcbiAgICByZXR1cm4gbmV3IENhbnZnKGN0eCwgc3ZnRG9jdW1lbnQsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxyXG4gICAqIENyZWF0ZSBuZXcgQ2FudmcgaW5zdGFuY2Ugd2l0aCBpbmhlcml0ZWQgb3B0aW9ucy5cclxuICAgKiBAcGFyYW0gY3R4IC0gUmVuZGVyaW5nIGNvbnRleHQuXHJcbiAgICogQHBhcmFtIHN2ZyAtIFNWRyBzb3VyY2Ugc3RyaW5nIG9yIFVSTC5cclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlbmRlcmluZyBvcHRpb25zLlxyXG4gICAqIEByZXR1cm5zIENhbnZnIGluc3RhbmNlLlxyXG4gICAqL1xuXG5cbiAgZm9yayhjdHgsIHN2Zykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICByZXR1cm4gQ2FudmcuZnJvbShjdHgsIHN2ZywgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLm9wdGlvbnMpLCBvcHRpb25zKSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ3JlYXRlIG5ldyBDYW52ZyBpbnN0YW5jZSB3aXRoIGluaGVyaXRlZCBvcHRpb25zLlxyXG4gICAqIEBwYXJhbSBjdHggLSBSZW5kZXJpbmcgY29udGV4dC5cclxuICAgKiBAcGFyYW0gc3ZnIC0gU1ZHIHNvdXJjZSBzdHJpbmcuXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZW5kZXJpbmcgb3B0aW9ucy5cclxuICAgKiBAcmV0dXJucyBDYW52ZyBpbnN0YW5jZS5cclxuICAgKi9cblxuXG4gIGZvcmtTdHJpbmcoY3R4LCBzdmcpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgcmV0dXJuIENhbnZnLmZyb21TdHJpbmcoY3R4LCBzdmcsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdGhpcy5vcHRpb25zKSwgb3B0aW9ucykpO1xuICB9XG4gIC8qKlxyXG4gICAqIERvY3VtZW50IGlzIHJlYWR5IHByb21pc2UuXHJcbiAgICogQHJldHVybnMgUmVhZHkgcHJvbWlzZS5cclxuICAgKi9cblxuXG4gIHJlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLnNjcmVlbi5yZWFkeSgpO1xuICB9XG4gIC8qKlxyXG4gICAqIERvY3VtZW50IGlzIHJlYWR5IHZhbHVlLlxyXG4gICAqIEByZXR1cm5zIElzIHJlYWR5IG9yIG5vdC5cclxuICAgKi9cblxuXG4gIGlzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NyZWVuLmlzUmVhZHkoKTtcbiAgfVxuICAvKipcclxuICAgKiBSZW5kZXIgb25seSBmaXJzdCBmcmFtZSwgaWdub3JpbmcgYW5pbWF0aW9ucyBhbmQgbW91c2UuXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZW5kZXJpbmcgb3B0aW9ucy5cclxuICAgKi9cblxuXG4gIHJlbmRlcigpIHtcbiAgICB2YXIgX2FyZ3VtZW50czIgPSBhcmd1bWVudHMsXG4gICAgICAgIF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBfYXJndW1lbnRzMi5sZW5ndGggPiAwICYmIF9hcmd1bWVudHMyWzBdICE9PSB1bmRlZmluZWQgPyBfYXJndW1lbnRzMlswXSA6IHt9O1xuXG4gICAgICBfdGhpcy5zdGFydChfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgZW5hYmxlUmVkcmF3OiB0cnVlLFxuICAgICAgICBpZ25vcmVBbmltYXRpb246IHRydWUsXG4gICAgICAgIGlnbm9yZU1vdXNlOiB0cnVlXG4gICAgICB9LCBvcHRpb25zKSk7XG5cbiAgICAgIHlpZWxkIF90aGlzLnJlYWR5KCk7XG5cbiAgICAgIF90aGlzLnN0b3AoKTtcbiAgICB9KSgpO1xuICB9XG4gIC8qKlxyXG4gICAqIFN0YXJ0IHJlbmRlcmluZy5cclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlbmRlciBvcHRpb25zLlxyXG4gICAqL1xuXG5cbiAgc3RhcnQoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBkb2N1bWVudEVsZW1lbnQsXG4gICAgICBzY3JlZW4sXG4gICAgICBvcHRpb25zOiBiYXNlT3B0aW9uc1xuICAgIH0gPSB0aGlzO1xuICAgIHNjcmVlbi5zdGFydChkb2N1bWVudEVsZW1lbnQsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICBlbmFibGVSZWRyYXc6IHRydWVcbiAgICB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpKTtcbiAgfVxuICAvKipcclxuICAgKiBTdG9wIHJlbmRlcmluZy5cclxuICAgKi9cblxuXG4gIHN0b3AoKSB7XG4gICAgdGhpcy5zY3JlZW4uc3RvcCgpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJlc2l6ZSBTVkcgdG8gZml0IGluIGdpdmVuIHNpemUuXHJcbiAgICogQHBhcmFtIHdpZHRoXHJcbiAgICogQHBhcmFtIGhlaWdodFxyXG4gICAqIEBwYXJhbSBwcmVzZXJ2ZUFzcGVjdFJhdGlvXHJcbiAgICovXG5cblxuICByZXNpemUod2lkdGgpIHtcbiAgICB2YXIgaGVpZ2h0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB3aWR0aDtcbiAgICB2YXIgcHJlc2VydmVBc3BlY3RSYXRpbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgdGhpcy5kb2N1bWVudEVsZW1lbnQucmVzaXplKHdpZHRoLCBoZWlnaHQsIHByZXNlcnZlQXNwZWN0UmF0aW8pO1xuICB9XG5cbn1cblxuZXhwb3J0IHsgQUVsZW1lbnQsIEFuaW1hdGVDb2xvckVsZW1lbnQsIEFuaW1hdGVFbGVtZW50LCBBbmltYXRlVHJhbnNmb3JtRWxlbWVudCwgQm91bmRpbmdCb3gsIENCMSwgQ0IyLCBDQjMsIENCNCwgQ2FudmcsIENpcmNsZUVsZW1lbnQsIENsaXBQYXRoRWxlbWVudCwgRGVmc0VsZW1lbnQsIERlc2NFbGVtZW50LCBEb2N1bWVudCwgRWxlbWVudCwgRWxsaXBzZUVsZW1lbnQsIEZlQ29sb3JNYXRyaXhFbGVtZW50LCBGZUNvbXBvc2l0ZUVsZW1lbnQsIEZlRHJvcFNoYWRvd0VsZW1lbnQsIEZlR2F1c3NpYW5CbHVyRWxlbWVudCwgRmVNb3JwaG9sb2d5RWxlbWVudCwgRmlsdGVyRWxlbWVudCwgRm9udCwgRm9udEVsZW1lbnQsIEZvbnRGYWNlRWxlbWVudCwgR0VsZW1lbnQsIEdseXBoRWxlbWVudCwgR3JhZGllbnRFbGVtZW50LCBJbWFnZUVsZW1lbnQsIExpbmVFbGVtZW50LCBMaW5lYXJHcmFkaWVudEVsZW1lbnQsIE1hcmtlckVsZW1lbnQsIE1hc2tFbGVtZW50LCBNYXRyaXgsIE1pc3NpbmdHbHlwaEVsZW1lbnQsIE1vdXNlLCBQU0VVRE9fWkVSTywgUGFyc2VyLCBQYXRoRWxlbWVudCwgUGF0aFBhcnNlciwgUGF0dGVybkVsZW1lbnQsIFBvaW50LCBQb2x5Z29uRWxlbWVudCwgUG9seWxpbmVFbGVtZW50LCBQcm9wZXJ0eSwgUUIxLCBRQjIsIFFCMywgUmFkaWFsR3JhZGllbnRFbGVtZW50LCBSZWN0RWxlbWVudCwgUmVuZGVyZWRFbGVtZW50LCBSb3RhdGUsIFNWR0VsZW1lbnQsIFNWR0ZvbnRMb2FkZXIsIFNjYWxlLCBTY3JlZW4sIFNrZXcsIFNrZXdYLCBTa2V3WSwgU3RvcEVsZW1lbnQsIFN0eWxlRWxlbWVudCwgU3ltYm9sRWxlbWVudCwgVFJlZkVsZW1lbnQsIFRTcGFuRWxlbWVudCwgVGV4dEVsZW1lbnQsIFRleHRQYXRoRWxlbWVudCwgVGl0bGVFbGVtZW50LCBUcmFuc2Zvcm0sIFRyYW5zbGF0ZSwgVW5rbm93bkVsZW1lbnQsIFVzZUVsZW1lbnQsIFZpZXdQb3J0LCBjb21wcmVzc1NwYWNlcywgQ2FudmcgYXMgZGVmYXVsdCwgZ2V0U2VsZWN0b3JTcGVjaWZpY2l0eSwgbm9ybWFsaXplQXR0cmlidXRlTmFtZSwgbm9ybWFsaXplQ29sb3IsIHBhcnNlRXh0ZXJuYWxVcmwsIGluZGV4IGFzIHByZXNldHMsIHRvTnVtYmVycywgdHJpbUxlZnQsIHRyaW1SaWdodCwgdmVjdG9yTWFnbml0dWRlLCB2ZWN0b3JzQW5nbGUsIHZlY3RvcnNSYXRpbyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lhVzVrWlhndVpYTXVhbk1pTENKemIzVnlZMlZ6SWpwYlhTd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sdGRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzaWZRPT1cbiJdLCJuYW1lcyI6WyJfYXN5bmNUb0dlbmVyYXRvciIsIl9kZWZpbmVQcm9wZXJ0eSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIlJHQkNvbG9yIiwiU1ZHUGF0aERhdGEiLCJjYW52YXNSR0JBIiwib2Zmc2NyZWVuIiwiRE9NUGFyc2VyIiwiRE9NUGFyc2VyRmFsbGJhY2siLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJwcmVzZXQiLCJ3aW5kb3ciLCJpZ25vcmVBbmltYXRpb24iLCJpZ25vcmVNb3VzZSIsImNyZWF0ZUNhbnZhcyIsIndpZHRoIiwiaGVpZ2h0IiwiT2Zmc2NyZWVuQ2FudmFzIiwiY3JlYXRlSW1hZ2UiLCJ1cmwiLCJyZXNwb25zZSIsImZldGNoIiwiYmxvYiIsImltZyIsImNyZWF0ZUltYWdlQml0bWFwIiwiUmVmbGVjdCIsImRlbGV0ZVByb3BlcnR5Iiwibm9kZSIsIl9yZWYiLCJjYW52YXMiLCJsb2FkSW1hZ2UiLCJpbmRleCIsIk9iamVjdCIsImZyZWV6ZSIsIl9fcHJvdG9fXyIsImNvbXByZXNzU3BhY2VzIiwic3RyIiwicmVwbGFjZSIsInRyaW1MZWZ0IiwidHJpbVJpZ2h0IiwidG9OdW1iZXJzIiwibWF0Y2hlcyIsIm1hdGNoIiwibWFwIiwicGFyc2VGbG9hdCIsImFsbFVwcGVyY2FzZSIsIm5vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUiLCJuYW1lIiwidGVzdCIsInRvTG93ZXJDYXNlIiwicGFyc2VFeHRlcm5hbFVybCIsInVybE1hdGNoIiwiZXhlYyIsIm5vcm1hbGl6ZUNvbG9yIiwiY29sb3IiLCJzdGFydHNXaXRoIiwicmdiUGFydHMiLCJub3JtYWxpemVkQ29sb3IiLCJudW0iLCJpc0Zsb2F0IiwiU3RyaW5nIiwiTWF0aCIsInJvdW5kIiwiYXR0cmlidXRlUmVnZXgiLCJpZFJlZ2V4IiwiY2xhc3NSZWdleCIsInBzZXVkb0VsZW1lbnRSZWdleCIsInBzZXVkb0NsYXNzV2l0aEJyYWNrZXRzUmVnZXgiLCJwc2V1ZG9DbGFzc1JlZ2V4IiwiZWxlbWVudFJlZ2V4IiwiZmluZFNlbGVjdG9yTWF0Y2giLCJzZWxlY3RvciIsInJlZ2V4IiwiZ2V0U2VsZWN0b3JTcGVjaWZpY2l0eSIsInNwZWNpZmljaXR5IiwiY3VycmVudFNlbGVjdG9yIiwiZGVsdGEiLCJqb2luIiwiUFNFVURPX1pFUk8iLCJ2ZWN0b3JNYWduaXR1ZGUiLCJ2Iiwic3FydCIsInBvdyIsInZlY3RvcnNSYXRpbyIsInUiLCJ2ZWN0b3JzQW5nbGUiLCJhY29zIiwiQ0IxIiwidCIsIkNCMiIsIkNCMyIsIkNCNCIsIlFCMSIsIlFCMiIsIlFCMyIsIlByb3BlcnR5IiwiY29uc3RydWN0b3IiLCJkb2N1bWVudCIsInZhbHVlIiwiaXNOb3JtYWxpemVkQ29sb3IiLCJlbXB0eSIsInNwbGl0Iiwic2VwYXJhdG9yIiwiZ2V0U3RyaW5nIiwidHJpbSIsImhhc1ZhbHVlIiwiemVyb0lzVmFsdWUiLCJpc1N0cmluZyIsInJlZ2V4cCIsInJlc3VsdCIsImlzVXJsRGVmaW5pdGlvbiIsImlzUGl4ZWxzIiwiYXNTdHJpbmciLCJlbmRzV2l0aCIsInNldFZhbHVlIiwiZ2V0VmFsdWUiLCJkZWYiLCJnZXROdW1iZXIiLCJuIiwiZ2V0Q29sb3IiLCJnZXREcGkiLCJnZXRSZW0iLCJyb290RW1TaXplIiwiZ2V0RW0iLCJlbVNpemUiLCJnZXRVbml0cyIsImdldFBpeGVscyIsImF4aXNPcklzRm9udFNpemUiLCJwcm9jZXNzUGVyY2VudCIsImF4aXMiLCJpc0ZvbnRTaXplIiwidmlld1BvcnQiLCJzY3JlZW4iLCJtaW4iLCJjb21wdXRlU2l6ZSIsIm1heCIsImdldE1pbGxpc2Vjb25kcyIsImdldFJhZGlhbnMiLCJQSSIsImdldERlZmluaXRpb24iLCJkZWZpbml0aW9ucyIsImdldEZpbGxTdHlsZURlZmluaXRpb24iLCJlbGVtZW50Iiwib3BhY2l0eSIsImNyZWF0ZUdyYWRpZW50IiwiY3R4IiwiY3JlYXRlUGF0dGVybiIsImdldEhyZWZBdHRyaWJ1dGUiLCJwYXR0ZXJuVHJhbnNmb3JtIiwiZ2V0QXR0cmlidXRlIiwiZ2V0VGV4dEJhc2VsaW5lIiwidGV4dEJhc2VsaW5lTWFwcGluZyIsImFkZE9wYWNpdHkiLCJsZW4iLCJjb21tYXMiLCJpIiwib2siLCJhbHBoYSIsInRvUkdCQSIsIlZpZXdQb3J0Iiwidmlld1BvcnRzIiwiY2xlYXIiLCJzZXRDdXJyZW50IiwicHVzaCIsInJlbW92ZUN1cnJlbnQiLCJwb3AiLCJnZXRDdXJyZW50IiwiZCIsIlBvaW50IiwieCIsInkiLCJwYXJzZSIsInBvaW50IiwiZGVmYXVsdFZhbHVlIiwicGFyc2VTY2FsZSIsInNjYWxlIiwicGFyc2VQYXRoIiwicGF0aCIsInBvaW50cyIsInBhdGhQb2ludHMiLCJhbmdsZVRvIiwiYXRhbjIiLCJhcHBseVRyYW5zZm9ybSIsInRyYW5zZm9ybSIsInhwIiwieXAiLCJNb3VzZSIsIndvcmtpbmciLCJldmVudHMiLCJldmVudEVsZW1lbnRzIiwib25DbGljayIsImJpbmQiLCJvbk1vdXNlTW92ZSIsImlzV29ya2luZyIsInN0YXJ0Iiwib25jbGljayIsIm9ubW91c2Vtb3ZlIiwic3RvcCIsImhhc0V2ZW50cyIsInJ1bkV2ZW50cyIsInN0eWxlIiwiY3Vyc29yIiwiZm9yRWFjaCIsInJ1biIsInBhcmVudCIsImNoZWNrUGF0aCIsIl9yZWYyIiwiaXNQb2ludEluUGF0aCIsImNoZWNrQm91bmRpbmdCb3giLCJib3VuZGluZ0JveCIsIl9yZWYzIiwiaXNQb2ludEluQm94IiwibWFwWFkiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0VG9wIiwib2Zmc2V0UGFyZW50Iiwic2Nyb2xsWCIsInNjcm9sbFkiLCJldmVudCIsImNsaWVudFgiLCJjbGllbnRZIiwidHlwZSIsImV2ZW50VGFyZ2V0IiwiZGVmYXVsdFdpbmRvdyIsImRlZmF1bHRGZXRjaCQxIiwiU2NyZWVuIiwiRlJBTUVSQVRFIiwiTUFYX1ZJUlRVQUxfUElYRUxTIiwiQ0xJRU5UX1dJRFRIIiwiQ0xJRU5UX0hFSUdIVCIsIm1vdXNlIiwiYW5pbWF0aW9ucyIsIndhaXRzIiwiZnJhbWVEdXJhdGlvbiIsImlzUmVhZHlMb2NrIiwiaXNGaXJzdFJlbmRlciIsImludGVydmFsSWQiLCJ3YWl0IiwiY2hlY2tlciIsInJlYWR5IiwicmVhZHlQcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJpc1JlYWR5IiwiZXZlcnkiLCJfIiwicmVzb2x2ZVJlYWR5Iiwic2V0RGVmYXVsdHMiLCJzdHJva2VTdHlsZSIsImxpbmVDYXAiLCJsaW5lSm9pbiIsIm1pdGVyTGltaXQiLCJzZXRWaWV3Qm94IiwiYXNwZWN0UmF0aW8iLCJkZXNpcmVkV2lkdGgiLCJkZXNpcmVkSGVpZ2h0IiwibWluWCIsIm1pblkiLCJyZWZYIiwicmVmWSIsImNsaXAiLCJjbGlwWCIsImNsaXBZIiwiY2xlYW5Bc3BlY3RSYXRpbyIsImFzcGVjdFJhdGlvQWxpZ24iLCJhc3BlY3RSYXRpb01lZXRPclNsaWNlIiwiYWxpZ24iLCJtZWV0T3JTbGljZSIsInNjYWxlWCIsInNjYWxlWSIsInNjYWxlTWluIiwic2NhbGVNYXgiLCJmaW5hbERlc2lyZWRXaWR0aCIsImZpbmFsRGVzaXJlZEhlaWdodCIsInJlZlhQcm9wIiwicmVmWVByb3AiLCJoYXNSZWZzIiwidHJhbnNsYXRlIiwic2NhbGVkQ2xpcFgiLCJzY2FsZWRDbGlwWSIsImJlZ2luUGF0aCIsIm1vdmVUbyIsImxpbmVUbyIsImNsb3NlUGF0aCIsImlzTWVldE1pblkiLCJpc1NsaWNlTWF4WSIsImlzTWVldE1pblgiLCJpc1NsaWNlTWF4WCIsImVuYWJsZVJlZHJhdyIsImlnbm9yZURpbWVuc2lvbnMiLCJpZ25vcmVDbGVhciIsImZvcmNlUmVkcmF3Iiwic2NhbGVXaWR0aCIsInNjYWxlSGVpZ2h0Iiwib2Zmc2V0WCIsIm9mZnNldFkiLCJyZW5kZXIiLCJub3ciLCJEYXRlIiwidGhlbiIsInRpY2siLCJzaG91bGRVcGRhdGUiLCJjYW5jZWwiLCJyZWR1Y2UiLCJhbmltYXRpb24iLCJ1cGRhdGUiLCJ3aWR0aFN0eWxlIiwiZ2V0U3R5bGUiLCJoZWlnaHRTdHlsZSIsImNvbmNhdCIsImNXaWR0aCIsImNsaWVudFdpZHRoIiwiY0hlaWdodCIsImNsaWVudEhlaWdodCIsInZpZXdCb3giLCJ4UmF0aW8iLCJ5UmF0aW8iLCJfd2lkdGhTdHlsZSIsImlzTmFOIiwiX2hlaWdodFN0eWxlIiwidHJhbnNmb3JtU3R5bGUiLCJjbGVhclJlY3QiLCJkZWZhdWx0RmV0Y2giLCJEZWZhdWx0RE9NUGFyc2VyIiwiUGFyc2VyIiwicmVzb3VyY2UiLCJfdGhpcyIsInBhcnNlRnJvbVN0cmluZyIsImxvYWQiLCJ4bWwiLCJwYXJzZXIiLCJjaGVja0RvY3VtZW50IiwiZXJyIiwicGFyc2VyRXJyb3IiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsIkVycm9yIiwidGV4dENvbnRlbnQiLCJfdGhpczIiLCJ0ZXh0IiwiVHJhbnNsYXRlIiwiYXBwbHkiLCJ1bmFwcGx5IiwiYXBwbHlUb1BvaW50IiwiUm90YXRlIiwicm90YXRlIiwidHJhbnNmb3JtT3JpZ2luIiwiYW5nbGUiLCJvcmlnaW5YIiwib3JpZ2luWSIsImN4IiwiY3kiLCJudW1iZXJzIiwidHgiLCJ0eSIsInJhZCIsImNvcyIsInNpbiIsIlNjYWxlIiwic2NhbGVTaXplIiwiTWF0cml4IiwibWF0cml4IiwiYSIsImIiLCJjIiwiZSIsImYiLCJnIiwiaCIsImRldCIsIlNrZXciLCJza2V3IiwiU2tld1giLCJ0YW4iLCJTa2V3WSIsInBhcnNlVHJhbnNmb3JtcyIsInBhcnNlVHJhbnNmb3JtIiwiVHJhbnNmb3JtIiwidHJhbnNmb3JtcyIsImRhdGEiLCJUcmFuc2Zvcm1UeXBlIiwidHJhbnNmb3JtVHlwZXMiLCJmcm9tRWxlbWVudCIsInRyYW5zZm9ybU9yaWdpblhQcm9wZXJ0eSIsInRyYW5zZm9ybU9yaWdpbllQcm9wZXJ0eSIsInNrZXdYIiwic2tld1kiLCJFbGVtZW50IiwiY2FwdHVyZVRleHROb2RlcyIsImF0dHJpYnV0ZXMiLCJjcmVhdGUiLCJzdHlsZXMiLCJzdHlsZXNTcGVjaWZpY2l0eSIsImFuaW1hdGlvbkZyb3plbiIsImFuaW1hdGlvbkZyb3plblZhbHVlIiwiY2hpbGRyZW4iLCJub2RlVHlwZSIsIkFycmF5IiwiZnJvbSIsImF0dHJpYnV0ZSIsIm5vZGVOYW1lIiwiYWRkU3R5bGVzRnJvbVN0eWxlRGVmaW5pdGlvbiIsImlkIiwiY2hpbGROb2RlcyIsImNoaWxkTm9kZSIsImFkZENoaWxkIiwidGV4dE5vZGUiLCJjcmVhdGVUZXh0Tm9kZSIsImdldFRleHQiLCJjcmVhdGVJZk5vdEV4aXN0cyIsImF0dHIiLCJfYXR0ciIsImtleSIsInNraXBBbmNlc3RvcnMiLCJwYXJlbnRTdHlsZSIsIl9zdHlsZSIsInNhdmUiLCJtYXNrIiwiYXBwbHlFZmZlY3RzIiwiZmlsdGVyIiwic2V0Q29udGV4dCIsInJlbmRlckNoaWxkcmVuIiwiY2xlYXJDb250ZXh0IiwicmVzdG9yZSIsImNsaXBQYXRoU3R5bGVQcm9wIiwiY2hpbGQiLCJjcmVhdGVFbGVtZW50IiwiaWdub3JlQ2hpbGRUeXBlcyIsImluY2x1ZGVzIiwibWF0Y2hlc1NlbGVjdG9yIiwiX25vZGUkZ2V0QXR0cmlidXRlIiwic3R5bGVDbGFzc2VzIiwiY2FsbCIsInNvbWUiLCJzdHlsZUNsYXNzIiwiZXhpc3RpbmdTcGVjaWZpY2l0eSIsInJlbW92ZVN0eWxlcyIsImlnbm9yZVN0eWxlcyIsInRvUmVzdG9yZSIsInN0eWxlUHJvcCIsInJlc3RvcmVTdHlsZXMiLCJpc0ZpcnN0Q2hpbGQiLCJfdGhpcyRwYXJlbnQiLCJpbmRleE9mIiwiVW5rbm93bkVsZW1lbnQiLCJ3cmFwRm9udEZhbWlseSIsImZvbnRGYW1pbHkiLCJ0cmltbWVkIiwicHJlcGFyZUZvbnRGYW1pbHkiLCJwcm9jZXNzIiwicHJlcGFyZUZvbnRTdHlsZSIsImZvbnRTdHlsZSIsInRhcmdldEZvbnRTdHlsZSIsInByZXBhcmVGb250V2VpZ2h0IiwiZm9udFdlaWdodCIsInRhcmdldEZvbnRXZWlnaHQiLCJGb250IiwiZm9udFZhcmlhbnQiLCJmb250U2l6ZSIsImluaGVyaXQiLCJpbmhlcml0Rm9udCIsImZvbnQiLCJwYXJ0cyIsInNldCIsInBhcnQiLCJ2YXJpYW50cyIsIndlaWdodHMiLCJ0b1N0cmluZyIsIkJvdW5kaW5nQm94IiwieDEiLCJOdW1iZXIiLCJOYU4iLCJ5MSIsIngyIiwieTIiLCJhZGRQb2ludCIsImFkZFgiLCJhZGRZIiwiYWRkQm91bmRpbmdCb3giLCJzdW1DdWJpYyIsInAwIiwicDEiLCJwMiIsInAzIiwiYmV6aWVyQ3VydmVBZGQiLCJmb3JYIiwiYjJhYyIsInQxIiwidDIiLCJhZGRCZXppZXJDdXJ2ZSIsInAweCIsInAweSIsInAxeCIsInAxeSIsInAyeCIsInAyeSIsInAzeCIsInAzeSIsImFkZFF1YWRyYXRpY0N1cnZlIiwiY3AxeCIsImNwMXkiLCJjcDJ4IiwiY3AyeSIsIlBhdGhQYXJzZXIiLCJjb250cm9sIiwiY3VycmVudCIsImNvbW1hbmQiLCJjb21tYW5kcyIsInByZXZpb3VzQ29tbWFuZCIsImFuZ2xlcyIsInJlc2V0IiwiaXNFbmQiLCJuZXh0IiwiZ2V0UG9pbnQiLCJ4UHJvcCIsInlQcm9wIiwibWFrZUFic29sdXRlIiwiZ2V0QXNDb250cm9sUG9pbnQiLCJnZXRBc0N1cnJlbnRQb2ludCIsImdldFJlZmxlY3RlZENvbnRyb2xQb2ludCIsIkNVUlZFX1RPIiwiU01PT1RIX0NVUlZFX1RPIiwiUVVBRF9UTyIsIlNNT09USF9RVUFEX1RPIiwib3giLCJveSIsInJlbGF0aXZlIiwiYWRkTWFya2VyIiwicHJpb3JUbyIsImFkZE1hcmtlckFuZ2xlIiwiZ2V0TWFya2VyUG9pbnRzIiwiZ2V0TWFya2VyQW5nbGVzIiwiaiIsIlJlbmRlcmVkRWxlbWVudCIsIm1vZGlmaWVkRW1TaXplU3RhY2siLCJjYWxjdWxhdGVPcGFjaXR5Iiwib3BhY2l0eVN0eWxlIiwiZnJvbU1lYXN1cmUiLCJmaWxsU3R5bGVQcm9wIiwiZmlsbE9wYWNpdHlTdHlsZVByb3AiLCJzdHJva2VTdHlsZVByb3AiLCJzdHJva2VPcGFjaXR5UHJvcCIsImZpbGxTdHlsZSIsIl9maWxsU3R5bGUiLCJfZmlsbFN0eWxlMiIsIl9zdHJva2VTdHlsZSIsIl9zdHJva2VTdHlsZTIiLCJzdHJva2VXaWR0aFN0eWxlUHJvcCIsIm5ld0xpbmVXaWR0aCIsImxpbmVXaWR0aCIsInN0cm9rZUxpbmVjYXBTdHlsZVByb3AiLCJzdHJva2VMaW5lam9pblN0eWxlUHJvcCIsInN0cm9rZU1pdGVybGltaXRQcm9wIiwic3Ryb2tlRGFzaGFycmF5U3R5bGVQcm9wIiwic3Ryb2tlRGFzaG9mZnNldFByb3AiLCJnYXBzIiwic2V0TGluZURhc2giLCJ3ZWJraXRMaW5lRGFzaCIsIm1vekRhc2giLCJvZmZzZXQiLCJsaW5lRGFzaE9mZnNldCIsIndlYmtpdExpbmVEYXNoT2Zmc2V0IiwibW96RGFzaE9mZnNldCIsImZvbnRTdHlsZVByb3AiLCJmb250U3R5bGVTdHlsZVByb3AiLCJmb250VmFyaWFudFN0eWxlUHJvcCIsImZvbnRXZWlnaHRTdHlsZVByb3AiLCJmb250U2l6ZVN0eWxlUHJvcCIsImZvbnRGYW1pbHlTdHlsZVByb3AiLCJnbG9iYWxBbHBoYSIsInBvcEVtU2l6ZSIsIlBhdGhFbGVtZW50IiwicGF0aFBhcnNlciIsIk1PVkVfVE8iLCJwYXRoTSIsIkxJTkVfVE8iLCJwYXRoTCIsIkhPUklaX0xJTkVfVE8iLCJwYXRoSCIsIlZFUlRfTElORV9UTyIsInBhdGhWIiwicGF0aEMiLCJwYXRoUyIsInBhdGhRIiwicGF0aFQiLCJBUkMiLCJwYXRoQSIsIkNMT1NFX1BBVEgiLCJwYXRoWiIsImdldEJvdW5kaW5nQm94IiwiZ2V0TWFya2VycyIsIm1hcmtlcnMiLCJmaWxsUnVsZVN0eWxlUHJvcCIsImZpbGwiLCJzZXRUcmFuc2Zvcm0iLCJzdHJva2UiLCJtYXJrZXJzTGFzdEluZGV4IiwibWFya2VyU3RhcnRTdHlsZVByb3AiLCJtYXJrZXJNaWRTdHlsZVByb3AiLCJtYXJrZXJFbmRTdHlsZVByb3AiLCJtYXJrZXIiLCJfbWFya2VyIiwiX3BvaW50IiwiX2FuZ2xlIiwiX21hcmtlcjIiLCJfcG9pbnQyIiwiX2FuZ2xlMiIsImNvbnRyb2xQb2ludCIsImN1cnJlbnRQb2ludCIsImJlemllckN1cnZlVG8iLCJxdWFkcmF0aWNDdXJ2ZVRvIiwiclgiLCJyWSIsInhSb3QiLCJsQXJjRmxhZyIsInN3ZWVwRmxhZyIsInhBeGlzUm90YXRpb24iLCJjdXJycCIsImwiLCJzIiwiY3BwIiwiY2VudHAiLCJhMSIsImFkIiwiZGlyIiwiYWgiLCJoYWxmV2F5IiwiciIsInN4Iiwic3kiLCJhcmMiLCJCb29sZWFuIiwiR2x5cGhFbGVtZW50IiwiaG9yaXpBZHZYIiwidW5pY29kZSIsImFyYWJpY0Zvcm0iLCJUZXh0RWxlbWVudCIsIm1lYXN1cmVDYWNoZSIsInRleHRCYXNlbGluZSIsImluaXRpYWxpemVDb29yZGluYXRlcyIsImxlYWZUZXh0cyIsInRleHRDaHVua1N0YXJ0IiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJtYXhYIiwiTkVHQVRJVkVfSU5GSU5JVFkiLCJnZXRURWxlbWVudEJvdW5kaW5nQm94IiwiYWRqdXN0Q2hpbGRDb29yZGluYXRlc1JlY3Vyc2l2ZSIsImNoaWxkQm91bmRpbmdCb3giLCJnZXRDaGlsZEJvdW5kaW5nQm94IiwiZ2V0Rm9udFNpemUiLCJpbmhlcml0Rm9udFNpemUiLCJtZWFzdXJlVGV4dCIsImdldEdseXBoIiwiY2hhciIsImdseXBoIiwiaXNBcmFiaWMiLCJwcmV2Q2hhciIsIm5leHRDaGFyIiwiZ2x5cGhzIiwibWF5YmVHbHlwaCIsIm1pc3NpbmdHbHlwaCIsImdldFRleHRGcm9tTm9kZSIsInBhcmVudE5vZGUiLCJsYXN0SW5kZXgiLCJyZW5kZXJURWxlbWVudENoaWxkcmVuIiwicmVuZGVyQ2hpbGQiLCJyZW5kZXJUZXh0IiwiY3VzdG9tRm9udCIsInVuaXRzUGVyRW0iLCJmb250RmFjZSIsImN0eEZvbnQiLCJpc1JUTCIsInJldmVyc2UiLCJkeCIsImx3IiwiZmlsbFRleHQiLCJzdHJva2VUZXh0IiwiYXBwbHlBbmNob3JpbmciLCJmaXJzdEVsZW1lbnQiLCJ0ZXh0QW5jaG9yIiwic2hpZnQiLCJhZGp1c3RDaGlsZENvb3JkaW5hdGVzUmVjdXJzaXZlQ29yZSIsInRleHRQYXJlbnQiLCJhZGp1c3RDaGlsZENvb3JkaW5hdGVzIiwieEF0dHIiLCJ5QXR0ciIsImR4QXR0ciIsImR5QXR0ciIsImdldEluaGVyaXRlZEF0dHJpYnV0ZSIsIm1lYXN1cmUiLCJtZWFzdXJlVGFyZ2V0VGV4dCIsInRhcmdldFRleHQiLCJfbWVhc3VyZSIsInBhcmVudEF0dHIiLCJUU3BhbkVsZW1lbnQiLCJUZXh0Tm9kZSIsIlNWR0VsZW1lbnQiLCJyb290IiwiX3RoaXMkbm9kZSRwYXJlbnROb2RlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJmb250U2l6ZVByb3AiLCJyZWZYQXR0ciIsInJlZllBdHRyIiwidmlld0JveEF0dHIiLCJyZXNpemUiLCJwcmVzZXJ2ZUFzcGVjdFJhdGlvIiwid2lkdGhBdHRyIiwiaGVpZ2h0QXR0ciIsInN0eWxlQXR0ciIsIm9yaWdpbldpZHRoIiwib3JpZ2luSGVpZ2h0IiwicHJlc2VydmVBc3BlY3RSYXRpb0F0dHIiLCJSZWN0RWxlbWVudCIsInJ4QXR0ciIsInJ5QXR0ciIsInJ4IiwicnkiLCJLQVBQQSIsIkNpcmNsZUVsZW1lbnQiLCJFbGxpcHNlRWxlbWVudCIsIkxpbmVFbGVtZW50IiwiZ2V0UG9pbnRzIiwieDAiLCJ5MCIsIlBvbHlsaW5lRWxlbWVudCIsIlBvbHlnb25FbGVtZW50IiwiUGF0dGVybkVsZW1lbnQiLCJwYXJlbnRPcGFjaXR5UHJvcCIsInBhdHRlcm5TdmciLCJwYXR0ZXJuQ2FudmFzIiwicGF0dGVybkN0eCIsImdldENvbnRleHQiLCJwYXR0ZXJuIiwiTWFya2VyRWxlbWVudCIsIm9yaWVudCIsIm1hcmtlclVuaXRzIiwibWFya2VyU3ZnIiwib3ZlcmZsb3ciLCJEZWZzRWxlbWVudCIsIkdFbGVtZW50IiwiR3JhZGllbnRFbGVtZW50IiwiYXR0cmlidXRlc1RvSW5oZXJpdCIsInN0b3BzIiwiZ2V0R3JhZGllbnRVbml0cyIsInN0b3BzQ29udGFpbmVyIiwiaW5oZXJpdFN0b3BDb250YWluZXIiLCJncmFkaWVudCIsImdldEdyYWRpZW50IiwiYWRkUGFyZW50T3BhY2l0eSIsImFkZENvbG9yU3RvcCIsInJvb3RWaWV3IiwicmVjdCIsImdyb3VwIiwiYXR0cmlidXRlVG9Jbmhlcml0IiwiY29sb3JQcm9wIiwiTGluZWFyR3JhZGllbnRFbGVtZW50IiwiaXNCb3VuZGluZ0JveFVuaXRzIiwiY3JlYXRlTGluZWFyR3JhZGllbnQiLCJSYWRpYWxHcmFkaWVudEVsZW1lbnQiLCJmeCIsImZ5IiwiZnIiLCJjcmVhdGVSYWRpYWxHcmFkaWVudCIsIlN0b3BFbGVtZW50Iiwic3RvcE9wYWNpdHkiLCJzdG9wQ29sb3IiLCJBbmltYXRlRWxlbWVudCIsImR1cmF0aW9uIiwiaW5pdGlhbFZhbHVlIiwiaW5pdGlhbFVuaXRzIiwicmVtb3ZlZCIsImZyb3plbiIsImJlZ2luIiwibWF4RHVyYXRpb24iLCJ0byIsInZhbHVlcyIsInZhbHVlc0F0dHIiLCJnZXRQcm9wZXJ0eSIsImF0dHJpYnV0ZVR5cGUiLCJhdHRyaWJ1dGVOYW1lIiwiY2FsY1ZhbHVlIiwicHJvZ3Jlc3MiLCJnZXRQcm9ncmVzcyIsIm5ld1ZhbHVlIiwicHJvcCIsInVwZGF0ZWQiLCJ0eXBlQXR0ciIsInAiLCJsYiIsImZsb29yIiwidWIiLCJjZWlsIiwiQW5pbWF0ZUNvbG9yRWxlbWVudCIsImNvbG9yRnJvbSIsImNvbG9yVG8iLCJBbmltYXRlVHJhbnNmb3JtRWxlbWVudCIsInRyYW5zZm9ybUZyb20iLCJ0cmFuc2Zvcm1UbyIsIkZvbnRFbGVtZW50IiwiZm9udEZhbWlseVN0eWxlIiwiRm9udEZhY2VFbGVtZW50IiwiYXNjZW50IiwiZGVzY2VudCIsIk1pc3NpbmdHbHlwaEVsZW1lbnQiLCJUUmVmRWxlbWVudCIsImZpcnN0Q2hpbGQiLCJBRWxlbWVudCIsImhhc1RleHQiLCJvcGVuIiwib3duS2V5cyQyIiwib2JqZWN0IiwiZW51bWVyYWJsZU9ubHkiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic3ltYm9scyIsInN5bSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJfb2JqZWN0U3ByZWFkJDIiLCJ0YXJnZXQiLCJzb3VyY2UiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImRlZmluZVByb3BlcnR5IiwiVGV4dFBhdGhFbGVtZW50IiwidGV4dFdpZHRoIiwidGV4dEhlaWdodCIsInBhdGhMZW5ndGgiLCJnbHlwaEluZm8iLCJsZXR0ZXJTcGFjaW5nQ2FjaGUiLCJtZWFzdXJlc0NhY2hlIiwiTWFwIiwicGF0aEVsZW1lbnQiLCJkYXRhQXJyYXkiLCJwYXJzZVBhdGhEYXRhIiwidGhldGEiLCJkVGhldGEiLCJwc2kiLCJmcyIsInNldFRleHREYXRhIiwidGV4dERlY29yYXRpb24iLCJyb3RhdGlvbiIsInBhcnRpYWxUZXh0IiwiZ2V0TGV0dGVyU3BhY2luZ0F0IiwiaWR4IiwiZmluZFNlZ21lbnRUb0ZpdENoYXIiLCJhbmNob3IiLCJ0ZXh0RnVsbFdpZHRoIiwiZnVsbFBhdGhXaWR0aCIsInNwYWNlc051bWJlciIsImlucHV0T2Zmc2V0IiwiZHkiLCJjaGFySSIsImdseXBoV2lkdGgiLCJzcGxpbmVTdGVwIiwiZ2V0RXF1aWRpc3RhbnRQb2ludE9uUGF0aCIsInNlZ21lbnQiLCJkeVgiLCJkeVkiLCJoYXMiLCJnZXQiLCJjaGFycyIsInRoaXNTcGFjaW5nIiwicGFyZW50U3BhY2luZyIsImxldHRlclNwYWNpbmciLCJ0ZXh0TGVuIiwiZHhTdW0iLCJhY2MiLCJjdXIiLCJnZXRQYXRoTGVuZ3RoIiwic3RhcnRPZmZzZXQiLCJuZXh0T2Zmc2V0IiwicGF0aENvbW1hbmRzIiwic3RhcnRYIiwic3RhcnRZIiwibmV4dENvbW1hbmRUeXBlIiwiY2FsY0xlbmd0aCIsImNvbW1hbmRUeXBlIiwiZ2V0TGluZUxlbmd0aCIsImdldFBvaW50T25DdWJpY0JlemllciIsImdldFBvaW50T25RdWFkcmF0aWNCZXppZXIiLCJlbmQiLCJpbmMiLCJhYnMiLCJnZXRQb2ludE9uRWxsaXB0aWNhbEFyYyIsImdldFBvaW50T25MaW5lIiwiZGlzdCIsImZyb21YIiwiZnJvbVkiLCJtIiwicmlzZSIsInB0IiwiaXgiLCJpeSIsInBSaXNlIiwicFJ1biIsImdldFBvaW50T25QYXRoIiwiZGlzdGFuY2UiLCJmdWxsTGVuIiwiY3VtdWxhdGl2ZVBhdGhMZW5ndGgiLCJjdXJyZW50VCIsInBjdCIsInA0eCIsInA0eSIsImNvc1BzaSIsInNpblBzaSIsImJ1aWxkRXF1aWRpc3RhbnRDYWNoZSIsImlucHV0U3RlcCIsImlucHV0UHJlY2lzaW9uIiwicHJlY2lzaW9uIiwic3RlcCIsImVxdWlkaXN0YW50Q2FjaGUiLCJ0YXJnZXREaXN0YW5jZSIsImRhdGFVcmlSZWdleCIsIkltYWdlRWxlbWVudCIsImxvYWRlZCIsImhyZWYiLCJpc1N2ZyIsImltYWdlcyIsImxvYWRTdmciLCJpbWFnZSIsImNvbnNvbGUiLCJlcnJvciIsImF0b2IiLCJkZWNvZGVVUklDb21wb25lbnQiLCJzdmciLCJzdWJEb2N1bWVudCIsImNhbnZnIiwiZm9ya1N0cmluZyIsImRvY3VtZW50RWxlbWVudCIsIl9pbWFnZSIsImNvbXBsZXRlIiwiZHJhd0ltYWdlIiwiU3ltYm9sRWxlbWVudCIsIlNWR0ZvbnRMb2FkZXIiLCJmb250cyIsInN2Z0RvY3VtZW50IiwiZm9udE5vZGUiLCJTdHlsZUVsZW1lbnQiLCJjc3MiLCJjc3NEZWZzIiwiY3NzUGFydHMiLCJjc3NDbGFzc2VzIiwiY3NzUHJvcHMiLCJjc3NDbGFzcyIsInByb3BzIiwiY3NzUHJvcCIsInN1YnN0ciIsInNyY3MiLCJzcmMiLCJVc2VFbGVtZW50IiwidGVtcFN2ZyIsIm9sZFBhcmVudCIsImVsZW1lbnRUcmFuc2Zvcm0iLCJjYWNoZWRFbGVtZW50IiwiaW1HZXQiLCJfaGVpZ2h0IiwicmdiYSIsImltU2V0IiwidmFsIiwibWkiLCJtMSIsIm0yIiwibTMiLCJGZUNvbG9yTWF0cml4RWxlbWVudCIsImluY2x1ZGVPcGFjaXR5IiwiX3giLCJfeSIsInNyY0RhdGEiLCJnZXRJbWFnZURhdGEiLCJuciIsIm5nIiwibmIiLCJuYSIsInB1dEltYWdlRGF0YSIsIk1hc2tFbGVtZW50IiwiaWdub3JlZFN0eWxlcyIsIm1hc2tDYW52YXMiLCJtYXNrQ3R4IiwidG1wQ2FudmFzIiwidG1wQ3R4IiwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIiwiZmlsbFJlY3QiLCJub29wIiwiQ2xpcFBhdGhFbGVtZW50IiwiY29udGV4dFByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCJGaWx0ZXJFbGVtZW50IiwicHgiLCJweSIsImVmZCIsImV4dHJhRmlsdGVyRGlzdGFuY2UiLCJ0bXBDYW52YXNXaWR0aCIsInRtcENhbnZhc0hlaWdodCIsIkZlRHJvcFNoYWRvd0VsZW1lbnQiLCJfd2lkdGgiLCJGZU1vcnBob2xvZ3lFbGVtZW50IiwiRmVDb21wb3NpdGVFbGVtZW50IiwiRmVHYXVzc2lhbkJsdXJFbGVtZW50IiwiYmx1clJhZGl1cyIsImJvZHkiLCJnZXRVbmlxdWVJZCIsImRpc3BsYXkiLCJhcHBlbmRDaGlsZCIsInJlbW92ZUNoaWxkIiwiVGl0bGVFbGVtZW50IiwiRGVzY0VsZW1lbnQiLCJlbGVtZW50cyIsIm93bktleXMkMSIsIl9vYmplY3RTcHJlYWQkMSIsIl9jcmVhdGVJbWFnZSIsImFub255bW91c0Nyb3NzT3JpZ2luIiwiY3Jvc3NPcmlnaW4iLCJyZWplY3QiLCJvbmxvYWQiLCJvbmVycm9yIiwiX2V2ZW50IiwiX3NvdXJjZSIsIl9saW5lbm8iLCJfY29sbm8iLCJEb2N1bWVudCIsImVtU2l6ZVN0YWNrIiwidW5pcXVlSWQiLCJiaW5kQ3JlYXRlSW1hZ2UiLCJpc0ltYWdlc0xvYWRlZCIsImlzRm9udHNMb2FkZWQiLCJmb3JjZUFub255bW91c0Nyb3NzT3JpZ2luIiwiY3JlYXRlRG9jdW1lbnRFbGVtZW50IiwiZWxlbWVudFR5cGUiLCJFbGVtZW50VHlwZSIsImVsZW1lbnRUeXBlcyIsImNvbmZpZyIsIm93bktleXMiLCJfb2JqZWN0U3ByZWFkIiwiQ2FudmciLCJvcHRpb25zIiwiX2FyZ3VtZW50cyIsImZyb21TdHJpbmciLCJmb3JrIiwiX2FyZ3VtZW50czIiLCJiYXNlT3B0aW9ucyIsImRlZmF1bHQiLCJwcmVzZXRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/canvg/lib/index.es.js\n");

/***/ })

};
;